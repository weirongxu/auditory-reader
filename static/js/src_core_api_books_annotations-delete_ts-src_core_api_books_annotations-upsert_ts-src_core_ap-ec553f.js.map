{"version":3,"file":"static/js/src_core_api_books_annotations-delete_ts-src_core_api_books_annotations-upsert_ts-src_core_ap-ec553f.js","sources":["/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/annotations-delete.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/annotations-upsert.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/annotations.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/cover.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/create-by-url.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/create.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/download.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/fetch-url-info.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/keywords-delete.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/keywords-upsert.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/keywords.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/move-after.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/move-top.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/page.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/position-sync.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/position.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/remove.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/render.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/search.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/show.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/tmp-store.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/update.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/books/view.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/login.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/logout.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/api/user.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/book/book-base.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/book/book-epub.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/book/book-manager.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/book/book-text.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/book/entity/book-entity-base.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/book/entity/book-entity-fs.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/book/entity/book-entity-indexed-db.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/book/indexedDB.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/book/list/book-list-base.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/book/list/book-list-fs.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/book/list/book-list-indexed-db.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/consts.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/env.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/generate/epub-gen.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/lang.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/route/action.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/route/router.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/route/session.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/util/browser.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/util/collection.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/util/converter.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/util/dom.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/util/http.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/util/random.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/util/readable.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/util/text.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/util/url.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/util/xml-dom.ts","/home/runner/work/auditory-reader/auditory-reader/src/web/common/notification.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/store/global.ts"],"sourcesContent":["import { bookManager } from '../../book/book-manager.js'\nimport { URouter } from '../../route/router.js'\nimport type { BookViewQuery } from './view.js'\n\ninterface BookAnnotationDelete extends BookViewQuery {\n  annotationUuids: string[]\n}\n\nexport const booksAnnotationsDeleteRouter = new URouter<\n  BookAnnotationDelete,\n  { ok: boolean }\n>('books/annotations-delete').routeLogined(async ({ req, userInfo }) => {\n  const body = await req.body\n  const bookEntity = await bookManager.entity(userInfo.account, body.uuid)\n  await bookEntity.annotationsDelete(body.annotationUuids)\n  return { ok: true }\n})\n","import { v1 as uuidv1 } from 'uuid'\nimport { bookManager } from '../../book/book-manager.js'\nimport type { BookTypes } from '../../book/types.js'\nimport { URouter } from '../../route/router.js'\nimport type { BookViewQuery } from './view.js'\n\ntype AnnotationUpsert = Omit<BookTypes.PropertyAnnotation, 'uuid'> & {\n  uuid: string | null\n}\n\ninterface BookAnnotationUpsert extends BookViewQuery {\n  annotations: AnnotationUpsert[]\n}\n\nexport const booksAnnotationsUpsertRouter = new URouter<\n  BookAnnotationUpsert,\n  { ok: boolean; annotations: BookTypes.PropertyAnnotation[] }\n>('books/annotations-upsert').routeLogined(async ({ req, userInfo }) => {\n  const body = await req.body\n  const bookEntity = await bookManager.entity(userInfo.account, body.uuid)\n  const annotations = body.annotations.map((n) => {\n    n.uuid = n.uuid || uuidv1()\n    return n as BookTypes.PropertyAnnotation\n  })\n  return {\n    ok: true,\n    annotations: await bookEntity.annotationsUpsert(annotations),\n  }\n})\n","import { bookManager } from '../../book/book-manager.js'\nimport type { BookTypes } from '../../book/types.js'\nimport { URouter } from '../../route/router.js'\nimport type { BookViewQuery } from './view.js'\n\nexport const booksAnnotationsRouter = new URouter<\n  BookViewQuery,\n  BookTypes.PropertyAnnotation[]\n>('books/annotations').routeLogined(async ({ req, userInfo }) => {\n  const body = await req.body\n  const bookEntity = await bookManager.entity(userInfo.account, body.uuid)\n  return bookEntity.annotationsGet()\n})\n","import { bookManager } from '../../book/book-manager.js'\nimport type { BookTypes } from '../../book/types.js'\nimport { URouter } from '../../route/router.js'\nimport { ErrorRequestResponse } from '../../route/session.js'\n\nexport type BookCoverQuery = {\n  uuid: BookTypes.EntityUUID\n}\n\nexport const booksCoverRouter = new URouter<BookCoverQuery>('books/cover', {\n  method: 'get',\n}).routeLogined(async ({ req, res, userInfo }) => {\n  const uuid = req.searchParams.get('uuid')\n  if (!uuid) {\n    throw new ErrorRequestResponse('uuid parameter required')\n  }\n  const book = await bookManager.book(userInfo.account, uuid)\n\n  const file = await book.cover()\n  if (!file) throw new ErrorRequestResponse('cover in book not found')\n\n  if (file.mediaType) res.header('Content-Type', file.mediaType.toString())\n  return file.buffer\n})\n\nexport const getBooksCoverPath = (uuid: string) =>\n  `${booksCoverRouter.fullRoutePath}?uuid=${uuid}`\n","import { Readability } from '@mozilla/readability'\nimport { v1 as uuidv1 } from 'uuid'\nimport { bookManager } from '../../book/book-manager.js'\nimport type { BookTypes } from '../../book/types.js'\nimport { env } from '../../env.js'\nimport { EpubGen } from '../../generate/epub-gen.js'\nimport type { LangCode } from '../../lang.js'\nimport { URouter } from '../../route/router.js'\nimport { HTMLImgs2DataURL, jsDOMParser } from '../../util/dom.js'\nimport { fetchDom } from '../../util/http.js'\n\nexport type BookCreateByUrl = {\n  name: string\n  langCode: LangCode\n  url: string\n  /**\n   * @default false\n   */\n  isTmp?: boolean\n}\n\nexport const booksCreateByUrlRouter = new URouter<\n  BookCreateByUrl,\n  BookTypes.EntityJson\n>('books/create-by-url').routeLogined(async ({ req, userInfo }) => {\n  const body: BookCreateByUrl = await req.body\n\n  const uuid = uuidv1()\n\n  const date = new Date()\n  const entity: BookTypes.Entity = {\n    uuid,\n    name: body.name,\n    type: 'epub',\n    langCode: body.langCode,\n    isFavorited: false,\n    isArchived: false,\n    createdAt: date,\n    updatedAt: date,\n    isTmp: body.isTmp ?? false,\n  }\n\n  const dom = await fetchDom(body.url)\n  const doc = dom.doc\n  const article = new Readability(doc).parse()\n\n  if (!article) throw new Error('parse article error')\n\n  const articleDom = await jsDOMParser(article.content)\n  const articleDoc = articleDom.doc\n\n  if (env.appMode === 'server')\n    await HTMLImgs2DataURL(body.url, articleDoc.body)\n\n  const htmlContent = new articleDom.view.XMLSerializer().serializeToString(\n    articleDoc.body,\n  )\n\n  const epubBuf = await new EpubGen({\n    title: body.name,\n    date,\n    htmlContent,\n    lang: body.langCode,\n    publisher: body.url,\n    sourceURL: body.url,\n    uuid,\n  }).gen()\n\n  const entityJson = await bookManager\n    .list(userInfo.account)\n    .add(entity, epubBuf)\n\n  return entityJson\n})\n","import { v1 as uuidv1 } from 'uuid'\nimport { bookManager } from '../../book/book-manager.js'\nimport type { BookTypes } from '../../book/types.js'\nimport type { LangCode } from '../../lang.js'\nimport { URouter } from '../../route/router.js'\nimport { base64ToArrayBuffer } from '../../util/converter.js'\n\nexport type BookCreate = {\n  name: string\n  langCode: LangCode\n  type: BookTypes.EntityType\n  bufferBase64: string\n  /**\n   * @default false\n   */\n  isTmp?: boolean\n}\n\nexport const booksCreateRouter = new URouter<BookCreate, BookTypes.EntityJson>(\n  'books/create',\n).routeLogined(async ({ req, userInfo }) => {\n  const body = await req.body\n  const buf = base64ToArrayBuffer(body.bufferBase64)\n  const uuid = uuidv1()\n\n  const entity: BookTypes.Entity = {\n    uuid,\n    name: body.name,\n    type: body.type,\n    langCode: body.langCode,\n    isFavorited: false,\n    isArchived: false,\n    createdAt: new Date(),\n    updatedAt: new Date(),\n    isTmp: body.isTmp ?? false,\n  }\n\n  const entityJson = await bookManager.list(userInfo.account).add(entity, buf)\n\n  return entityJson\n})\n","import { bookManager } from '../../book/book-manager.js'\nimport { URouter } from '../../route/router.js'\nimport { ErrorRequestResponse } from '../../route/session.js'\n\nexport type BookDownloadQuery = {\n  uuid: string\n}\n\nexport const booksDownloadRouter = new URouter<\n  BookDownloadQuery,\n  ArrayBuffer | undefined\n>('books/download', {\n  method: 'get',\n}).routeLogined(async ({ req, res, userInfo }) => {\n  const searchParams = req.searchParams\n  const uuid = searchParams.get('uuid')\n  if (!uuid) throw new ErrorRequestResponse('uuid parameter required')\n  const bookEntity = await bookManager.entity(userInfo.account, uuid)\n  const { contentType, buffer, filename } = await bookEntity.download()\n  res.header('Content-Type', contentType)\n  res.header(\n    'Content-Disposition',\n    `attachment; filename=\"${encodeURI(filename)}\"`,\n  )\n  return buffer\n})\n","import { Readability } from '@mozilla/readability'\nimport type { LangCode } from '../../lang.js'\nimport { parseLangCode } from '../../lang.js'\nimport { URouter } from '../../route/router.js'\nimport { fetchDom } from '../../util/http.js'\n\nexport type BookFetchUrlInfoQuery = {\n  url: string\n}\n\nexport type BookFetchUrlInfo = {\n  title: string\n  lang?: LangCode\n}\n\nexport const booksFetchUrlInfoRouter = new URouter<\n  BookFetchUrlInfoQuery,\n  BookFetchUrlInfo\n>('books/fetch-url-info').routeLogined(async ({ req }) => {\n  const body = await req.body\n\n  const dom = await fetchDom(body.url)\n  const doc = dom.doc\n  const article = new Readability(doc).parse()\n  let title: string, lang: string | undefined\n  if (article) {\n    title = article.title\n    // @ts-ignore\n    lang = article.lang as string | undefined\n  } else {\n    const titleDom =\n      doc.querySelector('article h1') ??\n      doc.querySelector('h1') ??\n      doc.querySelector('meta[name=og\\\\:title]') ??\n      doc.querySelector('head>title')\n    title = titleDom?.textContent?.trim() ?? ''\n  }\n\n  lang ??= doc.activeElement?.getAttribute('lang') ?? undefined\n\n  const langCode = parseLangCode(lang)\n\n  const info: BookFetchUrlInfo = {\n    title,\n    lang: langCode,\n  }\n\n  return info\n})\n","import { bookManager } from '../../book/book-manager.js'\nimport { URouter } from '../../route/router.js'\nimport type { BookViewQuery } from './view.js'\n\ninterface BookKeywordDelete extends BookViewQuery {\n  keywordUuids: string[]\n}\n\nexport const booksKeywordsDeleteRouter = new URouter<\n  BookKeywordDelete,\n  { ok: boolean }\n>('books/keywords-delete').routeLogined(async ({ req, userInfo }) => {\n  const body = await req.body\n  const bookEntity = await bookManager.entity(userInfo.account, body.uuid)\n  await bookEntity.keywordsDelete(body.keywordUuids)\n  return { ok: true }\n})\n","import { v1 as uuidv1 } from 'uuid'\nimport { bookManager } from '../../book/book-manager.js'\nimport type { BookTypes } from '../../book/types.js'\nimport { URouter } from '../../route/router.js'\nimport type { BookViewQuery } from './view.js'\n\ntype KeywordUpsert = Omit<BookTypes.PropertyKeyword, 'uuid'> & {\n  uuid: string | null\n}\n\ninterface BookKeywordUpsert extends BookViewQuery {\n  keywords: KeywordUpsert[]\n}\n\nexport const booksKeywordsUpsertRouter = new URouter<\n  BookKeywordUpsert,\n  { ok: boolean; keywords: BookTypes.PropertyKeyword[] }\n>('books/keywords-upsert').routeLogined(async ({ req, userInfo }) => {\n  const body = await req.body\n  const bookEntity = await bookManager.entity(userInfo.account, body.uuid)\n  const keywords = body.keywords.map((n) => {\n    n.uuid = n.uuid || uuidv1()\n    return n as BookTypes.PropertyKeyword\n  })\n  return {\n    ok: true,\n    keywords: await bookEntity.keywordsUpsert(keywords),\n  }\n})\n","import { bookManager } from '../../book/book-manager.js'\nimport type { BookTypes } from '../../book/types.js'\nimport { URouter } from '../../route/router.js'\nimport type { BookViewQuery } from './view.js'\n\nexport const booksKeywordsRouter = new URouter<\n  BookViewQuery,\n  BookTypes.PropertyKeyword[]\n>('books/keywords').routeLogined(async ({ req, userInfo }) => {\n  const body = await req.body\n  const bookEntity = await bookManager.entity(userInfo.account, body.uuid)\n  return bookEntity.keywordsGet()\n})\n","import { bookManager } from '../../book/book-manager.js'\nimport { URouter } from '../../route/router.js'\n\nexport type BookMoveOffsetItQuery = {\n  uuid: string\n  afterUuid: string\n}\n\nexport const booksMoveAfterRouter = new URouter<BookMoveOffsetItQuery>(\n  'books/move-after',\n).routeLogined(async ({ req, userInfo }) => {\n  const body = await req.body\n  const book = bookManager.list(userInfo.account)\n  await book.moveAfter(body.uuid, body.afterUuid)\n  return { ok: true }\n})\n","import { bookManager } from '../../book/book-manager.js'\nimport { URouter } from '../../route/router.js'\n\nexport type BookMoveTopItQuery = {\n  uuid: string\n}\n\nexport const booksMoveTopRouter = new URouter<BookMoveTopItQuery>(\n  'books/move-top',\n).routeLogined(async ({ req, userInfo }) => {\n  const body = await req.body\n  const book = bookManager.list(userInfo.account)\n  await book.moveTop(body.uuid)\n  return { ok: true }\n})\n","import { bookManager } from '../../book/book-manager.js'\nimport type { BookTypes } from '../../book/types.js'\nimport { URouter } from '../../route/router.js'\n\nexport type BookPost = {\n  filter: Partial<BookTypes.FilterParams>\n  page: {\n    page?: number\n    perPage?: number\n  }\n}\n\nexport type BookPage = {\n  items: BookTypes.Entity[]\n  current: number\n  count: number\n  pageCount: number\n}\n\nexport const booksPageRouter = new URouter<BookPost, BookPage>(\n  'books/page',\n).routeLogined(async ({ req, userInfo }) => {\n  const body = await req.body\n  const { page, filter } = body\n  const data = await bookManager.list(userInfo.account).page(filter, page)\n  return {\n    items: data.items,\n    current: data.page,\n    pageCount: data.pageCount,\n    count: data.count,\n  }\n})\n","import { bookManager } from '../../book/book-manager.js'\nimport type { BookTypes } from '../../book/types.js'\nimport { URouter } from '../../route/router.js'\n\ntype PositionSyncPost = {\n  uuid: BookTypes.EntityUUID\n  pos: BookTypes.PropertyPosition\n}\n\nexport const booksPositionSyncRouter = new URouter<PositionSyncPost, any>(\n  'books/position-sync',\n).routeLogined(async ({ req, userInfo }) => {\n  const body = await req.body\n  const bookEntity = await bookManager.entity(userInfo.account, body.uuid)\n  await bookEntity.posSet(body.pos)\n  return { ok: true }\n})\n","import { bookManager } from '../../book/book-manager.js'\nimport type { BookTypes } from '../../book/types.js'\nimport { URouter } from '../../route/router.js'\nimport type { BookViewQuery } from './view.js'\n\nexport const booksPositionRouter = new URouter<\n  BookViewQuery,\n  BookTypes.PropertyPosition\n>('books/position').routeLogined(async ({ req, userInfo }) => {\n  const body = await req.body\n  const bookEntity = await bookManager.entity(userInfo.account, body.uuid)\n  return await bookEntity.posGet()\n})\n","import { bookManager } from '../../book/book-manager.js'\nimport { URouter } from '../../route/router.js'\n\nexport type BookRemoveQuery = {\n  uuid: string\n}\n\nexport const booksRemoveRouter = new URouter<BookRemoveQuery>(\n  'books/remove',\n).routeLogined(async ({ req, userInfo }) => {\n  const body = await req.body\n  await bookManager.delete(userInfo.account, body.uuid)\n  return { ok: true }\n})\n","import mime from 'mime-types'\nimport path from '@file-services/path'\nimport { bookManager } from '../../book/book-manager.js'\nimport { URouter } from '../../route/router.js'\nimport { ErrorRequestResponse } from '../../route/session.js'\n\nexport const booksRenderRouter = new URouter('books/render', {\n  method: 'get',\n  isDynamic: true,\n}).routeLogined(async ({ req, res, userInfo }) => {\n  const [uuid, ...paths] = req.paths\n  if (!uuid) throw new ErrorRequestResponse('uuid not found')\n  const book = await bookManager.book(userInfo.account, uuid)\n  const filepath = decodeURI(path.join(...paths))\n  const file = await book.file(filepath)\n  if (!file) throw new ErrorRequestResponse('Path in book not found')\n  const contType = file.mediaType ?? mime.contentType(path.basename(filepath))\n  if (contType) res.header('Content-Type', contType)\n  return file.buffer\n})\n\nexport const getBooksRenderPath = (uuid: string, paths: string) =>\n  path.join(booksRenderRouter.fullRoutePath, uuid, paths)\n","import mime from 'mime-types'\nimport path from '@file-services/path'\nimport { bookManager } from '../../book/book-manager.js'\nimport { URouter } from '../../route/router.js'\nimport { jsDOMParser } from '../../util/dom.js'\nimport { ReadableExtractor } from '../../util/readable.js'\n\nexport type BookSearchQuery = {\n  uuid: string\n  search: string\n}\n\nexport type BookSearchResponse = {\n  search: string\n  matches: BookSearchMatch[]\n}\n\nexport type BookSearchMatch = {\n  text: string\n  section: number\n  paragraph: number\n  start: number\n  nav?: string\n}\n\nfunction searchAllIndex(content: string, search: string) {\n  const indexes: number[] = []\n  let startIndex = 0\n  while (startIndex !== -1) {\n    startIndex = content.indexOf(search, startIndex)\n    if (startIndex !== -1) {\n      indexes.push(startIndex)\n      startIndex += search.length\n    }\n  }\n  return indexes\n}\n\nexport const booksSearchRouter = new URouter<\n  BookSearchQuery,\n  BookSearchResponse\n>('books/search').routeLogined(async ({ req, userInfo }) => {\n  const body = await req.body\n  const book = await bookManager.book(userInfo.account, body.uuid)\n  const navs = await book.navs()\n  const matches: BookSearchMatch[] = []\n  for (const [section, spine] of book.spines.entries()) {\n    const filepath = spine.href\n    const file = await book.file(filepath)\n    if (!file) continue\n    const content = file.buffer.toString('utf-8')\n    const contType = file.mediaType ?? mime.contentType(path.basename(filepath))\n    if (\n      contType &&\n      ['/xml', '/html', '/xhtml'].some((t) => contType.includes(t))\n    ) {\n      const { doc } = await jsDOMParser(content)\n      const readableExtractor = new ReadableExtractor(doc, navs)\n      const parts = readableExtractor.toReadableParts()\n      const nav = navs.find((it) => it.spineIndex === section)\n      for (const [paragraph, part] of parts.entries()) {\n        if (part.type !== 'text') continue\n        const startIndexes = searchAllIndex(part.text, body.search)\n        if (!startIndexes.length) continue\n        for (const startIndex of startIndexes)\n          matches.push({\n            text: part.text,\n            section,\n            paragraph,\n            start: startIndex,\n            nav: nav?.label,\n          })\n      }\n    }\n  }\n  return { search: body.search, matches }\n})\n","import { bookManager } from '../../book/book-manager.js'\nimport type { BookTypes } from '../../book/types.js'\nimport { URouter } from '../../route/router.js'\n\nexport type BookShowQuery = {\n  uuid: string\n}\n\nexport const booksShowRouter = new URouter<\n  BookShowQuery,\n  BookTypes.Entity | undefined\n>('books/show').routeLogined(async ({ req, userInfo }) => {\n  const body = await req.body\n  const bookEntity = await bookManager.entity(userInfo.account, body.uuid)\n  return bookEntity.entity\n})\n","import { v1 as uuidv1 } from 'uuid'\nimport { bookManager } from '../../book/book-manager.js'\nimport type { BookTypes } from '../../book/types.js'\nimport { TMP_UUID } from '../../consts.js'\nimport type { LangCode } from '../../lang.js'\nimport { URouter } from '../../route/router.js'\n\nexport type BookCreate = {\n  name: string\n  langCode: LangCode\n  type: BookTypes.EntityType\n  bufferBase64: string\n  /**\n   * @default false\n   */\n  isTmp?: boolean\n}\n\nexport const booksTmpStoreRouter = new URouter<any, BookTypes.EntityJson>(\n  'books/tmp-store',\n).routeLogined(async ({ userInfo }) => {\n  const bookEntityTmp = await bookManager.entity(userInfo.account, TMP_UUID)\n  const uuid = uuidv1()\n\n  const entity: BookTypes.Entity = {\n    uuid,\n    name: bookEntityTmp.entity.name,\n    type: bookEntityTmp.entity.type,\n    langCode: bookEntityTmp.entity.langCode,\n    isFavorited: bookEntityTmp.entity.isFavorited,\n    isArchived: bookEntityTmp.entity.isArchived,\n    createdAt: new Date(),\n    updatedAt: new Date(),\n    isTmp: false,\n  }\n\n  const buf = await bookEntityTmp.readFileBuffer()\n  const pos = await bookEntityTmp.posGet()\n  const annotations = await bookEntityTmp.annotationsGet()\n\n  const entityJson = await bookManager.list(userInfo.account).add(entity, buf)\n\n  const bookEntity = await bookManager.entity(userInfo.account, entityJson.uuid)\n  await bookEntity.posSet(pos)\n  await bookEntity.annotationsUpsert(annotations)\n\n  return entityJson\n})\n","import { bookManager } from '../../book/book-manager.js'\nimport type { BookTypes } from '../../book/types.js'\nimport { URouter } from '../../route/router.js'\n\nexport type BookUpdateQuery = {\n  uuid: string\n  update: BookTypes.EntityUpdate\n}\n\nexport const booksUpdateRouter = new URouter<BookUpdateQuery, object>(\n  'books/update',\n).routeLogined(async ({ req, userInfo }) => {\n  const body = await req.body\n  await bookManager.update(userInfo.account, body.uuid, body.update)\n  return { ok: true }\n})\n","import type { BookNav, BookSpine } from '../../book/book-base.js'\nimport { bookManager } from '../../book/book-manager.js'\nimport type { BookTypes } from '../../book/types.js'\nimport { URouter } from '../../route/router.js'\n\nexport type BookViewQuery = {\n  uuid: BookTypes.EntityUUID\n}\n\nexport type BookViewRes = {\n  item: BookTypes.Entity\n  navs: BookNav[]\n  spines: BookSpine[]\n}\n\nexport const booksViewRouter = new URouter<BookViewQuery, BookViewRes>(\n  'books/view',\n).routeLogined(async ({ req, userInfo }) => {\n  const body = await req.body\n  const bookEntity = await bookManager.entity(userInfo.account, body.uuid)\n  const book = await bookManager.book(userInfo.account, body.uuid)\n  return {\n    item: bookEntity.entity,\n    navs: await book.navs(),\n    spines: book.spines,\n  }\n})\n","import { URouter } from '../route/router.js'\n\nexport type LoginReq = {\n  account: string\n  password: string\n}\n\nexport type LoginRes = {\n  ok: boolean\n}\n\nexport const loginRouter = new URouter<LoginReq, LoginRes>('login').route(\n  async ({ req }) => {\n    const session = req.session\n    const body = await req.body\n    const logined = await session.userLogin(body.account, body.password)\n    return {\n      ok: logined,\n    }\n  },\n)\n","import { URouter } from '../route/router.js'\n\nexport type LogoutRes = {\n  ok: boolean\n}\n\nexport const logoutRouter = new URouter<void, LogoutRes>('logout').route(\n  async ({ req }) => {\n    const session = req.session\n    await session.userLogout()\n    return { ok: true }\n  },\n)\n","import { URouter } from '../route/router.js'\nimport type { UserInfo } from '../route/session.js'\n\nexport type UserRes = {\n  info?: UserInfo\n}\n\nexport const userRouter = new URouter<null, UserRes>('user').route(\n  ({ req }) => {\n    const info = req.session.userInfo()\n    return { info }\n  },\n)\n","import type { BookViewRes } from '../api/books/view.js'\n\nexport interface BookView extends BookViewRes {\n  flattenedNavs: BookNav[]\n}\n\nexport type BookNav = {\n  /** root (minimum) level is 1 */\n  level: number\n  label: string\n  href?: string\n  hrefBase?: string\n  hrefAnchor?: string\n  spineIndex?: number\n  children: BookNav[]\n}\n\nexport type BookSpine = {\n  id: string\n  href: string\n}\n\nexport type BookFile = {\n  buffer: Buffer\n  mediaType?: string\n}\n\nexport abstract class BookBase {\n  abstract readonly spines: BookSpine[]\n\n  abstract navs(): Promise<BookNav[]>\n\n  abstract file(href: string): Promise<BookFile | undefined>\n\n  abstract cover(): Promise<BookFile | undefined>\n}\n","import JSZip from 'jszip'\nimport path from '@file-services/path'\nimport { compact } from '../util/collection.js'\nimport { arrayBufferToBuffer } from '../util/converter.js'\nimport type { XMLElem } from '../util/xml-dom.js'\nimport { XMLDOMLoader } from '../util/xml-dom.js'\nimport type { BookFile, BookNav, BookSpine } from './book-base.js'\nimport { BookBase } from './book-base.js'\n\ntype ManifestItem = {\n  id: string\n  href: string\n  mediaType: string\n  properties?: string\n}\n\ntype SpineItem = {\n  manifest: ManifestItem\n  idref: string\n  linear: string\n}\n\n// JSDOM unsupported :scope selector\n\n/**\n * Implementation `:scope` selector\n * ```\n * querySelectorAll(':scope>navPoint .class') <=> scopeQuerySelectorAll(dom, ['navPoint'], '.class')\n * querySelectorAll(':scope>navLabel>text .class') <=> scopeQuerySelectorAll(dom, ['navLabel', 'text'], '.class')\n * ```\n */\nfunction* scopeQuerySelectorAll(\n  scope: Element,\n  childTags: string[],\n  selector?: string,\n): Generator<Element, undefined, void> {\n  const [tag, ...remainTags] = childTags\n  if (!tag) {\n    if (selector) {\n      for (const el of scope.querySelectorAll(selector)) {\n        yield el\n      }\n    } else {\n      yield scope\n    }\n    return\n  }\n  for (const el of scope.children) {\n    if (tag === '*' || el.tagName.toLowerCase() === tag.toLowerCase()) {\n      yield* scopeQuerySelectorAll(el, remainTags, selector)\n    }\n  }\n}\n\nexport const NAV_TOC_SELECTOR = 'nav[epub\\\\:type=\"toc\"]'\n\n/**\n * Implementation `:scope` selector\n * ```\n * querySelector(':scope>navPoint') <=> scopeQuerySelector(dom, ['navPoint'])\n * querySelector(':scope>navLabel>text') <=> scopeQuerySelector(dom, ['navLabel', 'text'])\n * ```\n */\nfunction scopeQuerySelector(\n  scope: Element,\n  childTags: string[],\n  selector?: string,\n): Element | null {\n  const first = scopeQuerySelectorAll(scope, childTags, selector).next()\n  return first.value ?? null\n}\n\nexport class BookEpub extends BookBase {\n  protected static async getRootPath(xml: XMLDOMLoader) {\n    const containerRoot = await xml.htmlDom('META-INF/container.xml')\n    if (!containerRoot) {\n      console.error('Parse META-INF/container.xml error')\n      return\n    }\n    const rootfilePath = containerRoot\n      .querySelector('rootfile')\n      ?.getAttribute('full-path')\n    if (!rootfilePath) {\n      console.error('rootfile full-path not found')\n      return\n    }\n    return path.join('/', rootfilePath)\n  }\n\n  static async read(buffer: ArrayBuffer): Promise<BookEpub | undefined> {\n    const zip = await JSZip.loadAsync(buffer)\n    const xml = new XMLDOMLoader(zip)\n    const rootPath = await this.getRootPath(xml)\n    if (!rootPath) {\n      console.error(`epub root-path(${rootPath}) not found`)\n      return\n    }\n    const rootDoc = await xml.xmlDom(rootPath)\n    if (!rootDoc) {\n      console.error(`epub root document not found`)\n      return\n    }\n    return new BookEpub(zip, xml, rootDoc, path.dirname(rootPath))\n  }\n\n  protected constructor(\n    protected zip: JSZip,\n    protected xmlLoader: XMLDOMLoader,\n    protected rootPkg: XMLElem,\n    protected rootDir: string,\n  ) {\n    super()\n  }\n\n  #version?: 2 | 3\n  get version(): 2 | 3 {\n    if (!this.#version) {\n      const versionStr = this.rootPkg.getAttribute('version') ?? '2.0'\n      this.#version = parseFloat(versionStr) >= 3 ? 3 : 2\n    }\n    return this.#version\n  }\n\n  #title?: string | null\n  get title() {\n    if (!this.#title) {\n      const titleElem = this.rootPkg\n        .findDescendant('metadata')\n        ?.findDescendant('dc:title')\n      this.#title = titleElem?.text()?.trim() ?? null\n    }\n    return this.#title\n  }\n\n  #language?: string | null\n  get language() {\n    if (!this.#language) {\n      const langElem = this.rootPkg\n        .findDescendant('metadata')\n        ?.findDescendant('dc:language')\n      this.#language = langElem?.text()?.trim() ?? null\n    }\n    return this.#language\n  }\n\n  #manifestItems?: ManifestItem[]\n  get manifestItems(): ManifestItem[] {\n    if (!this.#manifestItems) {\n      const items =\n        this.rootPkg.findDescendant('manifest')?.childrenFilter('item') ?? []\n      this.#manifestItems = items.map((item) => {\n        return {\n          id: item.getAttribute('id')!,\n          href: path.join(this.rootDir, item.getAttribute('href')!),\n          mediaType: item.getAttribute('media-type')!,\n          properties: item.getAttribute('properties') ?? undefined,\n        }\n      })\n    }\n    return this.#manifestItems\n  }\n\n  #spine?: XMLElem\n  get spine(): XMLElem {\n    if (!this.#spine) {\n      // spine\n      this.#spine = this.rootPkg.findDescendant('spine') ?? undefined\n      if (!this.#spine) throw new Error('spine not found')\n    }\n    return this.#spine\n  }\n\n  #spineItems?: SpineItem[]\n  get spineItems(): SpineItem[] {\n    if (!this.#spineItems) {\n      this.#spineItems = compact(\n        [...this.spine.childrenFilter('itemref')].map((item) => {\n          const idref = item.getAttribute('idref')!\n          const manifest = this.manifestItems.find((m) => m.id === idref)\n          if (!manifest) return\n          return {\n            manifest,\n            idref,\n            linear: item.getAttribute('linear')!,\n          }\n        }),\n      )\n    }\n    return this.#spineItems\n  }\n\n  #spines?: BookSpine[]\n  get spines(): BookSpine[] {\n    if (!this.#spines) {\n      this.#spines = this.spineItems.map((s) => ({\n        href: s.manifest.href,\n        id: s.idref,\n      }))\n    }\n    return this.#spines\n  }\n\n  async file(href: string): Promise<BookFile | undefined> {\n    const file = await this.xmlLoader.file(href)\n    if (!file) return\n    const arrBuf = await file.arrayBuffer()\n    const buffer = arrayBufferToBuffer(arrBuf)\n    const absHref = href.startsWith('/') ? href : `/${href}`\n    const manifest = this.manifestItems.find((item) => item.href == absHref)\n    return { buffer, mediaType: manifest?.mediaType }\n  }\n\n  async cover(): Promise<BookFile | undefined> {\n    const coverElem = this.rootPkg\n      .findDescendant('metadata')\n      ?.findDescendants('meta')\n      .find((node) => node.getAttribute('name') === 'cover')\n    if (!coverElem) return\n    const coverId = coverElem.getAttribute('content')\n    if (!coverId) return\n    const manifest = this.manifestItems.find((item) => item.id === coverId)\n    if (!manifest?.href) return\n    const file = await this.xmlLoader.file(manifest.href)\n    if (!file) return\n    const buffer = arrayBufferToBuffer(await file.arrayBuffer())\n    return {\n      buffer,\n      mediaType: manifest.mediaType,\n    }\n  }\n\n  async content(href: string) {\n    return this.xmlLoader.content(href)\n  }\n\n  async xmlDom(href: string) {\n    return this.xmlLoader.xmlDom(href)\n  }\n\n  async htmlDom(href: string) {\n    return this.xmlLoader.htmlDom(href)\n  }\n\n  dirBySpineIndex(spineIndex: number) {\n    const spine = this.spineItems[spineIndex]\n    if (spine) return path.dirname(spine.manifest.href)\n  }\n\n  protected getSpineIndexByHref(href: string): number | undefined {\n    const spineIndex = this.spineItems.findIndex(\n      (s) => s.manifest.href === href,\n    )\n    if (spineIndex === -1) return\n    return spineIndex\n  }\n\n  protected async loadNav3() {\n    const navManifest = this.manifestItems.find((it) => it.properties === 'nav')\n    if (!navManifest) return this.loadNav2()\n    const navDom = await this.htmlDom(navManifest.href)\n    const navDir = path.dirname(navManifest.href)\n    if (!navDom) return []\n    const navRoot = navDom.querySelector(`${NAV_TOC_SELECTOR}>ol`)\n    if (!navRoot) return []\n    return this.parseNav3(navRoot, navDir)\n  }\n\n  protected parseNav3(dom: Element, dir: string, level = 1): BookNav[] {\n    const nav: BookNav[] = compact(\n      Array.from(scopeQuerySelectorAll(dom, ['li'])).map(\n        (el): BookNav | undefined => {\n          const elem = Array.from(el.children).find(\n            (l) => l.tagName.toLowerCase() !== 'ol',\n          )\n          if (!elem) return\n          const label = elem.textContent ?? ''\n          let href: string | undefined\n          let hrefBase: string | undefined\n          let hrefAnchor: string | undefined\n          let spineIndex: number | undefined\n          if (elem.tagName.toLowerCase() === 'a') {\n            const src = elem.getAttribute('href')\n            if (src) {\n              href = path.join(dir, src)\n              ;[hrefBase, hrefAnchor] = href.split('#', 2)\n              if (hrefBase) spineIndex = this.getSpineIndexByHref(hrefBase)\n            }\n          }\n          const childOl = scopeQuerySelector(el, ['ol'])\n          return {\n            level,\n            label,\n            href,\n            hrefBase,\n            hrefAnchor,\n            spineIndex,\n            children: childOl ? this.parseNav3(childOl, dir, level + 1) : [],\n          }\n        },\n      ),\n    )\n\n    return nav\n  }\n\n  protected async loadNav2() {\n    const tocId = this.spine.getAttribute('toc') ?? 'ncx'\n    const ncxManifest = this.manifestItems.find((it) => it.id === tocId)\n    if (!ncxManifest) return []\n    const navDom = await this.xmlDom(ncxManifest.href)\n    const navDir = path.dirname(ncxManifest.href)\n    if (!navDom) return []\n    const navRoot = navDom.findDescendant('navMap')\n    if (!navRoot) return []\n    return this.parseNav2(navRoot, navDir)\n  }\n\n  protected parseNav2(dom: XMLElem, dir: string, level = 1): BookNav[] {\n    const nav: BookNav[] = compact(\n      dom.childrenFilter('navPoint').map((el): BookNav | undefined => {\n        const label = el.findChild('navLabel')?.findChild('text')?.text()\n        if (!label) return\n        let href: string | undefined\n        let hrefBase: string | undefined\n        let hrefAnchor: string | undefined\n        let spineIndex: number | undefined\n        const src = el.findChild('content')?.getAttribute('src')\n        if (src) {\n          href = path.join(dir, src)\n          ;[hrefBase, hrefAnchor] = href.split('#', 2)\n          if (hrefBase) spineIndex = this.getSpineIndexByHref(hrefBase)\n        }\n        return {\n          level,\n          label,\n          href,\n          hrefBase,\n          hrefAnchor,\n          spineIndex,\n          children: this.parseNav2(el, dir, level + 1),\n        }\n      }),\n    )\n\n    return nav\n  }\n\n  #navs?: BookNav[]\n  async navs(): Promise<BookNav[]> {\n    if (!this.#navs) {\n      if (this.version >= 3) {\n        this.#navs = await this.loadNav3()\n      } else {\n        this.#navs = await this.loadNav2()\n      }\n    }\n    return this.#navs\n  }\n}\n","import { TMP_UUID } from '../consts.js'\nimport { env } from '../env.js'\nimport { ErrorRequestResponse } from '../route/session.js'\nimport type { BookBase } from './book-base'\nimport { BookEpub } from './book-epub.js'\nimport { BookText } from './book-text.js'\nimport type { BookEntityBase } from './entity/book-entity-base'\nimport type { BookListBase } from './list/book-list-base'\nimport { BookListFS } from './list/book-list-fs.js'\nimport { BookListIndexedDB } from './list/book-list-indexed-db.js'\nimport type { BookTypes } from './types.js'\n\nconst extractUuid = (\n  method: (\n    account: string,\n    uuid: BookTypes.EntityUUID,\n    ...args: any[]\n  ) => unknown,\n  context: ClassMethodDecoratorContext,\n) => {\n  const methodName = context.name\n  context.addInitializer(function (this: any) {\n    this[methodName] = function (\n      account: string,\n      uuid: BookTypes.EntityUUID,\n      ...args: unknown[]\n    ) {\n      const extractedUuid =\n        uuid === TMP_UUID ? bookManager.reqTmpUuid(account) : uuid\n      return method.call(this, account, extractedUuid, ...args)\n    }\n  })\n}\n\nclass BookManager {\n  protected cacheList = new Map<string, BookListBase>()\n  protected cacheEntity = new Map<string, BookEntityBase>()\n  protected cacheBook = new Map<string, BookBase>()\n\n  reqTmpUuid(account: string) {\n    const uuid = this.list(account).tmpUuid\n    return uuid ?? TMP_UUID\n  }\n\n  list(account: string): BookListBase {\n    let bookList = this.cacheList.get(account)\n    if (!bookList) {\n      bookList =\n        env.appMode === 'server'\n          ? new BookListFS(account)\n          : new BookListIndexedDB(account)\n      this.cacheList.set(account, bookList)\n    }\n    return bookList\n  }\n\n  @extractUuid\n  async delete(account: string, uuid: BookTypes.EntityUUID) {\n    this.cacheEntity.delete(uuid)\n    this.cacheBook.delete(uuid)\n    await this.list(account).delete(uuid)\n  }\n\n  @extractUuid\n  async entity(account: string, uuid: string): Promise<BookEntityBase> {\n    let entity = this.cacheEntity.get(uuid)\n    if (!entity) {\n      entity = await this.list(account).book(uuid)\n      if (!entity)\n        throw new ErrorRequestResponse(`book entity(${uuid}) not found`)\n      this.cacheEntity.set(uuid, entity)\n    }\n    return entity\n  }\n\n  @extractUuid\n  async update(\n    account: string,\n    uuid: string,\n    update: BookTypes.EntityUpdate,\n  ): Promise<void> {\n    await this.list(account).update(uuid, update)\n    this.cacheEntity.delete(uuid)\n  }\n\n  @extractUuid\n  async book(account: string, uuid: string): Promise<BookBase> {\n    let book = this.cacheBook.get(uuid)\n    if (!book) {\n      const bookEntity = await this.entity(account, uuid)\n      book = await this.parseBook(bookEntity)\n      this.cacheBook.set(uuid, book)\n    }\n    return book\n  }\n\n  protected async parseBook(bookEntity: BookEntityBase): Promise<BookBase> {\n    switch (bookEntity.entity.type) {\n      case 'epub': {\n        const epub = await BookEpub.read(await bookEntity.readFileBuffer())\n        if (!epub) throw new ErrorRequestResponse('Parse epub error')\n        return epub\n      }\n      case 'text': {\n        const text = await BookText.read(\n          await bookEntity.readFileText(),\n          bookEntity.entity.name,\n        )\n        return text\n      }\n      default:\n        throw new ErrorRequestResponse(\n          `Unsupported type ${bookEntity.entity.type as string}`,\n        )\n    }\n  }\n}\n\nexport const bookManager = new BookManager()\n","import { splitParagraph } from '../util/text.js'\nimport type { BookFile, BookNav, BookSpine } from './book-base.js'\nimport { BookBase } from './book-base.js'\n\nexport class BookText extends BookBase {\n  static async read(text: string, title: string) {\n    let html = splitParagraph(text)\n      .map((p) => `<p>${p}</p>`)\n      .join('\\r\\n')\n    html = `\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <meta charset=\"UTF-8\">\n      <title>${title}</title>\n    </head>\n    <body>\n      ${html}\n    </body>\n    </html>\n    `\n    return new BookText(text, html)\n  }\n\n  constructor(\n    public readonly text: string,\n    public readonly html: string,\n  ) {\n    super()\n  }\n\n  spines: BookSpine[] = [\n    {\n      href: '/main.html',\n      id: 'main',\n    },\n  ]\n\n  async navs(): Promise<BookNav[]> {\n    return []\n  }\n\n  async file(): Promise<BookFile | undefined> {\n    return {\n      buffer: Buffer.from(this.html, 'utf8'),\n    }\n  }\n\n  async cover() {\n    return undefined\n  }\n}\n","import mime from 'mime-types'\nimport { ErrorRequestResponse } from '../../route/session.js'\nimport type { BookTypes } from '../types.js'\nimport { orderBy } from '../../util/collection.js'\n\nexport abstract class BookEntityBase {\n  constructor(public readonly entity: BookTypes.Entity) {}\n\n  abstract readFileBuffer(): Promise<ArrayBuffer>\n\n  abstract readFileText(): Promise<string>\n\n  async download(): Promise<{\n    contentType: string\n    buffer: ArrayBuffer\n    filename: string\n  }> {\n    const buffer = await this.readFileBuffer()\n    let extname: string | undefined\n    let contentType: string | false = false\n    switch (this.entity.type) {\n      case 'epub':\n        extname = '.epub'\n        break\n      case 'text':\n        extname = '.txt'\n        break\n    }\n    const unknownHint = 'Book type unknown'\n    if (!extname) throw new ErrorRequestResponse(unknownHint)\n    contentType = mime.contentType(extname)\n    if (!contentType) throw new ErrorRequestResponse(unknownHint)\n    const filename = this.entity.name + extname\n    return { contentType, buffer, filename }\n  }\n\n  async reset() {\n    await this.posSet({\n      section: 0,\n      paragraph: 0,\n    })\n    await this.annotationsDeleteAll()\n  }\n\n  abstract delete(): Promise<void>\n\n  abstract readProp(): Promise<BookTypes.PropertyJson>\n\n  protected abstract writeProp(prop: BookTypes.PropertyJson): Promise<void>\n\n  async posGet(): Promise<BookTypes.PropertyPosition> {\n    const prop = await this.readProp()\n    return (\n      prop.position ?? {\n        section: 0,\n        paragraph: 0,\n      }\n    )\n  }\n\n  async posSet(pos: BookTypes.PropertyPosition): Promise<void> {\n    const prop = await this.readProp()\n    prop.position = pos\n    await this.writeProp(prop)\n  }\n\n  private sortAnnotations(annotations: BookTypes.PropertyAnnotation[]) {\n    return orderBy(annotations, 'asc', (n) => [\n      n.pos.section,\n      n.pos.paragraph,\n      n.range?.start ?? 0,\n    ])\n  }\n\n  async annotationsGet(): Promise<BookTypes.PropertyAnnotation[]> {\n    const prop = await this.readProp()\n    return prop.annotations ?? []\n  }\n\n  async annotationsUpsert(annotations: BookTypes.PropertyAnnotation[]) {\n    const prop = await this.readProp()\n    prop.annotations ??= []\n    for (const annotation of annotations) {\n      const index = prop.annotations.findIndex(\n        (b) => b.uuid === annotation.uuid,\n      )\n      if (index !== -1) prop.annotations[index] = annotation\n      else prop.annotations.push(annotation)\n    }\n    prop.annotations = this.sortAnnotations(prop.annotations)\n    await this.writeProp(prop)\n    return prop.annotations\n  }\n\n  async annotationsDelete(annotationUuids: string[]) {\n    const prop = await this.readProp()\n    if (prop.annotations)\n      prop.annotations = prop.annotations.filter(\n        (b) => !annotationUuids.includes(b.uuid),\n      )\n    await this.writeProp(prop)\n  }\n\n  async annotationsDeleteAll() {\n    const prop = await this.readProp()\n    if (prop.annotations) prop.annotations = []\n    await this.writeProp(prop)\n  }\n\n  private sortKeywords(keywords: BookTypes.PropertyKeyword[]) {\n    return orderBy(keywords, 'asc', (n) => [\n      n.pos.section,\n      n.pos.paragraph,\n      n.keyword,\n    ])\n  }\n\n  async keywordsGet() {\n    const prop = await this.readProp()\n    return prop.keywords ?? []\n  }\n\n  async keywordsUpsert(keywords: BookTypes.PropertyKeyword[]) {\n    const prop = await this.readProp()\n    prop.keywords ??= []\n    for (const keyword of keywords) {\n      const index = prop.keywords.findIndex((b) => b.uuid === keyword.uuid)\n      if (index !== -1) prop.keywords[index] = keyword\n      else prop.keywords.push(keyword)\n    }\n    prop.keywords = this.sortKeywords(prop.keywords)\n    await this.writeProp(prop)\n    return prop.keywords\n  }\n\n  async keywordsDelete(keywordUuids: string[]) {\n    const prop = await this.readProp()\n    if (prop.keywords)\n      prop.keywords = prop.keywords.filter(\n        (b) => !keywordUuids.includes(b.uuid),\n      )\n    await this.writeProp(prop)\n  }\n}\n","import fs from 'fs'\nimport path from '@file-services/path'\nimport type { BookTypes } from '../types.js'\nimport { BookEntityBase } from './book-entity-base.js'\n\nexport class BookEntityFS extends BookEntityBase {\n  /**\n   * Book dir\n   * `books/02`\n   */\n  protected bookDir: string\n  /**\n   * Book basename\n   * `books/02/b9b990-4d72-11ed-86a9-498b78ad0441`\n   */\n  protected bookBaseNamePath: string\n  /**\n   * Book data path\n   * `books/02/b9b990-4d72-11ed-86a9-498b78ad0441.data`\n   */\n  protected bufferPath: string\n  /**\n   * Book prop json path\n   * `books/02/b9b990-4d72-11ed-86a9-498b78ad0441.prop.json`\n   */\n  protected propJsonPath: string\n  protected propJson?: BookTypes.PropertyJson\n\n  static async create(\n    allBooksDir: string,\n    entity: BookTypes.Entity,\n    file: ArrayBuffer,\n  ) {\n    const bookEntity = new BookEntityFS(allBooksDir, entity)\n    await bookEntity.mkdir()\n    await bookEntity.writeFile(file)\n    const prop = await bookEntity.readProp()\n    await bookEntity.writeProp(prop)\n  }\n\n  constructor(\n    protected readonly allBooksDir: string,\n    entity: BookTypes.Entity,\n  ) {\n    super(entity)\n    const prefix = entity.uuid.slice(0, 2)\n    const remain = entity.uuid.slice(2)\n    if (this.entity.isTmp) {\n      this.bookDir = path.join(this.allBooksDir, '$')\n      this.bookBaseNamePath = path.join(this.bookDir, 'tmp')\n    } else {\n      this.bookDir = path.join(this.allBooksDir, prefix)\n      this.bookBaseNamePath = path.join(this.bookDir, remain)\n    }\n    this.bufferPath = `${this.bookBaseNamePath}.data`\n    this.propJsonPath = `${this.bookBaseNamePath}.prop.json`\n  }\n\n  protected async mkdir() {\n    await fs.promises.mkdir(this.bookDir, { recursive: true })\n  }\n\n  protected async writeFile(file: ArrayBuffer) {\n    await fs.promises.writeFile(this.bufferPath, Buffer.from(file))\n  }\n\n  async readFileBuffer(): Promise<ArrayBuffer> {\n    return fs.promises.readFile(this.bufferPath)\n  }\n\n  async readFileText(): Promise<string> {\n    return fs.promises.readFile(this.bufferPath, 'utf8')\n  }\n\n  async delete() {\n    if (fs.existsSync(this.bufferPath)) await fs.promises.rm(this.bufferPath)\n    if (fs.existsSync(this.propJsonPath))\n      await fs.promises.rm(this.propJsonPath)\n    if (fs.existsSync(this.bookDir)) {\n      const dirFiles = await fs.promises.readdir(this.bookDir)\n      if (dirFiles.length === 0) await fs.promises.rmdir(this.bookDir)\n    }\n  }\n\n  async readProp(): Promise<BookTypes.PropertyJson> {\n    if (!this.propJson) {\n      if (!fs.existsSync(this.propJsonPath)) {\n        this.propJson = {}\n      } else {\n        const str = await fs.promises.readFile(this.propJsonPath, 'utf8')\n        try {\n          this.propJson = JSON.parse(str) as BookTypes.PropertyJson\n        } catch {\n          this.propJson = {}\n        }\n      }\n    }\n    return this.propJson\n  }\n\n  protected async writeProp(prop: BookTypes.PropertyJson) {\n    await fs.promises.writeFile(this.propJsonPath, JSON.stringify(prop), 'utf8')\n  }\n}\n","import { getDB } from '../indexedDB.js'\nimport type { BookTypes } from '../types'\nimport { BookEntityBase } from './book-entity-base.js'\n\nexport class BookEntityIndexedDB extends BookEntityBase {\n  protected propJson?: BookTypes.PropertyJson\n  protected uid: string\n\n  static async create(entity: BookTypes.Entity, file: ArrayBuffer) {\n    const bookEntity = new BookEntityIndexedDB(entity)\n    await bookEntity.writeFile(file)\n    const prop = await bookEntity.readProp()\n    await bookEntity.writeProp(prop)\n  }\n\n  constructor(entity: BookTypes.Entity) {\n    super(entity)\n    if (this.entity.isTmp) {\n      this.uid = '$tmp'\n    } else {\n      this.uid = entity.uuid\n    }\n  }\n\n  async readFileBuffer(): Promise<ArrayBuffer> {\n    const db = await getDB()\n    const data = await db.get('book-data', this.uid)\n    if (!data) throw new Error(`book(${this.uid}) data not found`)\n    return data.data\n  }\n\n  async readFileText(): Promise<string> {\n    const buf = await this.readFileBuffer()\n    return new TextDecoder('utf-8').decode(buf)\n  }\n\n  protected async writeFile(file: ArrayBuffer) {\n    const db = await getDB()\n    await db.put(\n      'book-data',\n      {\n        data: file,\n      },\n      this.uid,\n    )\n  }\n\n  async delete(): Promise<void> {\n    const db = await getDB()\n    await db.delete('book-data', this.uid)\n  }\n\n  async readProp(): Promise<BookTypes.PropertyJson> {\n    if (!this.propJson) {\n      const db = await getDB()\n      this.propJson = (await db.get('book-properties', this.uid)) ?? {}\n    }\n    return this.propJson\n  }\n\n  protected async writeProp(prop: BookTypes.PropertyJson) {\n    const db = await getDB()\n    await db.put('book-properties', prop, this.uid)\n  }\n}\n","import type { DBSchema } from 'idb'\nimport { openDB } from 'idb'\nimport type { BookTypes } from './types.js'\n\ninterface MyDB extends DBSchema {\n  'book-json': {\n    key: string\n    value: BookTypes.Json\n  }\n\n  'book-data': {\n    key: string\n    value: {\n      data: ArrayBuffer\n    }\n  }\n\n  'book-properties': {\n    key: string\n    value: BookTypes.PropertyJson\n  }\n}\n\nexport async function getDB() {\n  return await openDB<MyDB>('auditory-reader', 1, {\n    upgrade(db) {\n      db.createObjectStore('book-json', {\n        autoIncrement: false,\n      })\n      db.createObjectStore('book-data', {\n        autoIncrement: false,\n      })\n      db.createObjectStore('book-properties', {\n        autoIncrement: false,\n      })\n    },\n  })\n}\n","import { TMP_UUID } from '../../consts.js'\nimport { orderBy } from '../../util/collection.js'\nimport { bookManager } from '../book-manager.js'\nimport type { BookEntityBase } from '../entity/book-entity-base.js'\nimport type { BookTypes } from '../types.js'\n\nexport abstract class BookListBase {\n  protected json?: BookTypes.Json\n\n  public readonly version = 1\n\n  public readonly defaultPerPage = 15\n\n  constructor(protected readonly account: string) {}\n\n  get tmpUuid() {\n    return this.json?.tmp?.uuid\n  }\n\n  protected isTmpUuid(uuid: string) {\n    return this.json?.tmp?.uuid === uuid\n  }\n\n  protected getDefaultJson(): BookTypes.Json {\n    return {\n      version: this.version,\n      list: [],\n    }\n  }\n\n  protected async getJson(): Promise<BookTypes.Json> {\n    this.json ??= await this.readJson()\n    return this.json\n  }\n\n  protected abstract readJson(): Promise<BookTypes.Json>\n\n  protected async list(): Promise<BookTypes.EntityJson[]> {\n    const data = await this.getJson()\n    return data.list\n  }\n\n  protected async listFilter({\n    archive = 'active',\n    favorite = 'all',\n    search,\n    order,\n  }: Partial<BookTypes.FilterParams>): Promise<BookTypes.EntityJson[]> {\n    let list = await this.list()\n    if (archive !== 'all')\n      list = list.filter((it) =>\n        archive === 'archived' ? it.isArchived : !it.isArchived,\n      )\n    if (favorite !== 'all')\n      list = list.filter((it) =>\n        favorite === 'favorited' ? it.isFavorited : !it.isFavorited,\n      )\n    if (search)\n      list = list.filter((it) =>\n        it.name.toLowerCase().includes(search.toLowerCase()),\n      )\n    if (order && order !== 'default')\n      switch (order) {\n        case 'reverse':\n          list = [...list].reverse()\n          break\n        case 'name':\n          list = orderBy(list, 'asc', (it) => it.name)\n          break\n        case 'name-reverse':\n          list = orderBy(list, 'desc', (it) => it.name)\n          break\n      }\n\n    return list\n  }\n\n  protected async getTmp(): Promise<BookTypes.EntityJson | undefined> {\n    const data = await this.getJson()\n    return data.tmp\n  }\n\n  protected async setTmp(entity: BookTypes.EntityJson) {\n    const data = await this.getJson()\n    data.tmp = entity\n  }\n\n  protected async write() {\n    await this.writeJson(await this.getJson())\n  }\n\n  protected abstract writeJson(json: BookTypes.Json): Promise<void>\n\n  public async moveOffset(uuid: string, offset: number): Promise<void> {\n    if (offset === 0) return\n    const list = await this.list()\n    const entityIndex = list.findIndex((it) => it.uuid === uuid)\n    if (entityIndex === -1) return\n    const targetIndex = entityIndex + offset\n    if (targetIndex < 0 || targetIndex >= list.length) return\n    const [entityJson] = list.splice(entityIndex, 1)\n    if (entityJson) list.splice(targetIndex, 0, entityJson)\n    await this.write()\n  }\n\n  public async moveAfter(uuid: string, afterUuid: string): Promise<void> {\n    if (uuid === afterUuid) return\n    const list = await this.list()\n    const entityIndex = list.findIndex((it) => it.uuid === uuid)\n    if (entityIndex === -1) return\n    const afterIndex = list.findIndex((it) => it.uuid === afterUuid)\n    if (afterIndex === -1) return\n    const targetIndex = afterIndex > entityIndex ? afterIndex : afterIndex + 1\n    if (\n      targetIndex === entityIndex ||\n      targetIndex < 0 ||\n      targetIndex >= list.length\n    )\n      return\n    const [entityJson] = list.splice(entityIndex, 1)\n    if (entityJson) list.splice(targetIndex, 0, entityJson)\n    await this.write()\n  }\n\n  public async moveTop(uuid: string): Promise<void> {\n    const list = await this.list()\n    const entityIndex = list.findIndex((it) => it.uuid === uuid)\n    if (entityIndex === -1) return\n    const [entityJson] = list.splice(entityIndex, 1)\n    if (entityJson) list.unshift(entityJson)\n    await this.write()\n  }\n\n  public async page(\n    filter: Partial<BookTypes.FilterParams>,\n    {\n      page = 1,\n      perPage = this.defaultPerPage,\n    }: Partial<BookTypes.PageParams> = {},\n  ): Promise<BookTypes.PageResult> {\n    const list = await this.listFilter(filter)\n    const skipCount = perPage * (page - 1)\n    const items = list\n      .slice(skipCount, skipCount + perPage)\n      .map((it) => this.toEntity(it))\n    const count = list.length\n    return {\n      page,\n      perPage,\n      items,\n      count,\n      pageCount: Math.ceil(count / perPage),\n    }\n  }\n\n  protected async entityJson(uuid: string) {\n    const list = await this.list()\n    return list.find((it) => it.uuid === uuid)\n  }\n\n  protected toEntity(entityJson: BookTypes.EntityJson): BookTypes.Entity {\n    const entity: BookTypes.Entity = {\n      name: entityJson.name,\n      type: entityJson.type,\n      langCode: entityJson.langCode,\n      isFavorited: entityJson.isFavorited,\n      isArchived: Boolean(entityJson.isArchived),\n      uuid: entityJson.uuid,\n      createdAt: new Date(entityJson.createdAt),\n      updatedAt: new Date(entityJson.updatedAt),\n      isTmp: entityJson.isTmp,\n    }\n    return entity\n  }\n\n  public async update(\n    uuid: string,\n    update: BookTypes.EntityUpdate,\n  ): Promise<void> {\n    const list = await this.list()\n    const entityJson = list.find((it) => it.uuid === uuid)\n    if (!entityJson) return\n    if (update.langCode) entityJson.langCode = update.langCode\n    if (update.name) entityJson.name = update.name\n    if (update.isFavorited !== undefined)\n      entityJson.isFavorited = update.isFavorited\n    if (update.isArchived !== undefined)\n      entityJson.isArchived = update.isArchived\n    await this.write()\n  }\n\n  public async add(\n    entity: BookTypes.Entity,\n    file: ArrayBuffer,\n  ): Promise<BookTypes.EntityJson> {\n    const entityJson: BookTypes.EntityJson = {\n      name: entity.name,\n      uuid: entity.uuid,\n      type: entity.type,\n      langCode: entity.langCode,\n      isFavorited: entity.isFavorited,\n      createdAt: entity.createdAt.toISOString(),\n      updatedAt: entity.updatedAt.toISOString(),\n      isTmp: entity.isTmp,\n    }\n\n    if (entity.isTmp) {\n      // delete cache\n      await bookManager.delete(this.account, TMP_UUID)\n\n      const bookEntity = this.entity2bookEntity(entityJson)\n      await bookEntity.reset()\n      await this.setTmp(entityJson)\n    } else {\n      const list = await this.list()\n      list.push(entityJson)\n    }\n\n    await this.write()\n    await this.bookAdd(entity, file)\n    return entityJson\n  }\n\n  public async delete(uuid: string): Promise<void> {\n    const list = await this.list()\n    const bookIndex = list.findIndex((b) => b.uuid === uuid)\n    if (bookIndex === -1) {\n      return\n    }\n    const entityJson = list[bookIndex]\n    if (entityJson) await this.bookDelete(entityJson)\n    list.splice(bookIndex, 1)\n\n    await this.write()\n  }\n\n  public async book(uuid: string): Promise<BookEntityBase | undefined> {\n    const entityJson = this.isTmpUuid(uuid)\n      ? await this.getTmp()\n      : await this.entityJson(uuid)\n    if (!entityJson) return\n    return this.entity2bookEntity(entityJson)\n  }\n\n  protected abstract entity2bookEntity(\n    entity: BookTypes.EntityJson,\n  ): BookEntityBase\n\n  protected abstract bookAdd(\n    entity: BookTypes.Entity,\n    file: ArrayBuffer,\n  ): Promise<void>\n\n  protected abstract bookDelete(entityJson: BookTypes.EntityJson): Promise<void>\n}\n","import fs from 'fs'\nimport path from '@file-services/path'\nimport { env } from '../../env.js'\nimport { BookEntityFS } from '../entity/book-entity-fs.js'\nimport type { BookTypes } from '../types'\nimport { BookListBase } from './book-list-base.js'\nimport type { BookEntityBase } from '../entity/book-entity-base.js'\n\nexport class BookListFS extends BookListBase {\n  /**\n   * `path/to/:account`\n   */\n  protected accountDir: string\n  /**\n   * `path/to/:account/books.json`\n   */\n  protected jsonPath: string\n  /**\n   * `path/to/:account/books`\n   */\n  protected allBooksDir: string\n\n  constructor(account: string) {\n    super(account)\n    this.accountDir = path.join(env.dataPath, 'users', account)\n    this.allBooksDir = path.join(this.accountDir, 'books')\n    this.jsonPath = path.join(this.accountDir, 'books.json')\n  }\n\n  protected async readJson(): Promise<BookTypes.Json> {\n    const jsonPath = this.jsonPath\n    if (!fs.existsSync(jsonPath)) {\n      return this.getDefaultJson()\n    } else {\n      const str = await fs.promises.readFile(jsonPath, 'utf8')\n      return JSON.parse(str) as BookTypes.Json\n    }\n  }\n\n  protected async writeJson(json: BookTypes.Json) {\n    if (!fs.existsSync(this.accountDir))\n      await fs.promises.mkdir(this.accountDir, { recursive: true })\n    await fs.promises.writeFile(this.jsonPath, JSON.stringify(json), 'utf8')\n  }\n\n  protected entity2bookEntity(\n    entityJson: BookTypes.EntityJson,\n  ): BookEntityBase {\n    return new BookEntityFS(this.allBooksDir, this.toEntity(entityJson))\n  }\n\n  protected async bookAdd(\n    entity: BookTypes.Entity,\n    file: ArrayBuffer,\n  ): Promise<void> {\n    await BookEntityFS.create(this.allBooksDir, entity, file)\n  }\n\n  protected async bookDelete(entityJson: BookTypes.EntityJson): Promise<void> {\n    const book = new BookEntityFS(this.allBooksDir, this.toEntity(entityJson))\n    await book.delete()\n  }\n}\n","import type { BookEntityBase } from '../entity/book-entity-base'\nimport { BookEntityIndexedDB } from '../entity/book-entity-indexed-db.js'\nimport { getDB } from '../indexedDB.js'\nimport type { BookTypes } from '../types'\nimport { BookListBase } from './book-list-base.js'\n\nexport class BookListIndexedDB extends BookListBase {\n  protected async readJson(): Promise<BookTypes.Json> {\n    const db = await getDB()\n    const storedJson = await db.get('book-json', 'default')\n    if (!storedJson) {\n      const defaultJson = this.getDefaultJson()\n      await db.add('book-json', defaultJson, 'default')\n      return defaultJson\n    }\n    return storedJson\n  }\n\n  protected async writeJson(json: BookTypes.Json): Promise<void> {\n    const db = await getDB()\n    await db.put('book-json', json, 'default')\n  }\n\n  protected entity2bookEntity(\n    entityJson: BookTypes.EntityJson,\n  ): BookEntityBase {\n    return new BookEntityIndexedDB(this.toEntity(entityJson))\n  }\n\n  protected async bookAdd(\n    entity: BookTypes.Entity,\n    file: ArrayBuffer,\n  ): Promise<void> {\n    await BookEntityIndexedDB.create(entity, file)\n  }\n\n  protected async bookDelete(entityJson: BookTypes.EntityJson): Promise<void> {\n    const book = new BookEntityIndexedDB(this.toEntity(entityJson))\n    await book.delete()\n  }\n}\n","export const PARA_BOX_CLASS = '__para_box__'\nexport const PARA_IGNORE_CLASS = '__para_ignore__'\nexport const PARA_ACTIVE_CLASS = '__para_active__'\nexport const PARA_ANNOTATION_CLASS = '__para_annotation__'\nexport const ROOT_ANNOTATION_HIGHLIGHT_CLASS = '__root_annotation_highlight__'\nexport const ROOT_KEYWORD_HIGHLIGHT_CLASS = '__root_keyword_highlight__'\nexport const ROOT_UTTERER_HIGHLIGHT_CLASS = '__root_utterer_highlight__'\n\nexport const IMG_MAX_WIDTH_CLASS = '__img_max_width__'\nexport const IMG_MAX_HEIGHT_CLASS = '__img_max_height__'\n\nexport const COLOR_SCHEME_DARK_CLASS = '__color_scheme_dark__'\n\nexport const COLUMN_BREAK_CLASS = '__column_break__'\n\nexport const ZH_PERSON_RULES = {\n  妳: {\n    word: '乃',\n    pinyin: 'naǐ',\n  },\n  她: {\n    word: '伊',\n    pinyin: 'yī',\n  },\n  它: {\n    word: '牠',\n    pinyin: 'tuó',\n  },\n}\n\nexport const TMP_UUID = '$tmp'\n","import fs from 'fs'\nimport path from '@file-services/path'\nimport { isBrowser } from './util/browser.js'\nimport { randomString } from './util/random.js'\n\nexport type Account = {\n  account: string\n  password: string\n}\n\nexport type AppMode = 'server' | 'service-worker'\n\nexport type Env = {\n  isProduction: boolean\n  appMode: AppMode\n  appPort: number\n  appBodyLimit: string\n  appPublicRoot: string\n  appApiRoot: string\n  accounts: Account[]\n  sessionKey: string\n  dataPath: string\n}\n\ntype Config = {\n  appPort?: number\n  appPublicPath?: string\n  appBodyLimit?: string\n  accounts?: Account[]\n  sessionKey?: string\n}\n\nconst dataPath = 'server-data'\nconst config: Config = isBrowser\n  ? {}\n  : JSON.parse(fs.readFileSync('auditory-reader.config.json', 'utf8'))\n\nconst appPublicRoot = config.appPublicPath || process.env.APP_PUBLIC_PATH || '/'\n\nexport const env: Env = {\n  isProduction: process.env.NODE_ENV === 'production',\n  appMode: (process.env.APP_MODE as AppMode | undefined) || 'server',\n  appPort: config.appPort ?? 4001,\n  appBodyLimit: config.appBodyLimit ?? '20mb',\n  appPublicRoot,\n  appApiRoot: path.join(appPublicRoot, 'api'),\n  dataPath,\n  sessionKey: config.sessionKey || randomString(40),\n  accounts: config.accounts ?? [],\n}\n","import dedent from 'dedent'\nimport JSZip from 'jszip'\nimport { PARA_IGNORE_CLASS } from '../consts.js'\n\nexport class EpubGen {\n  zip: JSZip\n\n  constructor(\n    private readonly options: {\n      uuid: string\n      title: string\n      lang: string\n      htmlContent: string\n      date: Date\n      publisher: string\n      sourceURL?: string\n    },\n  ) {\n    this.zip = new JSZip()\n  }\n\n  genContainer() {\n    this.zip.file(\n      'META-INF/container.xml',\n      dedent`\n        <?xml version=\"1.0\"?>\n        <container version=\"1.0\" xmlns=\"urn:oasis:names:tc:opendocument:xmlns:container\">\n          <rootfiles>\n            <rootfile full-path=\"content.opf\" media-type=\"application/oebps-package+xml\"/>\n          </rootfiles>\n        </container>\n      `,\n    )\n  }\n\n  genContentOpf() {\n    this.zip.file(\n      'content.opf',\n      dedent`\n        <package xmlns=\"http://www.idpf.org/2007/opf\" unique-identifier=\"${\n          this.options.uuid\n        }\" version=\"3.0\" >\n          <metadata\n            xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n            xmlns:dcterms=\"http://purl.org/dc/terms/\"\n            xmlns:opf=\"http://www.idpf.org/2007/opf\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n            <dc:title>${this.options.title}</dc:title>\n            <dc:creator>unknown</dc:creator>\n            <dc:language>${this.options.lang}</dc:language>\n            <dc:date>${this.options.date.toISOString()}</dc:date>\n            <dc:publisher>${this.options.publisher}</dc:publisher>\n          </metadata>\n          <manifest>\n            <item href=\"page-styles.css\" id=\"page-styles\" media-type=\"text/css\"/>\n            <item href=\"stylesheet.css\" id=\"stylesheet\" media-type=\"text/css\"/>\n            <item href=\"text/content.html\" id=\"html-content\" media-type=\"application/xhtml+xml\"/>\n          </manifest>\n          <spine>\n            <itemref idref=\"html-content\"/>\n          </spine>\n        </package>\n      `,\n    )\n  }\n\n  genStyle() {\n    this.zip.file(\n      'page-styles.css',\n      dedent`\n        @page {\n          margin-bottom: 5pt;\n          margin-top: 5pt\n        }\n      `,\n    )\n    this.zip.file(\n      'stylesheet.css',\n      dedent`\n        rt {\n          user-select: none;\n        }\n        img {\n          max-width: 100%;\n        }\n      `,\n    )\n  }\n\n  genContentHTML() {\n    this.zip.file(\n      'text/content.html',\n      dedent`\n        <?xml version='1.0' encoding='utf-8'?>\n        <html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\" xml:lang=\"${\n          this.options.lang\n        }\">\n          <head>\n            <title>${this.options.title}</title>\n            <link href=\"../stylesheet.css\" rel=\"stylesheet\" type=\"text/css\"/>\n            <link href=\"../page-styles.css\" rel=\"stylesheet\" type=\"text/css\"/>\n            <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>\n          </head>\n          <body>\n            ${\n              this.options.sourceURL\n                ? `<p class=\"${PARA_IGNORE_CLASS}\"><a target=\"_blank\" href=\"${this.options.sourceURL}\">\n                  ${this.options.sourceURL}\n                </a></p>`\n                : ''\n            }\n            <h1>${this.options.title}</h1>\n            ${this.options.htmlContent}\n          </body>\n        </html>\n      `,\n    )\n  }\n\n  async gen() {\n    this.zip.file('mimetype', 'application/epub+zip')\n    this.genContainer()\n    this.genContentOpf()\n    this.genStyle()\n    this.genContentHTML()\n\n    return await this.zip.generateAsync({ type: 'arraybuffer' })\n  }\n}\n","import { useMemo } from 'react'\nimport { orderBy } from './util/collection.js'\n\nconst langSet = [\n  { code: 'ab', name: 'Abkhazian' },\n  { code: 'aa', name: 'Afar' },\n  { code: 'af', name: 'Afrikaans' },\n  { code: 'ak', name: 'Akan' },\n  { code: 'sq', name: 'Albanian' },\n  { code: 'am', name: 'Amharic' },\n  { code: 'ar', name: 'Arabic' },\n  { code: 'an', name: 'Aragonese' },\n  { code: 'hy', name: 'Armenian' },\n  { code: 'as', name: 'Assamese' },\n  { code: 'av', name: 'Avaric' },\n  { code: 'ae', name: 'Avestan' },\n  { code: 'ay', name: 'Aymara' },\n  { code: 'az', name: 'Azerbaijani' },\n  { code: 'bm', name: 'Bambara' },\n  { code: 'ba', name: 'Bashkir' },\n  { code: 'eu', name: 'Basque' },\n  { code: 'be', name: 'Belarusian' },\n  { code: 'bn', name: 'Bengali (Bangla)' },\n  { code: 'bh', name: 'Bihari' },\n  { code: 'bi', name: 'Bislama' },\n  { code: 'bs', name: 'Bosnian' },\n  { code: 'br', name: 'Breton' },\n  { code: 'bg', name: 'Bulgarian' },\n  { code: 'my', name: 'Burmese' },\n  { code: 'ca', name: 'Catalan' },\n  { code: 'ch', name: 'Chamorro' },\n  { code: 'ce', name: 'Chechen' },\n  { code: 'ny', name: 'Chichewa, Chewa, Nyanja' },\n  { code: 'zh', name: 'Chinese' },\n  // { code: 'zh-Hans', name: 'Chinese (Simplified)' },\n  // { code: 'zh-Hant', name: 'Chinese (Traditional)' },\n  { code: 'cv', name: 'Chuvash' },\n  { code: 'kw', name: 'Cornish' },\n  { code: 'co', name: 'Corsican' },\n  { code: 'cr', name: 'Cree' },\n  { code: 'hr', name: 'Croatian' },\n  { code: 'cs', name: 'Czech' },\n  { code: 'da', name: 'Danish' },\n  { code: 'dv', name: 'Divehi, Dhivehi, Maldivian' },\n  { code: 'nl', name: 'Dutch' },\n  { code: 'dz', name: 'Dzongkha' },\n  { code: 'en', name: 'English' },\n  { code: 'eo', name: 'Esperanto' },\n  { code: 'et', name: 'Estonian' },\n  { code: 'ee', name: 'Ewe' },\n  { code: 'fo', name: 'Faroese' },\n  { code: 'fj', name: 'Fijian' },\n  { code: 'fi', name: 'Finnish' },\n  { code: 'fr', name: 'French' },\n  { code: 'ff', name: 'Fula, Fulah, Pulaar, Pular' },\n  { code: 'gl', name: 'Galician' },\n  { code: 'gd', name: 'Gaelic (Scottish)' },\n  { code: 'gv', name: 'Gaelic (Manx)' },\n  { code: 'ka', name: 'Georgian' },\n  { code: 'de', name: 'German' },\n  { code: 'el', name: 'Greek' },\n  { code: 'kl', name: 'Greenlandic' },\n  { code: 'gn', name: 'Guarani' },\n  { code: 'gu', name: 'Gujarati' },\n  { code: 'ht', name: 'Haitian Creole' },\n  { code: 'ha', name: 'Hausa' },\n  { code: 'he', name: 'Hebrew' },\n  { code: 'hz', name: 'Herero' },\n  { code: 'hi', name: 'Hindi' },\n  { code: 'ho', name: 'Hiri Motu' },\n  { code: 'hu', name: 'Hungarian' },\n  { code: 'is', name: 'Icelandic' },\n  { code: 'io', name: 'Ido' },\n  { code: 'ig', name: 'Igbo' },\n  { code: 'id, in', name: 'Indonesian' },\n  { code: 'ia', name: 'Interlingua' },\n  { code: 'ie', name: 'Interlingue' },\n  { code: 'iu', name: 'Inuktitut' },\n  { code: 'ik', name: 'Inupiak' },\n  { code: 'ga', name: 'Irish' },\n  { code: 'it', name: 'Italian' },\n  { code: 'ja', name: 'Japanese' },\n  { code: 'jv', name: 'Javanese' },\n  { code: 'kl', name: 'Kalaallisut, Greenlandic' },\n  { code: 'kn', name: 'Kannada' },\n  { code: 'kr', name: 'Kanuri' },\n  { code: 'ks', name: 'Kashmiri' },\n  { code: 'kk', name: 'Kazakh' },\n  { code: 'km', name: 'Khmer' },\n  { code: 'ki', name: 'Kikuyu' },\n  { code: 'rw', name: 'Kinyarwanda (Rwanda)' },\n  { code: 'rn', name: 'Kirundi' },\n  { code: 'ky', name: 'Kyrgyz' },\n  { code: 'kv', name: 'Komi' },\n  { code: 'kg', name: 'Kongo' },\n  { code: 'ko', name: 'Korean' },\n  { code: 'ku', name: 'Kurdish' },\n  { code: 'kj', name: 'Kwanyama' },\n  { code: 'lo', name: 'Lao' },\n  { code: 'la', name: 'Latin' },\n  { code: 'lv', name: 'Latvian (Lettish)' },\n  { code: 'li', name: 'Limburgish ( Limburger)' },\n  { code: 'ln', name: 'Lingala' },\n  { code: 'lt', name: 'Lithuanian' },\n  { code: 'lu', name: 'Luga-Katanga' },\n  { code: 'lg', name: 'Luganda, Ganda' },\n  { code: 'lb', name: 'Luxembourgish' },\n  { code: 'gv', name: 'Manx' },\n  { code: 'mk', name: 'Macedonian' },\n  { code: 'mg', name: 'Malagasy' },\n  { code: 'ms', name: 'Malay' },\n  { code: 'ml', name: 'Malayalam' },\n  { code: 'mt', name: 'Maltese' },\n  { code: 'mi', name: 'Maori' },\n  { code: 'mr', name: 'Marathi' },\n  { code: 'mh', name: 'Marshallese' },\n  { code: 'mo', name: 'Moldavian' },\n  { code: 'mn', name: 'Mongolian' },\n  { code: 'na', name: 'Nauru' },\n  { code: 'nv', name: 'Navajo' },\n  { code: 'ng', name: 'Ndonga' },\n  { code: 'nd', name: 'Northern Ndebele' },\n  { code: 'ne', name: 'Nepali' },\n  { code: 'no', name: 'Norwegian' },\n  { code: 'nb', name: 'Norwegian bokmål' },\n  { code: 'nn', name: 'Norwegian nynorsk' },\n  { code: 'ii', name: 'Nuosu' },\n  { code: 'oc', name: 'Occitan' },\n  { code: 'oj', name: 'Ojibwe' },\n  { code: 'cu', name: 'Old Church Slavonic, Old Bulgarian' },\n  { code: 'or', name: 'Oriya' },\n  { code: 'om', name: 'Oromo (Afaan Oromo)' },\n  { code: 'os', name: 'Ossetian' },\n  { code: 'pi', name: 'Pāli' },\n  { code: 'ps', name: 'Pashto, Pushto' },\n  { code: 'fa', name: 'Persian (Farsi)' },\n  { code: 'pl', name: 'Polish' },\n  { code: 'pt', name: 'Portuguese' },\n  { code: 'pa', name: 'Punjabi (Eastern)' },\n  { code: 'qu', name: 'Quechua' },\n  { code: 'rm', name: 'Romansh' },\n  { code: 'ro', name: 'Romanian' },\n  { code: 'ru', name: 'Russian' },\n  { code: 'se', name: 'Sami' },\n  { code: 'sm', name: 'Samoan' },\n  { code: 'sg', name: 'Sango' },\n  { code: 'sa', name: 'Sanskrit' },\n  { code: 'sr', name: 'Serbian' },\n  { code: 'sh', name: 'Serbo-Croatian' },\n  { code: 'st', name: 'Sesotho' },\n  { code: 'tn', name: 'Setswana' },\n  { code: 'sn', name: 'Shona' },\n  { code: 'ii', name: 'Sichuan Yi' },\n  { code: 'sd', name: 'Sindhi' },\n  { code: 'si', name: 'Sinhalese' },\n  { code: 'ss', name: 'Siswati' },\n  { code: 'sk', name: 'Slovak' },\n  { code: 'sl', name: 'Slovenian' },\n  { code: 'so', name: 'Somali' },\n  { code: 'nr', name: 'Southern Ndebele' },\n  { code: 'es', name: 'Spanish' },\n  { code: 'su', name: 'Sundanese' },\n  { code: 'sw', name: 'Swahili (Kiswahili)' },\n  { code: 'ss', name: 'Swati' },\n  { code: 'sv', name: 'Swedish' },\n  { code: 'tl', name: 'Tagalog' },\n  { code: 'ty', name: 'Tahitian' },\n  { code: 'tg', name: 'Tajik' },\n  { code: 'ta', name: 'Tamil' },\n  { code: 'tt', name: 'Tatar' },\n  { code: 'te', name: 'Telugu' },\n  { code: 'th', name: 'Thai' },\n  { code: 'bo', name: 'Tibetan' },\n  { code: 'ti', name: 'Tigrinya' },\n  { code: 'to', name: 'Tonga' },\n  { code: 'ts', name: 'Tsonga' },\n  { code: 'tr', name: 'Turkish' },\n  { code: 'tk', name: 'Turkmen' },\n  { code: 'tw', name: 'Twi' },\n  { code: 'ug', name: 'Uyghur' },\n  { code: 'uk', name: 'Ukrainian' },\n  { code: 'ur', name: 'Urdu' },\n  { code: 'uz', name: 'Uzbek' },\n  { code: 've', name: 'Venda' },\n  { code: 'vi', name: 'Vietnamese' },\n  { code: 'vo', name: 'Volapük' },\n  { code: 'wa', name: 'Wallon' },\n  { code: 'cy', name: 'Welsh' },\n  { code: 'wo', name: 'Wolof' },\n  { code: 'fy', name: 'Western Frisian' },\n  { code: 'xh', name: 'Xhosa' },\n  { code: 'yi', name: 'Yiddish' },\n  { code: 'ji', name: 'Yiddish' },\n  { code: 'yo', name: 'Yoruba' },\n  { code: 'za', name: 'Zhuang, Chuang' },\n  { code: 'zu', name: 'Zulu' },\n] as const\n\ntype LangItem = (typeof langSet)[number]\nexport type LangCode = (typeof langSet)[number]['code']\n\nexport const langList = langSet as unknown as LangItem[]\n\nexport const langCodes: LangCode[] = langSet.map((l) => l.code)\n\nexport const parseLangCode = (\n  lang: string | null | undefined,\n): LangCode | undefined => {\n  if (!lang) return\n  if (lang.includes('-')) lang = lang.split('-')[0]\n  if (!lang) return\n  if (lang.includes('_')) lang = lang.split('_')[0]\n  if (!lang) return\n  lang = lang.toLowerCase()\n  if (!langCodes.includes(lang as LangCode)) {\n    return\n  }\n  return lang as LangCode\n}\n\nexport const useUserLanguages = (): LangCode[] => {\n  const userLanguages = useMemo(\n    () => global.navigator.languages as LangCode[],\n    [],\n  )\n  return userLanguages\n}\n\nexport const useOrderedLangs = () => {\n  const userLanguages = useUserLanguages()\n\n  const langs = useMemo(() => {\n    return orderBy(langList, 'asc', (l) =>\n      userLanguages.indexOf(l.code) === -1 ? 0 : 1,\n    )\n  }, [userLanguages])\n\n  return langs\n}\n\nexport const useOrderedLangOptions = () => {\n  const langs = useOrderedLangs()\n\n  const options = useMemo(() => {\n    return langs.map((l: { name: string; code: LangCode }, i) => ({\n      key: i,\n      value: l.code,\n      label: `${l.name} (${l.code})`,\n    }))\n  }, [langs])\n\n  return options\n}\n","import path from '@file-services/path'\nimport { useCallback, useEffect, useRef, useState } from 'react'\nimport type { NavigateFunction } from 'react-router-dom'\nimport { useNavigate } from 'react-router-dom'\nimport { env } from '../env.js'\nimport type { URouter } from './router'\n\nexport type Action<ReqType, ResType> = (body: ReqType) => Promise<ResType>\n\nexport class ActionUnauthorized extends Error {\n  constructor() {\n    super()\n  }\n}\n\nexport class ActionRequestError extends Error {\n  constructor(public readonly message: string) {\n    super()\n  }\n}\n\nexport class ActionError<T> extends Error {\n  constructor(public data: T) {\n    super()\n  }\n}\n\nexport function getActionPath(urlPath: string): string {\n  return path.join(env.appApiRoot, urlPath)\n}\n\nexport function actionCatchError(navigate: NavigateFunction) {\n  return (error: unknown) => {\n    if (error instanceof ActionUnauthorized) {\n      navigate('/login')\n      return false\n    } else throw error\n  }\n}\n\ntype ActionOptions = {\n  /**\n   * @default true\n   */\n  clearWhenReload?: boolean\n  request?: boolean\n}\n\nexport function useAction<Req, Res>(\n  router: URouter<Req, Res>,\n  arg: Req,\n  options?: ActionOptions,\n) {\n  const navigate = useNavigate()\n  const refArg = useRef<Req>(arg)\n  refArg.current = arg\n  const argJson = JSON.stringify(arg)\n  const refOptions = useRef<ActionOptions | undefined>(options)\n  refOptions.current = options\n  const [data, setData] = useState<Res>()\n  const [error, setError] = useState<any>()\n\n  const load = useCallback(\n    (signal: AbortSignal) => {\n      router\n        .action(refArg.current)\n        .then((res) => {\n          if (signal.aborted) return\n          setData(res)\n        })\n        .catch((error) => {\n          if (signal.aborted) return\n          if (error instanceof ActionUnauthorized) {\n            navigate('/login')\n            return null\n          } else {\n            setError(error)\n          }\n        })\n    },\n    [navigate, router],\n  )\n\n  const reload = useCallback(\n    (options?: { signal?: AbortSignal }) => {\n      if (refOptions.current?.clearWhenReload !== false) {\n        setData(undefined)\n        setError(undefined)\n      }\n      load(options?.signal ?? new AbortController().signal)\n    },\n    [load],\n  )\n\n  // load\n  useEffect(() => {\n    if (!argJson) return\n    if (options?.request === false) return\n    const abort = new AbortController()\n    reload({ signal: abort.signal })\n    return () => {\n      abort.abort()\n    }\n  }, [argJson, options?.request, reload])\n\n  return { data, reload, error }\n}\n","import { notificationApi } from '../../web/common/notification.js'\nimport {\n  ActionError,\n  ActionRequestError,\n  ActionUnauthorized,\n  getActionPath,\n} from './action.js'\nimport type { URequest } from './request'\nimport type { UResponse } from './response'\nimport type { UserInfo } from './session'\n\ntype ApiContext<R, P, M> = {\n  req: URequest<R>\n  res: UResponse<P>\n} & M\n\ntype ApiHandler<R = any, P = any, M = object> = (\n  context: ApiContext<R, P, M>,\n) => P | Promise<P>\n\ntype RouterMethod = 'get' | 'post'\n\ntype RouterResponseType = 'json' | 'buffer'\n\nexport type RouterOptions = {\n  method?: RouterMethod\n  responseType?: RouterResponseType\n  isDynamic?: boolean\n}\n\nexport class URouter<Req = any, Res = any> {\n  fullRoutePath: string\n  method: RouterMethod\n  responseType: RouterResponseType\n  isDynamic: boolean\n  handler?: ApiHandler<Req, Res, object>\n\n  constructor(\n    public readonly routePath: string,\n    {\n      method = 'post',\n      responseType = 'json',\n      isDynamic = false,\n    }: RouterOptions = {},\n  ) {\n    this.fullRoutePath = getActionPath(routePath)\n    this.method = method\n    this.responseType = responseType\n    this.isDynamic = isDynamic\n  }\n\n  isMatch(ctx: { method: string; pathname: string }) {\n    if (this.method !== ctx.method.toLowerCase()) return false\n    if (this.isDynamic) return ctx.pathname.startsWith(this.fullRoutePath)\n    return this.fullRoutePath === ctx.pathname\n  }\n\n  getDynamicPaths(pathname: string) {\n    if (!this.isDynamic) return []\n    if (!pathname.startsWith(this.fullRoutePath))\n      throw new Error('getDynamicPaths pathname not match')\n    return pathname\n      .slice(this.fullRoutePath.length)\n      .replace(/^\\/*/, '')\n      .split('/')\n  }\n\n  async action(body: Req, signal?: AbortSignal): Promise<Res> {\n    const res = await fetch(this.fullRoutePath, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      signal,\n      body: body ? JSON.stringify(body) : null,\n    })\n    if (res.status === 401) throw new ActionUnauthorized()\n    if (res.status.toString().startsWith('4')) {\n      const json = await res.json()\n      notificationApi().error({\n        message: 'Error',\n        description: json.message,\n      })\n      throw new ActionRequestError(json.message)\n    }\n    if (!res.status.toString().startsWith('2'))\n      throw new ActionError(await res.json())\n    return await res.json()\n  }\n\n  route(handler: ApiHandler<Req, Res>) {\n    this.handler = handler\n\n    return this\n  }\n\n  routeLogined(handler: ApiHandler<Req, Res, { userInfo: UserInfo }>) {\n    this.route((context) => {\n      const session = context.req.session\n      const userInfo = session.userInfo()\n      if (!userInfo) {\n        context.res.status(401)\n        return {} as any\n      }\n      return handler({\n        ...(context as ApiContext<Req, Res, any>),\n        userInfo,\n      })\n    })\n\n    return this\n  }\n}\n","import type session from 'express-session'\nimport { env } from '../env.js'\n\ntype SessionNode = session.Session & Partial<session.SessionData>\n\ndeclare module 'express-session' {\n  interface SessionData {\n    user?: string\n  }\n}\n\nexport class ErrorRequestResponse extends Error {}\n\nexport type UserInfo = {\n  account: string\n}\n\nexport class USession {\n  static fromNode(session: SessionNode) {\n    return new this(session, null)\n  }\n\n  static fromBrowser() {\n    return new this(null, { account: 'anonymous' })\n  }\n\n  constructor(\n    public readonly nodeSession: SessionNode | null,\n    public readonly browserUser: UserInfo | null,\n  ) {}\n\n  userInfo(): UserInfo | undefined {\n    if (this.browserUser) {\n      return this.browserUser\n    } else if (this.nodeSession) {\n      return this.nodeSession.user\n        ? {\n            account: this.nodeSession.user,\n          }\n        : undefined\n    }\n  }\n\n  async userLogin(account: string, password: string) {\n    if (!this.nodeSession) return false\n\n    if (\n      env.accounts.find((a) => a.account === account && a.password === password)\n    ) {\n      this.nodeSession.user = account\n      this.nodeSession.save()\n      return true\n    } else {\n      return false\n    }\n  }\n\n  async userLogout() {\n    if (!this.nodeSession) return\n    this.nodeSession.user = undefined\n    this.nodeSession.save()\n  }\n\n  userLogined() {\n    return !!this.userInfo()\n  }\n\n  async save() {\n    if (this.nodeSession) this.nodeSession.save()\n  }\n}\n\nexport function createUserStore(session: SessionNode) {\n  return {\n    login: async (account: string, password: string) => {\n      if (\n        env.accounts.find(\n          (a) => a.account === account && a.password === password,\n        )\n      ) {\n        session.user = account\n        session.save()\n        return true\n      } else {\n        return false\n      }\n    },\n    logout: async () => {\n      session.user = undefined\n      session.save()\n    },\n    logined() {\n      return !!this.info()\n    },\n    info: (): UserInfo | null => {\n      return session.user\n        ? {\n            account: session.user,\n          }\n        : null\n    },\n  }\n}\n","import isMobileJS from 'ismobilejs'\n\nexport const isBrowser: boolean =\n  Boolean(global.window) || Boolean(global.navigator)\n\nexport const supportedTouch: boolean =\n  'ontouchstart' in\n  (isBrowser ? ((global.window as Window | undefined) ?? {}) : {})\n\nexport const isMobile: boolean =\n  isBrowser && isMobileJS(navigator.userAgent).any\n\nexport const isSafari: boolean =\n  isBrowser && /^((?!chrome|android).)*safari/i.test(navigator.userAgent)\n\nexport const isFirefox: boolean =\n  isBrowser && navigator.userAgent.toLowerCase().includes('firefox')\n","export function range(\n  start: number,\n  end: number,\n  step = start < end ? 1 : -1,\n): number[] {\n  const result = []\n  if (step > 0)\n    for (let i = start; i < end; i += step) {\n      result.push(i)\n    }\n  else if (step < 0)\n    for (let i = start; i > end; i += step) {\n      result.push(i)\n    }\n  return result\n}\n\nexport function compact<T>(\n  list: (T | '' | 0 | false | null | undefined)[],\n): T[] {\n  return list.filter((it): it is T => !!it)\n}\n\nexport function findPair<T>(\n  list: T[],\n  predicate: (value: T, index: number, list: T[]) => boolean,\n  startIndex = 0,\n): [item: T, index: number] | [undefined, undefined] {\n  let index = startIndex\n  while (index < list.length) {\n    const value = list[index]\n    if (!value) continue\n    const testResult = predicate(value, index, list)\n    if (testResult) {\n      return [value, index]\n    }\n    index += 1\n  }\n  return [undefined, undefined]\n}\n\nexport function findIndex<T>(\n  list: T[],\n  predicate: (value: T, index: number, list: T[]) => boolean,\n  startIndex?: number,\n): number | undefined {\n  return findPair(list, predicate, startIndex)[1]\n}\n\nexport function find<T>(\n  list: T[],\n  predicate: (value: T, index: number, list: T[]) => boolean,\n  startIndex?: number,\n): T | undefined {\n  return findPair(list, predicate, startIndex)[0]\n}\n\nexport function findLastPair<T>(\n  list: T[],\n  predicate: (value: T, index: number, list: T[]) => boolean,\n  startIndex = list.length - 1,\n): [item: T, index: number] | [undefined, undefined] {\n  let index = startIndex\n  while (index >= 0) {\n    const value = list[index]\n    if (!value) continue\n    const testResult = predicate(value, index, list)\n    if (testResult) {\n      return [value, index]\n    }\n    index -= 1\n  }\n  return [undefined, undefined]\n}\n\nexport function findLastIndex<T>(\n  list: T[],\n  predicate: (value: T, index: number, list: T[]) => boolean,\n  startIndex?: number,\n): number | undefined {\n  return findLastPair(list, predicate, startIndex)[1]\n}\n\nexport function findLast<T>(\n  list: T[],\n  predicate: (value: T, index: number, list: T[]) => boolean,\n  startIndex?: number,\n): T | undefined {\n  return findLastPair(list, predicate, startIndex)[0]\n}\n\nexport function maxIndexBy<T>(\n  list: T[],\n  getValue: (value: T, index: number, list: T[]) => number,\n): number {\n  let maxValue: number | null = null\n  let maxIndex: number | null = null\n  for (const [index, it] of list.entries()) {\n    const curValue = getValue(it, index, list)\n    if (maxValue === null || curValue > maxValue) {\n      maxValue = curValue\n      maxIndex = index\n    }\n  }\n  if (maxIndex === null) throw new Error('maxBy list is empty')\n  return maxIndex\n}\n\nexport function maxBy<T>(\n  list: T[],\n  getValue: (value: T, index: number, list: T[]) => number,\n): T {\n  const index = maxIndexBy(list, getValue)\n  return list[index]!\n}\n\nexport function minIndexBy<T>(\n  list: T[],\n  getValue: (value: T, index: number, list: T[]) => number,\n): number {\n  let minValue: number | null = null\n  let minIndex: number | null = null\n  for (const [index, it] of list.entries()) {\n    const curValue = getValue(it, index, list)\n    if (minValue === null || curValue < minValue) {\n      minValue = curValue\n      minIndex = index\n    }\n  }\n  if (minIndex === null) throw new Error('minBy list is empty')\n  return minIndex\n}\n\nexport function minBy<T>(\n  list: T[],\n  getValue: (value: T, index: number, list: T[]) => number,\n): T {\n  const index = minIndexBy(list, getValue)\n  return list[index]!\n}\n\nexport function uniqBy<T, V>(\n  list: T[],\n  getValue: (value: T, index: number, list: T[]) => V,\n): T[] {\n  const map = new Map<V, T>()\n  for (const [index, it] of list.entries()) {\n    const v = getValue(it, index, list)\n    if (!map.has(v)) map.set(v, it)\n  }\n  return [...map.values()]\n}\n\nexport function uniq<T>(list: T[]): T[] {\n  return uniqBy(list, (it) => it)\n}\n\ntype OrderTypes = number | string | boolean | OrderTypes[]\n\nexport function orderBy<T>(\n  list: T[],\n  order: 'asc' | 'desc',\n  getValue: (value: T, index: number, list: T[]) => OrderTypes,\n): T[] {\n  const listEntries = [...list.entries()]\n  const getDiff = <T extends OrderTypes>(va: T, vb: T): number => {\n    if (typeof va === 'string' && typeof vb === 'string')\n      return va.localeCompare(vb)\n    else if (typeof va === 'number' && typeof vb === 'number') return va - vb\n    else if (typeof va === 'boolean' && typeof vb === 'boolean')\n      return Number(va) - Number(vb)\n    else if (Array.isArray(va) && Array.isArray(vb)) {\n      for (const [idx, vaIt] of va.entries()) {\n        const vbIt = vb.at(idx)\n        if (vbIt === undefined) return 0\n        const diff = getDiff(vaIt, vbIt)\n        if (diff !== 0) return diff\n      }\n      return 0\n    } else\n      throw new Error(`no support order by type(${typeof va} vs ${typeof vb})`)\n  }\n  listEntries.sort(([ai, a], [bi, b]) => {\n    const va = getValue(a, ai, list)\n    const vb = getValue(b, bi, list)\n    return getDiff(va, vb)\n  })\n  if (order === 'desc') {\n    listEntries.reverse()\n  }\n  return listEntries.map((it) => it[1])\n}\n\nexport function groupToMap<T, A>(\n  list: T[],\n  getKey: (item: T, index: number, list: T[]) => A,\n): Map<A, T[]> {\n  const map = new Map<A, T[]>()\n  for (const [index, item] of list.entries()) {\n    const key = getKey(item, index, list)\n    let group = map.get(key)\n    if (!group) {\n      group = []\n      map.set(key, group)\n    }\n    group.push(item)\n  }\n  return map\n}\n\nexport function sum(list: number[]) {\n  return list.reduce((ret, cur) => ret + cur, 0)\n}\n","export function arrayBufferToBase64(buffer: ArrayBuffer): string {\n  let binary = ''\n  const bytes = new Uint8Array(buffer)\n  for (const byte of bytes) {\n    binary += String.fromCharCode(byte)\n  }\n  return window.btoa(binary)\n}\n\nexport function base64ToArrayBuffer(base64Str: string): Uint8Array {\n  return Uint8Array.from(window.atob(base64Str), (c) => c.charCodeAt(0))\n}\n\nexport function arrayBufferToBuffer(ab: ArrayBuffer): Buffer {\n  const buf = Buffer.alloc(ab.byteLength)\n  const view = new Uint8Array(ab)\n  for (let i = 0; i < buf.length; ++i) {\n    buf[i] = view[i]!\n  }\n  return buf\n}\n","import type { DOMWindow } from 'jsdom'\nimport { isUrl } from './url.js'\nimport { isBrowser } from './browser.js'\n\nexport type DOMView = DOMWindow\n\nconst viewSym = Symbol('DOMView')\n\nexport function isInputElement(element: any): element is Element {\n  if (element instanceof Element) {\n    const elemName = element.tagName.toLowerCase()\n    if (['textarea', 'input'].includes(elemName)) return true\n  }\n  return false\n}\n\nexport async function jsDOMParser(xml: string): Promise<{\n  view: DOMView\n  doc: Document\n}> {\n  if (isBrowser) {\n    const parser = new window.DOMParser()\n    const doc = parser.parseFromString(xml, 'text/html')\n    // @ts-ignore\n    doc[viewSym] = window\n    return { view: window as unknown as DOMView, doc }\n  } else {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const { JSDOM } = await import('jsdom')\n    const jsdom = new JSDOM('', { pretendToBeVisual: true })\n    const DOMParser = jsdom.window.DOMParser\n    const parser = new DOMParser()\n    const doc = parser.parseFromString(xml, 'text/html')\n    // @ts-ignore\n    doc[viewSym] = jsdom.window\n    return { view: jsdom.window, doc }\n  }\n}\n\nexport function getDomView(node: any): DOMView | undefined {\n  return (\n    node?.defaultView ||\n    node?.ownerDocument?.defaultView ||\n    node?.ownerDocument?.[viewSym]\n  )\n}\n\nexport function requiredDomView(node: any): DOMView {\n  const view = getDomView(node)\n  if (!view) throw new Error('no dom view')\n  return view\n}\n\nexport function isTextNode(node: any): node is Text {\n  const view = getDomView(node)\n  return !!view && node instanceof view.Text\n}\n\nexport function isElement(node: any): node is HTMLElement {\n  const view = getDomView(node)\n  return !!view && node instanceof view.HTMLElement\n}\n\nexport function isImageElement(node: any): node is HTMLImageElement {\n  const view = getDomView(node)\n  return !!view && node instanceof view.HTMLImageElement\n}\n\nexport function isAnchorElement(node: any): node is HTMLAnchorElement {\n  const view = getDomView(node)\n  return !!view && node instanceof view.HTMLAnchorElement\n}\n\nexport async function HTMLImgs2DataURL(\n  urlStr: string,\n  element: HTMLElement,\n  options: { referrer?: string } = {},\n) {\n  const url = new URL(urlStr)\n  const imgs = [...element.querySelectorAll('img')]\n  const headers = new Headers({\n    ...(options.referrer ? { Referer: options.referrer ?? undefined } : {}),\n  })\n  for (const img of imgs) {\n    let src = img.src || img.getAttribute('data-src')\n    if (!src) continue\n    try {\n      if (src.startsWith('//')) {\n        src = `${url.protocol}:${src}`\n      }\n      if (!isUrl(src)) return\n      const res = await fetch(src, {\n        headers,\n      })\n      const contentType = res.headers.get('Content-Type')\n      const buf = await res.arrayBuffer()\n      img.src = `data:${contentType};base64,${Buffer.from(buf).toString(\n        'base64',\n      )}`\n    } catch (err) {\n      console.error(err)\n    }\n  }\n}\n\nexport async function SVGImgs2DataURL(\n  svgElement: SVGSVGElement,\n  options: { referrer?: string; baseURL?: string } = {},\n) {\n  const imgs = [...svgElement.querySelectorAll('image')]\n  const headers = new Headers({\n    ...(options.referrer ? { Referer: options.referrer ?? undefined } : {}),\n  })\n  for (const img of imgs) {\n    const relativeSrc = img.href.baseVal\n    if (!relativeSrc) continue\n    const src = options.baseURL\n      ? new URL(relativeSrc, options.baseURL)\n      : relativeSrc\n    try {\n      const res = await fetch(src, {\n        headers,\n      })\n      const contentType = res.headers.get('Content-Type')\n      const buf = await res.arrayBuffer()\n      img.setAttribute(\n        'href',\n        `data:${contentType};base64,${Buffer.from(buf).toString('base64')}`,\n      )\n    } catch (err) {\n      console.error(err)\n    }\n  }\n}\n\nexport async function svgToDataUri(svgElement: SVGSVGElement, baseURL: string) {\n  const clonedSvg = svgElement.cloneNode(true) as SVGSVGElement\n  await SVGImgs2DataURL(clonedSvg, { baseURL })\n  clonedSvg.setAttribute('width', `${svgElement.clientWidth}px`)\n  const xml = new XMLSerializer().serializeToString(clonedSvg)\n  svgElement.cloneNode()\n  const svg64 = window.btoa(xml)\n  return `data:image/svg+xml;base64,${svg64}`\n}\n\nexport function eventBan(event: Event | React.FormEvent<HTMLElement>) {\n  event.preventDefault()\n  event.stopPropagation()\n}\n","import { ErrorRequestResponse } from '../route/session.js'\nimport { jsDOMParser } from './dom.js'\n\nexport async function fetchHtml(url: string) {\n  try {\n    const res = await fetch(url)\n    return await res.text()\n  } catch (err) {\n    const msg = err instanceof Error ? err.message : err?.toString()\n    throw new ErrorRequestResponse(msg)\n  }\n}\n\nexport async function fetchDom(url: string) {\n  const html = await fetchHtml(url)\n  return jsDOMParser(html)\n}\n","import { range } from './collection.js'\n\nexport function randomRange(start: number, end: number) {\n  return Math.random() * (end - start) + start\n}\n\nexport function randomRangeInt(start: number, end: number) {\n  return Math.floor(Math.random() * (end - start + 1)) + start\n}\n\nconst CHAR_CODES = [\n  ...range(0, 26).map((i) => i + 65), // A-Z\n  ...range(0, 26).map((i) => i + 97), // a-z\n  ...range(0, 10).map((i) => i + 48), // 0-9\n  33, // !\n  44, // ,\n  46, // .\n  58, // :\n  59, // ;\n  63, // ?\n  64, // @\n  95, // _\n]\n\nexport function randomChar() {\n  const charCodeIndex = randomRangeInt(0, CHAR_CODES.length - 1)\n  return String.fromCharCode(CHAR_CODES[charCodeIndex]!)\n}\n\nexport function randomString(len: number) {\n  return range(0, len)\n    .map(() => randomChar())\n    .join()\n}\n","import type { BookNav } from '../book/book-base.js'\nimport { PARA_BOX_CLASS, PARA_IGNORE_CLASS } from '../consts.js'\nimport { compact, orderBy } from './collection.js'\nimport {\n  isElement,\n  isImageElement,\n  isTextNode,\n  requiredDomView,\n} from './dom.js'\n\ninterface ReadablePartBase {\n  elem: HTMLElement\n  anchorIds: string[] | undefined\n  navAnchorIds: string[] | undefined\n}\n\nexport interface ReadablePartText extends ReadablePartBase {\n  type: 'text'\n  text: string\n}\n\nexport interface ReadablePartImage extends ReadablePartBase {\n  type: 'image'\n}\n\nexport type ReadablePart = ReadablePartText | ReadablePartImage\n\nexport interface TextAlias {\n  source: string\n  target: string\n}\n\nexport function* walkerNode(doc: Document, root: HTMLElement) {\n  const view = requiredDomView(root)\n  const walker = doc.createTreeWalker(root, view.NodeFilter.SHOW_ALL)\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  while (true) {\n    const curNode = walker.nextNode()\n    if (curNode) yield curNode\n    else break\n  }\n}\n\n/**\n * JSDOM getComputedStyle is not fully compatible with the DOM API.\n * - Property default could be empty\n * - Property inheritance is not supported\n */\nfunction getComputedStyle(elem: HTMLElement) {\n  return requiredDomView(elem).getComputedStyle(elem)\n}\n\nconst inlineElementNames = [\n  'a',\n  'abbr',\n  'acronym',\n  'b',\n  'bdo',\n  'big',\n  'br',\n  'button',\n  'cite',\n  'code',\n  'dfn',\n  'em',\n  'i',\n  'img',\n  'input',\n  'kbd',\n  'label',\n  'map',\n  'object',\n  'output',\n  'q',\n  'samp',\n  'script',\n  'select',\n  'small',\n  'span',\n  'strong',\n  'sub',\n  'sup',\n  'textarea',\n  'time',\n  'tt',\n  'var',\n]\n\nfunction isBlockElem(elem: HTMLElement) {\n  const display = getComputedStyle(elem).getPropertyValue('display')\n  if (!display) return !inlineElementNames.includes(elem.tagName.toLowerCase())\n  return !['inline', 'inline-block'].includes(display)\n}\n\nconst isIgnoreVerticalAlign = (elem: HTMLElement) => {\n  const verticalAlign =\n    getComputedStyle(elem).getPropertyValue('vertical-align')\n  return verticalAlign && ['top', 'bottom'].includes(verticalAlign)\n}\n\nconst ignoreTagNames = [\n  // ruby > rt\n  'rt',\n  'noscript',\n]\n\nfunction getParentBlockElem(elem: HTMLElement | null): HTMLElement | undefined {\n  if (!elem) return\n  if (isBlockElem(elem)) {\n    return elem\n  } else if (elem.parentElement) {\n    return getParentBlockElem(elem.parentElement)\n  }\n}\n\nfunction fixPageBreak(elem: HTMLElement) {\n  const style = getComputedStyle(elem)\n  const breakBeforeList = [\n    style.getPropertyValue('page-break-before'),\n    style.getPropertyValue('break-before'),\n  ]\n  if (breakBeforeList.some((b) => b === 'always')) {\n    elem.style.breakBefore = 'column'\n  }\n  const breakAfters = [\n    style.getPropertyValue('page-break-after'),\n    style.getPropertyValue('break-after'),\n  ]\n  if (breakAfters.some((b) => b === 'always')) {\n    elem.style.breakAfter = 'column'\n  }\n}\n\nfunction isAllInlineChild(elem: HTMLElement) {\n  if (elem.dataset.isAllInlineChild !== undefined) {\n    return elem.dataset.isAllInlineChild === '1'\n  }\n  for (const node of elem.childNodes) {\n    if (\n      isElement(node) &&\n      !node.classList.contains(PARA_IGNORE_CLASS) &&\n      (isBlockElem(node) || !isAllInlineChild(node))\n    ) {\n      elem.dataset.isAllInlineChild = '0'\n      return false\n    }\n  }\n  elem.dataset.isAllInlineChild = '1'\n  return true\n}\n\nexport class ReadableExtractor {\n  #parts: (\n    | {\n        type: 'image'\n        elem: HTMLImageElement\n        anchors: string[] | undefined\n        navAnchors: string[] | undefined\n      }\n    | {\n        type: 'text'\n        elem: Text\n        anchors: string[] | undefined\n        navAnchors: string[] | undefined\n      }\n  )[] = []\n  #accAnchors?: string[]\n  #accNavAnchors?: string[]\n  #alias: TextAlias[] = []\n  #navAnchorSet: Set<string>\n\n  constructor(\n    private doc: Document,\n    private flattenedNavs: BookNav[],\n  ) {\n    this.#navAnchorSet = new Set(\n      compact(this.flattenedNavs.map((n) => n.hrefAnchor)),\n    )\n    this.walk()\n  }\n\n  walk() {\n    // walk\n    for (const node of walkerNode(this.doc, this.doc.body)) {\n      if (isElement(node)) {\n        // anchors\n        if (node.id) {\n          this.addAnchor(node.id, this.#navAnchorSet.has(node.id))\n        }\n\n        // ruby\n        if (node.tagName.toLowerCase() === 'ruby') {\n          this.addRuby(node)\n        }\n\n        fixPageBreak(node)\n\n        // image\n        if (isImageElement(node)) {\n          this.addImage(node)\n          continue\n        }\n\n        // skip tag like: ruby > rt\n        const tagName = node.tagName.toLowerCase()\n        if (ignoreTagNames.includes(tagName)) {\n          node.classList.add(PARA_IGNORE_CLASS)\n          continue\n        }\n\n        // skip ignored vertical-align\n        if (isIgnoreVerticalAlign(node)) {\n          node.classList.add(PARA_IGNORE_CLASS)\n          continue\n        }\n\n        // skip invisible\n        const isVisible =\n          // JSDom not support checkVisibility\n          // eslint-disable-next-line @typescript-eslint/unbound-method, @typescript-eslint/no-unnecessary-condition\n          node.checkVisibility\n            ? node.checkVisibility({\n                contentVisibilityAuto: true,\n                checkOpacity: true,\n                visibilityProperty: true,\n              })\n            : true\n        if (!isVisible) {\n          node.classList.add(PARA_IGNORE_CLASS)\n          continue\n        }\n      }\n\n      // not text\n      if (!isTextNode(node)) continue\n\n      // no content\n      const content = node.textContent?.trim()\n      if (!content) continue\n\n      this.addText(node)\n    }\n  }\n\n  private popAccAnchors() {\n    const anchors = this.#accAnchors\n    const navAnchors = this.#accNavAnchors\n    this.#accAnchors = undefined\n    this.#accNavAnchors = undefined\n    return { anchors, navAnchors }\n  }\n\n  addAnchor(id: string, isNavAnchor: boolean) {\n    this.#accAnchors ??= []\n    this.#accAnchors.push(id)\n    if (isNavAnchor) {\n      this.#accNavAnchors ??= []\n      this.#accNavAnchors.push(id)\n    }\n  }\n\n  addRuby(elem: HTMLElement) {\n    let source = ''\n    let target = ''\n    for (const node of walkerNode(this.doc, elem)) {\n      if (isElement(node) && node.tagName.toLowerCase() === 'rt') {\n        target += node.textContent\n      } else if (isTextNode(node) && !node.parentElement?.closest('rt')) {\n        source += node.textContent\n      }\n    }\n    if (source && target) {\n      elem.dataset.isAlias = '1'\n      this.#alias.push({\n        source,\n        target,\n      })\n    }\n  }\n\n  addImage(elem: HTMLImageElement) {\n    const { anchors, navAnchors } = this.popAccAnchors()\n    this.#parts.push({ type: 'image', elem, anchors, navAnchors })\n  }\n\n  addText(text: Text) {\n    const { anchors, navAnchors } = this.popAccAnchors()\n    this.#parts.push({\n      type: 'text',\n      elem: text,\n      anchors,\n      navAnchors,\n    })\n  }\n\n  private getContentText(elem: HTMLElement) {\n    let contentText = ''\n    for (const node of walkerNode(elem.ownerDocument, elem)) {\n      if (!isTextNode(node)) continue\n      if (!node.parentElement) continue\n      if (node.parentElement.closest(`.${PARA_IGNORE_CLASS}`)) continue\n      contentText += node.textContent\n    }\n    return contentText\n  }\n\n  toReadableParts() {\n    const blockMap = new Map<HTMLElement, null | ReadablePart>()\n\n    const addTextPart = (\n      blockElem: HTMLElement,\n      anchors: string[] | undefined,\n      navAnchors: string[] | undefined,\n    ) => {\n      blockElem.classList.add(PARA_BOX_CLASS)\n      const textContent = this.getContentText(blockElem)\n      const notEmpty = !!textContent.trim()\n      if (notEmpty) {\n        const part: ReadablePart = {\n          elem: blockElem,\n          type: 'text',\n          text: textContent,\n          anchorIds: anchors,\n          navAnchorIds: navAnchors,\n        }\n        blockMap.set(blockElem, part)\n        readableParts.push(part)\n      } else {\n        blockMap.set(blockElem, null)\n      }\n    }\n\n    const readableParts: ReadablePart[] = []\n    for (const { type, elem, anchors, navAnchors } of this.#parts) {\n      switch (type) {\n        case 'image': {\n          elem.classList.add(PARA_BOX_CLASS)\n          readableParts.push({\n            elem,\n            type: 'image',\n            anchorIds: anchors,\n            navAnchorIds: navAnchors,\n          })\n          break\n        }\n        case 'text': {\n          // no parent\n          const blockElem = getParentBlockElem(elem.parentElement)\n          if (!blockElem) continue\n\n          // ignore class\n          if (blockElem.classList.contains(PARA_IGNORE_CLASS)) continue\n\n          // avoid duplicated\n          const part = blockMap.get(blockElem)\n          if (part) {\n            if (anchors) {\n              part.anchorIds ??= []\n              part.anchorIds.push(...anchors)\n            }\n            if (navAnchors) {\n              part.navAnchorIds ??= []\n              part.navAnchorIds.push(...navAnchors)\n            }\n            continue\n          }\n\n          if (isAllInlineChild(blockElem) && blockElem !== this.doc.body) {\n            addTextPart(blockElem, anchors, navAnchors)\n          } else {\n            // split block\n            if (!elem.parentElement) continue\n            const wrapElem = this.doc.createElement('span')\n            elem.after(wrapElem)\n            wrapElem.appendChild(elem)\n            addTextPart(wrapElem, anchors, navAnchors)\n          }\n          break\n        }\n      }\n    }\n    return readableParts\n  }\n\n  alias() {\n    return orderBy(this.#alias, 'desc', (a) => a.source.length)\n  }\n}\n","import { find } from './collection.js'\n\nexport function splitLines(text: string) {\n  return text.split(/\\r?\\n/)\n}\n\nexport function splitParagraph(text: string) {\n  return text.split(/\\r?\\n\\r?\\n/)\n}\n\nexport function capitalize(text: string) {\n  return text.charAt(0).toUpperCase() + text.slice(1)\n}\n\nexport function textEllipsis(text: string | undefined, maxLength: number) {\n  if (!text) return ''\n  if (text.length > maxLength + 3) {\n    return `${text.slice(0, maxLength)}...`\n  }\n  return text\n}\n\nexport function keywordMatches(\n  text: string,\n  keyword: { keyword: string; alias?: string[] },\n) {\n  function matchAllIndex(text: string, search: string) {\n    const matchIndexes: number[] = []\n    let index = 0\n    const len = text.length\n    while (index < len) {\n      const m = text.indexOf(search, index)\n      if (m === -1) break\n      matchIndexes.push(m)\n      index = m + search.length\n    }\n    return matchIndexes\n  }\n\n  const keywordMatches: [index: number, length: number][] = matchAllIndex(\n    text,\n    keyword.keyword,\n  ).map((index) => [index, keyword.keyword.length])\n  const aliasMatches: [index: number, length: number][] = []\n  if (keyword.alias)\n    for (const alias of keyword.alias) {\n      const len = alias.length\n      const matches = matchAllIndex(text, alias).filter(\n        (m) => !keywordMatches.some((k) => k[0] <= m && k[0] + k[1] >= m + len),\n      )\n      aliasMatches.push(\n        ...matches.map((m) => [m, len] satisfies [number, number]),\n      )\n    }\n  return [...keywordMatches, ...aliasMatches]\n}\n","export function urlSplitAnchor(url: string) {\n  const [mainUrl, anchorId] = url.split('#', 2)\n  return [decodeURIComponent(mainUrl ?? ''), decodeURIComponent(anchorId ?? '')]\n}\n\nexport function isUrl(url: string) {\n  try {\n    new URL(url)\n    return true\n  } catch {\n    return false\n  }\n}\n","import buffer from 'buffer'\nimport * as htmlparser2 from 'htmlparser2'\nimport JSZip from 'jszip'\nimport { isBrowser } from './browser.js'\nimport { compact } from './collection.js'\nimport { jsDOMParser } from './dom.js'\n\nglobalThis.Blob = isBrowser ? Blob : (buffer.Blob as unknown as typeof Blob)\nJSZip.support.blob = true\n\nexport type XMLNode = XMLElement | string\n\nexport type XMLElement = {\n  name: string\n  attributes: Record<string, string | undefined>\n  children?: XMLNode[]\n}\n\nexport class XMLDOMLoader {\n  constructor(protected zip: JSZip) {}\n\n  protected async htmlToDOM(xml: string) {\n    const dom = await jsDOMParser(xml)\n    return dom.doc\n  }\n\n  protected async xmlToDOM(xml: string) {\n    const doc = await parseXML(xml)\n    return new XMLElem(doc)\n  }\n\n  protected getFinalPath(filepath: string) {\n    return filepath.startsWith('/') ? filepath.slice(1) : filepath\n  }\n\n  async file(filepath: string) {\n    const file = this.zip.file(this.getFinalPath(filepath))\n    if (!file) return\n    return await file.async('blob')\n  }\n\n  async content(filepath: string) {\n    const file = this.zip.file(this.getFinalPath(filepath))\n    if (!file) return\n    return await file.async('string')\n  }\n\n  async htmlDom(filepath: string) {\n    const xml = await this.content(filepath)\n    if (!xml) return\n    const dom = await this.htmlToDOM(xml)\n    return dom\n  }\n\n  async xmlDom(filepath: string) {\n    const xml = await this.content(filepath)\n    if (!xml) return\n    const dom = await this.xmlToDOM(xml)\n    return dom\n  }\n}\n\nexport function parseXML(xmlText: string) {\n  return new Promise<XMLElement>((resolve, reject) => {\n    // the full parsed object.\n    let parsed: XMLElement\n    // the current node being parsed.\n    let current: XMLElement | undefined\n    // stack of nodes leading to the current one.\n    const stack: XMLElement[] = []\n\n    const parser = new htmlparser2.Parser(\n      {\n        ontext(text) {\n          if (!current) return\n          current.children ??= []\n          current.children.push(text)\n        },\n        onopentag(name, attributes) {\n          const child = {\n            name,\n            attributes,\n            children: undefined,\n          }\n          if (current) {\n            current.children ??= []\n            current.children.push(child)\n          } else {\n            parsed = child\n          }\n\n          stack.push(child)\n          current = child\n        },\n        onclosetag() {\n          stack.pop()\n          current = stack[stack.length - 1]\n        },\n        onend() {\n          resolve(parsed)\n        },\n        onerror(error) {\n          reject(error)\n        },\n      },\n      { xmlMode: true },\n    )\n\n    parser.write(xmlText)\n\n    parser.end()\n  })\n}\n\nexport class XMLElem {\n  protected static getDescendantsText(node: XMLNode): string | undefined {\n    if (typeof node === 'string') return node\n    if (!node.children) return\n    let text = ''\n    for (const c of node.children) {\n      text += this.getDescendantsText(c)\n    }\n    return text\n  }\n\n  get tagName() {\n    return this.node.name\n  }\n\n  constructor(public node: XMLElement) {}\n\n  getAttribute(attributeName: string): string | undefined {\n    return this.node.attributes[attributeName]\n  }\n\n  text(): string | undefined {\n    return XMLElem.getDescendantsText(this.node)\n  }\n\n  children(): XMLElem[] {\n    return compact(\n      this.node.children?.map((n) =>\n        typeof n === 'object' ? new XMLElem(n) : undefined,\n      ) ?? [],\n    )\n  }\n\n  childrenFilter(tagName: string) {\n    return this.children().filter((c) => c.tagName === tagName)\n  }\n\n  /**\n   * Find a child with the given name.\n   * @param tagName - The name to find.\n   */\n  findChild(tagName: string): XMLElem | undefined {\n    return this.children().find((it) => it.tagName === tagName)\n  }\n\n  /**\n   * Find all descendants with the given name.\n   * @param tagName - The name to find.\n   */\n  findDescendants(tagName: string): XMLElem[] {\n    const foundNodes: XMLElem[] = []\n    for (const elem of this.children()) {\n      if (elem.tagName === tagName) foundNodes.push(elem)\n      foundNodes.push(...elem.findDescendants(tagName))\n    }\n    return foundNodes\n  }\n\n  /**\n   * Find a descendant with the given name.\n   * @param tagName - The name to find.\n   */\n  findDescendant(tagName: string): XMLElem | undefined {\n    for (const elem of this.children()) {\n      if (elem.tagName === tagName) return elem\n      const found = elem.findDescendant(tagName)\n      if (found) return found\n    }\n  }\n}\n","import { atom, useAtom } from 'jotai'\nimport { message, notification } from 'antd'\nimport type { NotificationInstance } from 'antd/es/notification/interface.js'\nimport { globalStore } from '../store/global.js'\nimport { useEffect } from 'react'\nimport type { MessageInstance } from 'antd/es/message/interface.js'\n\nconst notificationApiAtom = atom<NotificationInstance | null>(null)\n\nexport const notificationApi = () => {\n  const api = globalStore.get(notificationApiAtom)\n  if (api) return api\n  return notification\n}\n\nexport function NotificationProvider() {\n  const [api, contextHolder] = notification.useNotification({\n    placement: 'top',\n    duration: 3,\n  })\n  const [, setNotificationApi] = useAtom(notificationApiAtom)\n  useEffect(() => {\n    setNotificationApi(api)\n  }, [api, setNotificationApi])\n  return contextHolder\n}\n\nconst messageApiAtom = atom<null | MessageInstance>(null)\n\nexport const messageApi = () => {\n  const api = globalStore.get(messageApiAtom)\n  if (api) return api\n  return message\n}\n\nexport function MessageProvider() {\n  const [messageApi, contextHolder] = message.useMessage({\n    duration: 3,\n  })\n  const [, setMessageApi] = useAtom(messageApiAtom)\n  useEffect(() => {\n    setMessageApi(messageApi)\n  }, [messageApi, setMessageApi])\n  return contextHolder\n}\n","import { createStore } from 'jotai'\n\nexport const globalStore = createStore()\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AAOA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;AAEA;AAWA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC5BA;AAEA;AAGA;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AAEA;AACA;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAYA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAGA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACzEA;AACA;AAGA;AACA;AAaA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AAMA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACzBA;AAEA;AACA;AACA;AAWA;AAGA;AAoBA;AAnBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AALA;AAKA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;AChDA;AACA;AAOA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;AAEA;AAWA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC5BA;AAEA;AAGA;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AAOA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;ACfA;AACA;AAMA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;ACdA;AAEA;AAiBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC/BA;AAEA;AAOA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;AChBA;AAEA;AAGA;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AAMA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;AC5EA;AAEA;AAMA;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACfA;AACA;AAEA;AAEA;AAaA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;AC/CA;AAEA;AAOA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;ACdA;AAEA;AAYA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC1BA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACnBA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;ACXA;AAOA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;ACgBA;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AAEA;AAEA;AAeA;AAEA;;;;;;AAMA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;;;;;AAMA;AAMA;AACA;AACA;AA4CA;AA1CA;AACA;AAMA;AALA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAGA;AACA;AAEA;AADA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAAA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5PA;AAMA;;AAGA;AASA;;AAAA;AAWA;;AAAA;AAWA;;AAAA;AAiBA;;AAAA;AAUA;;AAAA;AAmBA;;AAAA;AA4JA;;AAAA;AAjPA;AAMA;AAsPA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtWA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAGA;AAQA;AACA;AACA;AAGA;AAAA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AAGA;AACA;;AAhFA;AACA;AACA;;;AA+EA;AAlFA;;AAsBA;;AACA;;;AAMA;;AACA;;;AAWA;;AACA;;;AASA;;AACA;;;AAgCA;;;;;;;;;;;;;;;;;;;;;;;;ACtHA;AAEA;AAEA;AACA;AACA;AAGA;;;;;AAKA;;;AAGA;;;AAGA;AACA;AACA;AAgBA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA1BA;AAIA;AAIA;AACA;AACA;AACA;AACA;AAPA;AAsBA;;;;;;;;;;;;;;;;;;;;;;;;;ACnDA;AACA;AAEA;AAEA;AAOA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAHA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AADA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAxIA;;AAAA;AAAA;AAyIA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/IA;AACA;AAEA;AAEA;AAuBA;AAKA;AACA;AACA;AACA;AACA;AACA;AAoBA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA9DA;AAIA;;;AAnCA;;;AAKA;;;AAKA;;;AAKA;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA+CA;;;;;;;;;;;;;;;;;;;;;;;;ACvGA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAhDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA0CA;;;;;;;;;;;;;;;;;;;;;AC/DA;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACrCA;AACA;AACA;AAIA;AASA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAAA;AAMA;AACA;AAIA;AAIA;AAIA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAKA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AArOA;;AANA;AAEA;AAEA;AAEA;AAJA;AAEA;AAEA;AAiPA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9PA;AACA;AACA;AACA;AAEA;AAGA;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAvCA;AACA;;AAZA;;AAIA;;AAIA;AAKA;AACA;AACA;AACA;AAmCA;;;;;;;;;;;;;;;;;;;;;;;AC7DA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AA6BA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AAEA;AAiBA;AACA;;;;;;;AASA;AAEA;AAEA;AACA;AAGA;;;;;;AAQA;;AAEA;AACA;AACA;;;;;;;;;;;AAWA;AAEA;AAEA;AACA;;;;;AAOA;AAEA;;;;;;;AASA;AAEA;AAEA;AACA;;AAIA;;AAIA;;;;;;AAMA;AAGA;AACA;AAGA;AACA;;;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAxHA;;AAFA;AAGA;AAUA;AACA;AA6GA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChIA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAKA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5PA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC1GA;AACA;AA6BA;AAqBA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AA1EA;;AANA;AACA;AACA;AACA;AACA;AAGA;AAOA;AACA;AACA;AACA;AACA;AA+DA;;;;;;;;;;;;;;;;;;;;;;;;;AC/GA;AAUA;AAAA;AAMA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AA3CA;;;AACA;AACA;AACA;AAyCA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACtGA;AAEA;AAGA;AAIA;AAGA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAKA;AACA;AAEA;AAKA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAKA;AACA;AAEA;AAKA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAIA;AAKA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACpNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AAIA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAGA;AAFA;AAKA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACpJA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AChBA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AA6BA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AADA;AA8BA;AACA;AACA;AAsDA;AArDA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAvNA;;;AAnBA;;AAAA;;AAcA;;AAAA;;AACA;;AAAA;;AACA;;AAAA;;AACA;;AAAA;;AAGA;AACA;AArBA;AAgBA;AAOA;AAGA;AACA;AAgNA;;;;;;;;;;;;;;;;;;;;;;;;AClYA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;ACvDA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAUA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAxCA;;AAAA;AAAA;AAyCA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AADA;AAKA;AAEA;AACA;AACA;AAEA;;;AAGA;AAEA;AACA;AAEA;;;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AArDA;;AAAA;AAAA;AAsDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvLA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAVA;;AACA;AAIA;;;AALA;AAYA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AATA;;AACA;AAGA;;;AAJA;;;;;;;;;;;;;;;;;;;;;;;;ACnCA;AAEA"}