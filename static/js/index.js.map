{"version":3,"file":"static/js/index.js","sources":["/home/runner/work/auditory-reader/auditory-reader/src/web/app.scss","/home/runner/work/auditory-reader/auditory-reader/src/web/common/hint-text.module.scss","/home/runner/work/auditory-reader/auditory-reader/src/web/components/file-input.module.scss","/home/runner/work/auditory-reader/auditory-reader/src/web/components/pinch-zoom-pan.module.scss","/home/runner/work/auditory-reader/auditory-reader/src/web/hotkey/hotkey-state.module.scss","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/index.module.scss","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view.module.scss","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/book-search.module.scss","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/layout/layout.module.scss","/home/runner/work/auditory-reader/auditory-reader/src/core/book/enums.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/route/use-fetch.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/util/antd.tsx","/home/runner/work/auditory-reader/auditory-reader/src/core/util/emitter.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/util/promise.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/util/speech.ts","/home/runner/work/auditory-reader/auditory-reader/src/core/util/timer.ts","/home/runner/work/auditory-reader/auditory-reader/src/web/api.ts","/home/runner/work/auditory-reader/auditory-reader/src/web/app.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/atoms.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/common/confirm.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/common/hint-text.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/common/preview-image.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/common/swipe-action.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/components/file-input.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/components/flex-box.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/components/icon.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/components/input-number.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/components/language-select.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/components/link-wrap.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/components/pinch-zoom-pan.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/components/spin.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/components/textarea.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/hooks/use-escape.ts","/home/runner/work/auditory-reader/auditory-reader/src/web/hooks/use-style.ts","/home/runner/work/auditory-reader/auditory-reader/src/web/hooks/use-synced-debounce.ts","/home/runner/work/auditory-reader/auditory-reader/src/web/hooks/use-title.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/hotkey/hotkey-state.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/index.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/locale/i18n.ts","/home/runner/work/auditory-reader/auditory-reader/src/web/locale/langs/en.ts","/home/runner/work/auditory-reader/auditory-reader/src/web/locale/langs/zh.ts","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/add-successful.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/add.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/add/file.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/add/text.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/add/url.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/edit.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/entry.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/index-atoms.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/index.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view.context.ts","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/book-search.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/highlight/annotation-highlight.ts","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/highlight/highlight.ts","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/highlight/keyword-highlight.ts","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/highlight/utterer-highlight.ts","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/panel/annotations-dialogs.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/panel/annotations.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/panel/keywords-dialogs.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/panel/keywords.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/panel/nav.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/panel/panel.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/player-annotations.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/player-iframe-controller.ts","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/player-keywords.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/player-states.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/player-ui.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/player.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/progress-bar.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/sound.ts","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/utterer.ts","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/books/view/viewer.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/entry.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/layout/drag-file.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/layout/layout.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/layout/settings.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/layout/use-app-bar.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/login.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/pages/not-found.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/service-worker/register.ts","/home/runner/work/auditory-reader/auditory-reader/src/web/store.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/style.tsx","/home/runner/work/auditory-reader/auditory-reader/src/web/theme.tsx"],"sourcesContent":["// extracted by css-extract-rspack-plugin\nexport {};\n    if(module.hot) {\n      (function() {\n        var localsJsonString = undefined;\n        // 1727936079138\n        var cssReload = require(\"../../node_modules/.pnpm/@rspack+core@1.0.8_@swc+helpers@0.5.13/node_modules/@rspack/core/dist/builtin-plugin/css-extract/hmr/hotModuleReplacement.js\").cssReload(module.id, {});\n        // only invalidate when locals change\n        if (\n          module.hot.data &&\n          module.hot.data.value &&\n          module.hot.data.value !== localsJsonString\n        ) {\n          module.hot.invalidate();\n        } else {\n          module.hot.accept();\n        }\n        module.hot.dispose(function(data) {\n          data.value = localsJsonString;\n          cssReload();\n        });\n      })();\n    }\n  ","// extracted by css-extract-rspack-plugin\nexport default {\"hint\":\"src-web-common-hint-text-module__hint-cMFGU8\"};\n    if(module.hot) {\n      (function() {\n        var localsJsonString = \"{\\\"hint\\\":\\\"src-web-common-hint-text-module__hint-cMFGU8\\\"}\";\n        // 1727936079169\n        var cssReload = require(\"../../../node_modules/.pnpm/@rspack+core@1.0.8_@swc+helpers@0.5.13/node_modules/@rspack/core/dist/builtin-plugin/css-extract/hmr/hotModuleReplacement.js\").cssReload(module.id, {});\n        // only invalidate when locals change\n        if (\n          module.hot.data &&\n          module.hot.data.value &&\n          module.hot.data.value !== localsJsonString\n        ) {\n          module.hot.invalidate();\n        } else {\n          module.hot.accept();\n        }\n        module.hot.dispose(function(data) {\n          data.value = localsJsonString;\n          cssReload();\n        });\n      })();\n    }\n  ","// extracted by css-extract-rspack-plugin\nexport default {\"fileInput\":\"src-web-components-file-input-module__fileInput-jzkJ9C\"};\n    if(module.hot) {\n      (function() {\n        var localsJsonString = \"{\\\"fileInput\\\":\\\"src-web-components-file-input-module__fileInput-jzkJ9C\\\"}\";\n        // 1727936079224\n        var cssReload = require(\"../../../node_modules/.pnpm/@rspack+core@1.0.8_@swc+helpers@0.5.13/node_modules/@rspack/core/dist/builtin-plugin/css-extract/hmr/hotModuleReplacement.js\").cssReload(module.id, {});\n        // only invalidate when locals change\n        if (\n          module.hot.data &&\n          module.hot.data.value &&\n          module.hot.data.value !== localsJsonString\n        ) {\n          module.hot.invalidate();\n        } else {\n          module.hot.accept();\n        }\n        module.hot.dispose(function(data) {\n          data.value = localsJsonString;\n          cssReload();\n        });\n      })();\n    }\n  ","// extracted by css-extract-rspack-plugin\nexport default {\"overlay\":\"src-web-components-pinch-zoom-pan-module__overlay-RAuidH\",\"container\":\"src-web-components-pinch-zoom-pan-module__container-s1K_V6\",\"center\":\"src-web-components-pinch-zoom-pan-module__center-V6m0hj\"};\n    if(module.hot) {\n      (function() {\n        var localsJsonString = \"{\\\"overlay\\\":\\\"src-web-components-pinch-zoom-pan-module__overlay-RAuidH\\\",\\\"container\\\":\\\"src-web-components-pinch-zoom-pan-module__container-s1K_V6\\\",\\\"center\\\":\\\"src-web-components-pinch-zoom-pan-module__center-V6m0hj\\\"}\";\n        // 1727936079209\n        var cssReload = require(\"../../../node_modules/.pnpm/@rspack+core@1.0.8_@swc+helpers@0.5.13/node_modules/@rspack/core/dist/builtin-plugin/css-extract/hmr/hotModuleReplacement.js\").cssReload(module.id, {});\n        // only invalidate when locals change\n        if (\n          module.hot.data &&\n          module.hot.data.value &&\n          module.hot.data.value !== localsJsonString\n        ) {\n          module.hot.invalidate();\n        } else {\n          module.hot.accept();\n        }\n        module.hot.dispose(function(data) {\n          data.value = localsJsonString;\n          cssReload();\n        });\n      })();\n    }\n  ","// extracted by css-extract-rspack-plugin\nexport default {\"hotkeyList\":\"src-web-hotkey-hotkey-state-module__hotkeyList-X2vODR\"};\n    if(module.hot) {\n      (function() {\n        var localsJsonString = \"{\\\"hotkeyList\\\":\\\"src-web-hotkey-hotkey-state-module__hotkeyList-X2vODR\\\"}\";\n        // 1727936079169\n        var cssReload = require(\"../../../node_modules/.pnpm/@rspack+core@1.0.8_@swc+helpers@0.5.13/node_modules/@rspack/core/dist/builtin-plugin/css-extract/hmr/hotModuleReplacement.js\").cssReload(module.id, {});\n        // only invalidate when locals change\n        if (\n          module.hot.data &&\n          module.hot.data.value &&\n          module.hot.data.value !== localsJsonString\n        ) {\n          module.hot.invalidate();\n        } else {\n          module.hot.accept();\n        }\n        module.hot.dispose(function(data) {\n          data.value = localsJsonString;\n          cssReload();\n        });\n      })();\n    }\n  ","// extracted by css-extract-rspack-plugin\nexport default {\"hover\":\"src-web-pages-books-index-module__hover-MhvhD5\",\"table\":\"src-web-pages-books-index-module__table-OXXVHq\"};\n    if(module.hot) {\n      (function() {\n        var localsJsonString = \"{\\\"hover\\\":\\\"src-web-pages-books-index-module__hover-MhvhD5\\\",\\\"table\\\":\\\"src-web-pages-books-index-module__table-OXXVHq\\\"}\";\n        // 1727936079220\n        var cssReload = require(\"../../../../node_modules/.pnpm/@rspack+core@1.0.8_@swc+helpers@0.5.13/node_modules/@rspack/core/dist/builtin-plugin/css-extract/hmr/hotModuleReplacement.js\").cssReload(module.id, {});\n        // only invalidate when locals change\n        if (\n          module.hot.data &&\n          module.hot.data.value &&\n          module.hot.data.value !== localsJsonString\n        ) {\n          module.hot.invalidate();\n        } else {\n          module.hot.accept();\n        }\n        module.hot.dispose(function(data) {\n          data.value = localsJsonString;\n          cssReload();\n        });\n      })();\n    }\n  ","// extracted by css-extract-rspack-plugin\nexport default {\"contentWrapper\":\"src-web-pages-books-view-module__contentWrapper-xRbIAt\"};\n    if(module.hot) {\n      (function() {\n        var localsJsonString = \"{\\\"contentWrapper\\\":\\\"src-web-pages-books-view-module__contentWrapper-xRbIAt\\\"}\";\n        // 1727936079215\n        var cssReload = require(\"../../../../node_modules/.pnpm/@rspack+core@1.0.8_@swc+helpers@0.5.13/node_modules/@rspack/core/dist/builtin-plugin/css-extract/hmr/hotModuleReplacement.js\").cssReload(module.id, {});\n        // only invalidate when locals change\n        if (\n          module.hot.data &&\n          module.hot.data.value &&\n          module.hot.data.value !== localsJsonString\n        ) {\n          module.hot.invalidate();\n        } else {\n          module.hot.accept();\n        }\n        module.hot.dispose(function(data) {\n          data.value = localsJsonString;\n          cssReload();\n        });\n      })();\n    }\n  ","// extracted by css-extract-rspack-plugin\nexport default {\"bookSearchResult\":\"src-web-pages-books-view-book-search-module__bookSearchResult-wN3fTI\"};\n    if(module.hot) {\n      (function() {\n        var localsJsonString = \"{\\\"bookSearchResult\\\":\\\"src-web-pages-books-view-book-search-module__bookSearchResult-wN3fTI\\\"}\";\n        // 1727936079226\n        var cssReload = require(\"../../../../../node_modules/.pnpm/@rspack+core@1.0.8_@swc+helpers@0.5.13/node_modules/@rspack/core/dist/builtin-plugin/css-extract/hmr/hotModuleReplacement.js\").cssReload(module.id, {});\n        // only invalidate when locals change\n        if (\n          module.hot.data &&\n          module.hot.data.value &&\n          module.hot.data.value !== localsJsonString\n        ) {\n          module.hot.invalidate();\n        } else {\n          module.hot.accept();\n        }\n        module.hot.dispose(function(data) {\n          data.value = localsJsonString;\n          cssReload();\n        });\n      })();\n    }\n  ","// extracted by css-extract-rspack-plugin\nexport default {\"appBar\":\"src-web-pages-layout-layout-module__appBar-h5IaFg\"};\n    if(module.hot) {\n      (function() {\n        var localsJsonString = \"{\\\"appBar\\\":\\\"src-web-pages-layout-layout-module__appBar-h5IaFg\\\"}\";\n        // 1727936079207\n        var cssReload = require(\"../../../../node_modules/.pnpm/@rspack+core@1.0.8_@swc+helpers@0.5.13/node_modules/@rspack/core/dist/builtin-plugin/css-extract/hmr/hotModuleReplacement.js\").cssReload(module.id, {});\n        // only invalidate when locals change\n        if (\n          module.hot.data &&\n          module.hot.data.value &&\n          module.hot.data.value !== localsJsonString\n        ) {\n          module.hot.invalidate();\n        } else {\n          module.hot.accept();\n        }\n        module.hot.dispose(function(data) {\n          data.value = localsJsonString;\n          cssReload();\n        });\n      })();\n    }\n  ","export const sortOrders = [\n  'default',\n  'reverse',\n  'name',\n  'name-reverse',\n] as const\nexport type SortOrder = (typeof sortOrders)[number]\n","import type { DependencyList } from 'react'\nimport { useCallback, useEffect, useRef, useState } from 'react'\n\nexport type ReloadOptions = {\n  signal?: AbortSignal | undefined\n  clean?: boolean | undefined\n}\n\nexport function useFetchBase<Res>(\n  callback: () => Promise<Res>,\n  option?: { deps?: DependencyList },\n) {\n  const refCallback = useRef(callback)\n  const [data, setData] = useState<Res>()\n  const [error, setError] = useState<Error>()\n\n  const load = useCallback((signal: AbortSignal) => {\n    refCallback\n      .current()\n      .then((res) => {\n        if (signal.aborted) return\n        setData(res)\n      })\n      .catch((error) => {\n        if (signal.aborted) return\n        setError(error)\n      })\n  }, [])\n\n  const reload = useCallback(\n    ({ signal, clean = true }: ReloadOptions = {}) => {\n      if (clean) setData(undefined)\n      setError(undefined)\n      load(signal ?? new AbortController().signal)\n    },\n    [load],\n  )\n\n  useEffect(() => {\n    refCallback.current = callback\n  }, [callback])\n\n  useEffect(\n    () => {\n      const abort = new AbortController()\n      load(abort.signal)\n      return () => {\n        abort.abort()\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    option?.deps ?? [],\n  )\n\n  return { data, error, reload }\n}\n\nexport function useFetch<\n  Res,\n  Args extends Readonly<Array<any>> | readonly [any],\n>(args: Args, callback: (...args: Args) => Promise<Res>) {\n  return useFetchBase(() => callback(...args), { deps: [JSON.stringify(args)] })\n}\n","import type React from 'react'\n\nexport const filterOptionLabel = <T,>(\n  search: string,\n  option:\n    | {\n        label: React.ReactNode\n        value: T\n      }\n    | {\n        label: React.ReactNode\n        value: undefined\n      }\n    | undefined,\n) => {\n  if (!option) return false\n  if (typeof option.label !== 'string') return false\n  return option.label.toLowerCase().includes(search.toLowerCase())\n}\n","type Disposable = () => void\n\ntype Callback<T> = (value: T) => void | Promise<void>\n\ntype Listener<T> = { cb: Callback<T>; options: OnOptions }\n\ntype OnOptions = { once?: boolean }\n\nexport class SingleEmitter<T> {\n  #callbacks: Listener<T>[] = []\n\n  constructor(protected defaultOptions: OnOptions = {}) {}\n\n  on(callback: Callback<T>, options: OnOptions = {}): Disposable {\n    const listener = {\n      cb: callback,\n      options: {\n        ...this.defaultOptions,\n        ...options,\n      },\n    }\n    this.#callbacks.push(listener)\n\n    return () => {\n      this.off(listener)\n    }\n  }\n\n  fire(value: T) {\n    for (const callback of this.#callbacks) {\n      if (callback.options.once) this.off(callback)\n      Promise.resolve(callback.cb(value)).catch(console.error)\n    }\n  }\n\n  off(callback: Listener<T>) {\n    const idx = this.#callbacks.findIndex(() => callback)\n    if (idx === -1) return\n    this.#callbacks.splice(idx, 1)\n  }\n}\n\nexport class Emitter<T extends Record<string, any>> {\n  #listeners = new Map<string, SingleEmitter<any>>()\n\n  on<K extends keyof T & string>(\n    name: K,\n    callback: Callback<T[K]>,\n  ): Disposable {\n    let sEmitter = this.#listeners.get(name)\n    if (!sEmitter) {\n      sEmitter = new SingleEmitter()\n      this.#listeners.set(name, sEmitter)\n    }\n    return sEmitter.on(callback)\n  }\n\n  fire<K extends keyof T & string>(name: K, value: T[K]) {\n    const sEmitter = this.#listeners.get(name)\n    if (!sEmitter) return\n    Promise.resolve(sEmitter.fire(value)).catch(console.error)\n  }\n\n  off<K extends keyof T & string>(name: K) {\n    this.#listeners.delete(name)\n  }\n}\n\n/**\n * Emitter only fired when value changed\n */\nexport class ChangedEmitter<T extends Record<string, any>> extends Emitter<T> {\n  #lastValues = new Map<string, unknown>()\n\n  on<K extends keyof T & string>(\n    name: K,\n    callback: (value: T[K], prevValue?: T[K]) => void | Promise<void>,\n  ): Disposable {\n    return super.on(name, (value) =>\n      callback(value, this.#lastValues.get(name) as T[K]),\n    )\n  }\n\n  fire<K extends keyof T & string>(name: K, value: T[K]) {\n    if (!this.#lastValues.has(name) || this.#lastValues.get(name) !== value) {\n      this.#lastValues.set(name, value)\n      super.fire(name, value)\n    }\n  }\n}\n","export const async = (fn: () => Promise<unknown>) => {\n  fn().catch(console.error)\n}\n\nexport const sleep = (ms: number) => {\n  return new Promise<void>((resolve) => {\n    setTimeout(resolve, ms)\n  })\n}\n\nexport const nextTick = () => {\n  return new Promise<void>((resolve) => {\n    setTimeout(() => {\n      resolve()\n    })\n  })\n}\n","import { rainStart, rainStop } from '../../web/pages/books/view/sound.js'\nimport { ZH_PERSON_RULES } from '../consts.js'\nimport { findLast, findLastIndex, orderBy, range } from './collection.js'\nimport type { TextAlias } from './readable.js'\n\ntype AliasResult = {\n  text: string\n  highlightOffsets: [index: number, accOffset: number][]\n}\n\ntype HighlightEvent = {\n  charIndex: number\n  charLength: number\n}\n\nexport type SpeakResult = 'cancel' | 'done'\n\nfunction replacePersonText(text: string): string {\n  for (const [key, value] of Object.entries(ZH_PERSON_RULES)) {\n    text = text.replaceAll(key, value.word)\n  }\n  return text\n}\n\ntype QuotePosition = { type: 'start' | 'end'; charIndex: number }\nfunction getQuotePositions(text: string): QuotePosition[] {\n  const pos: QuotePosition[] = []\n  for (const [i, m] of [...text.matchAll(/\"|'/g)].entries()) {\n    if (i % 2 === 0) {\n      pos.push({\n        type: 'start',\n        charIndex: m.index,\n      })\n    } else {\n      pos.push({\n        type: 'end',\n        charIndex: m.index,\n      })\n    }\n  }\n  for (const m of text.matchAll(/“|‘|「|『/g)) {\n    pos.push({\n      type: 'start',\n      charIndex: m.index,\n    })\n  }\n  for (const m of text.matchAll(/”|’|」|』/g)) {\n    pos.push({\n      type: 'end',\n      charIndex: m.index,\n    })\n  }\n  return orderBy(pos, 'asc', (p) => p.charIndex)\n}\n\nexport class Speech {\n  public utterance: SpeechSynthesisUtterance\n  public state: 'speaking' | 'none' | 'cancel' = 'none'\n\n  constructor() {\n    this.utterance = new SpeechSynthesisUtterance()\n  }\n\n  private aliasReplace(text: string, aliasArray: TextAlias[]): AliasResult {\n    if (!aliasArray.length)\n      return {\n        text,\n        highlightOffsets: [],\n      }\n\n    const highlightOffsets: [index: number, accOffset: number][] = []\n    const indexMap = new Map<number, TextAlias>()\n    for (const alias of aliasArray) {\n      let i = -1\n      // eslint-disable-next-line no-constant-condition, @typescript-eslint/no-unnecessary-condition\n      while (true) {\n        i = text.indexOf(alias.source, i + 1)\n        if (i === -1) break\n        else if (!indexMap.has(i)) {\n          indexMap.set(i, alias)\n        }\n      }\n    }\n    const orderedIndexes = orderBy([...indexMap.entries()], 'asc', ([i]) => i)\n    let accOffset = 0\n    for (const [i, { source, target }] of orderedIndexes) {\n      text = text.replace(source, target)\n      const unitOffset = source.length - target.length\n      if (unitOffset === 0) continue\n      const afterI = i - accOffset\n      highlightOffsets.push([afterI, accOffset])\n      for (const j of range(1, target.length)) {\n        highlightOffsets.push([\n          afterI + j,\n          accOffset + Math.floor(unitOffset * (j / target.length)),\n        ])\n      }\n      accOffset = accOffset + unitOffset\n    }\n    return { text, highlightOffsets }\n  }\n\n  cancel() {\n    this.state = 'cancel'\n    if (speechSynthesis.speaking) speechSynthesis.cancel()\n  }\n\n  async speak(\n    text: string,\n    {\n      speed,\n      voice,\n      isPersonReplace,\n      quote = true,\n      alias,\n      onBoundary,\n    }: {\n      speed: number\n      voice: SpeechSynthesisVoice\n      isPersonReplace: boolean\n      quote?: boolean\n      alias?: TextAlias[]\n      onBoundary?: (event: HighlightEvent) => void\n    },\n  ) {\n    this.state = 'speaking'\n    text = isPersonReplace ? replacePersonText(text) : text\n\n    // boundary\n    const boundaryListeners: ((event: SpeechSynthesisEvent) => void)[] = []\n\n    if (quote) {\n      const quotePositions = getQuotePositions(text)\n      boundaryListeners.push((event: SpeechSynthesisEvent) => {\n        // quote & rain\n        const quotePosIndex = findLastIndex(\n          quotePositions,\n          (p) => p.charIndex <= event.charIndex,\n        )\n        if (quotePosIndex === undefined) return rainStop()\n        const posPass = quotePositions.slice(0, quotePosIndex + 1)\n        const startPosList = posPass.filter((p) => p.type === 'start')\n        const endPosList = posPass.filter((p) => p.type === 'end')\n        if (startPosList.length > endPosList.length) {\n          rainStart()\n        } else {\n          rainStop()\n        }\n      })\n    }\n\n    if (onBoundary)\n      if (alias && alias.length) {\n        const aliasResult = this.aliasReplace(text, alias)\n        text = aliasResult.text\n\n        const highlightOffsetTable = aliasResult.highlightOffsets\n\n        const highlightOffsetFn: (event: HighlightEvent) => HighlightEvent =\n          highlightOffsetTable.length\n            ? (event) => {\n                const startOffset = findLast(\n                  highlightOffsetTable,\n                  ([i]) => i <= event.charIndex,\n                )\n                if (!startOffset) return event\n                const charEndIndex = event.charIndex + event.charLength\n                const endOffset = findLast(\n                  highlightOffsetTable,\n                  ([i]) => i <= charEndIndex,\n                )\n                if (!endOffset) return event\n                const charIndex = event.charIndex + (startOffset.at(1) ?? 0)\n                const charLength =\n                  charEndIndex + (endOffset.at(1) ?? 0) - charIndex\n                return {\n                  charIndex,\n                  charLength,\n                }\n              }\n            : (event) => event\n\n        boundaryListeners.push((event: SpeechSynthesisEvent) => {\n          onBoundary(highlightOffsetFn(event))\n        })\n      } else {\n        boundaryListeners.push((event: SpeechSynthesisEvent) => {\n          onBoundary(event)\n        })\n      }\n\n    for (const boundaryListener of boundaryListeners) {\n      this.utterance.addEventListener('boundary', boundaryListener)\n    }\n\n    this.utterance.rate = speed\n    this.utterance.voice = voice\n    this.utterance.text = text\n    speechSynthesis.speak(this.utterance)\n\n    const result = await new Promise<SpeakResult>((resolve, reject) => {\n      this.utterance.addEventListener(\n        'end',\n        () => {\n          resolve(this.state === 'cancel' ? 'cancel' : 'done')\n        },\n        { once: true },\n      )\n      this.utterance.addEventListener(\n        'error',\n        (error) => {\n          if (this.state === 'cancel') resolve('cancel')\n          else reject(error)\n        },\n        { once: true },\n      )\n    })\n\n    for (const boundaryListener of boundaryListeners) {\n      this.utterance.removeEventListener('boundary', boundaryListener)\n    }\n    rainStop()\n    this.state = 'none'\n    return result\n  }\n}\n","import { range } from './collection.js'\nimport { sleep } from './promise.js'\n\nexport function debounceFn<A extends Array<any>>(\n  delay: number,\n  fn: (...args: A) => void,\n): (...args: A) => void {\n  let timer: NodeJS.Timeout | undefined\n  return (...args: A) => {\n    clearTimeout(timer)\n    timer = setTimeout(() => fn(...args), delay)\n  }\n}\n\nexport function throttleFn<A extends Array<any>, R>(\n  delay: number,\n  fn: (...args: A) => R,\n): (...args: A) => R | void {\n  let isThrottled = false\n  return (...args: A) => {\n    if (!isThrottled) {\n      const result = fn(...args)\n      isThrottled = true\n      setTimeout(() => (isThrottled = false), delay)\n      return result\n    }\n  }\n}\n\nexport function throttleTailFn<A extends Array<any>, R>(\n  delay: number,\n  fn: (...args: A) => R,\n): (...args: A) => R | void {\n  let timer: NodeJS.Timeout | undefined\n  let isThrottled = false\n  return (...args: A) => {\n    clearTimeout(timer)\n    if (isThrottled) {\n      timer = setTimeout(() => fn(...args), delay)\n    } else {\n      const result = fn(...args)\n      isThrottled = true\n      setTimeout(() => (isThrottled = false), delay)\n      return result\n    }\n  }\n}\n\nexport interface IterateAnimateOptions {\n  iteration?: number\n  duration?: number\n  abortCtrl?: AbortController\n}\n\nexport async function iterateAnimate(\n  { iteration = 10, duration = 100, abortCtrl }: IterateAnimateOptions,\n  callback: (index: number) => unknown,\n) {\n  let aborted = false as boolean\n  abortCtrl?.signal.addEventListener('abort', () => {\n    aborted = true\n  })\n\n  const unitTime = duration / iteration\n  for (const i of range(0, iteration + 1)) {\n    await sleep(unitTime)\n    if (aborted) break\n    await callback(i)\n  }\n}\n","import type { BookCreateByUrl } from '../core/api/books/create-by-url.js'\nimport { booksCreateByUrlRouter } from '../core/api/books/create-by-url.js'\nimport type { BookCreate } from '../core/api/books/create.js'\nimport { booksCreateRouter } from '../core/api/books/create.js'\nimport type { BookFetchUrlInfoQuery } from '../core/api/books/fetch-url-info.js'\nimport { booksFetchUrlInfoRouter } from '../core/api/books/fetch-url-info.js'\nimport type { BookMoveTopItQuery } from '../core/api/books/move-top.js'\nimport { booksMoveTopRouter } from '../core/api/books/move-top.js'\nimport {\n  booksSearchRouter,\n  type BookSearchMatch,\n  type BookSearchQuery,\n} from '../core/api/books/search.js'\nimport type { BookUpdateQuery } from '../core/api/books/update.js'\nimport { booksUpdateRouter } from '../core/api/books/update.js'\nimport type { BookTypes } from '../core/book/types.js'\n\nexport const API = {\n  book: {\n    async add(params: BookCreate): Promise<BookTypes.EntityJson> {\n      return await booksCreateRouter.action(params)\n    },\n    async fetchUrlInfo(params: BookFetchUrlInfoQuery) {\n      return await booksFetchUrlInfoRouter.action(params)\n    },\n    async addByUrl(params: BookCreateByUrl): Promise<BookTypes.EntityJson> {\n      return await booksCreateByUrlRouter.action(params)\n    },\n    async update(params: BookUpdateQuery): Promise<void> {\n      await booksUpdateRouter.action(params)\n    },\n    async top(params: BookMoveTopItQuery): Promise<void> {\n      await booksMoveTopRouter.action(params)\n    },\n    async search(\n      params: BookSearchQuery,\n    ): Promise<{ matches: BookSearchMatch[] }> {\n      return await booksSearchRouter.action(params)\n    },\n  },\n}\n\nwindow.API = API\n","// styles\nimport './app.scss'\n\n// modules\nimport { Alert } from 'antd'\nimport 'antd/dist/reset.css'\nimport { Provider } from 'jotai'\nimport { useEffect, useState } from 'react'\nimport { DndProvider } from 'react-dnd'\nimport { HTML5Backend } from 'react-dnd-html5-backend'\nimport { COLOR_SCHEME_DARK_CLASS } from '../core/consts.js'\nimport { ConfirmProvider } from './common/confirm.js'\nimport { HintTextProvider } from './common/hint-text.js'\nimport { MessageProvider, NotificationProvider } from './common/notification.js'\nimport { PreviewImageProvider } from './common/preview-image.js'\nimport { SpinFullscreen } from './components/spin.js'\nimport { useStyle } from './hooks/use-style.js'\nimport { TitleProvider } from './hooks/use-title.js'\nimport { HotkeysProvider } from './hotkey/hotkey-state.js'\nimport { RootEntry } from './pages/entry.js'\nimport { registerAPI } from './service-worker/register.js'\nimport { globalStore } from './store/global.js'\nimport { globalStyle } from './style.js'\nimport { AntdConfigProvider, useColorScheme } from './theme.js'\n\nfunction AppEntry() {\n  const theme = useColorScheme()\n  const [loadedStatus, setLoadedStatus] = useState<boolean | string>(false)\n\n  useEffect(() => {\n    registerAPI()\n      .then((status) => {\n        if (status === 'unsupported')\n          setLoadedStatus('Service worker is unsupported')\n        else if (status === 'failed')\n          setLoadedStatus('Service worker load failed')\n        else setLoadedStatus(true)\n      })\n      .catch((err) => {\n        setLoadedStatus('Service worker load failed')\n        console.error(err)\n      })\n  }, [])\n\n  useEffect(() => {\n    if (theme === 'dark')\n      document.documentElement.classList.add(COLOR_SCHEME_DARK_CLASS)\n    else document.documentElement.classList.remove(COLOR_SCHEME_DARK_CLASS)\n  }, [theme])\n  useStyle(globalStyle)\n\n  return (\n    <>\n      {loadedStatus === true && <RootEntry></RootEntry>}\n      {loadedStatus === false && <SpinFullscreen />}\n      {typeof loadedStatus === 'string' && (\n        <Alert type=\"error\" message={loadedStatus}></Alert>\n      )}\n    </>\n  )\n}\n\nfunction AppProvider() {\n  return (\n    <AntdConfigProvider>\n      <DndProvider backend={HTML5Backend}>\n        <AppEntry></AppEntry>\n        <NotificationProvider></NotificationProvider>\n        <MessageProvider></MessageProvider>\n        <HintTextProvider></HintTextProvider>\n        <PreviewImageProvider></PreviewImageProvider>\n        <ConfirmProvider></ConfirmProvider>\n        <TitleProvider></TitleProvider>\n        <HotkeysProvider></HotkeysProvider>\n      </DndProvider>\n    </AntdConfigProvider>\n  )\n}\n\nexport function App() {\n  return (\n    <Provider store={globalStore}>\n      <AppProvider></AppProvider>\n    </Provider>\n  )\n}\n","import { atom } from 'jotai'\n\nexport const iframeWinAtom = atom<{ win: Window | null }>({ win: null })\n","import { useSyncedRef } from '@react-hookz/web'\nimport { Button, Modal, Space } from 'antd'\nimport { t } from 'i18next'\nimport { atom, useAtom } from 'jotai'\nimport { useCallback, useEffect } from 'react'\nimport { useKeyEscape } from '../hooks/use-escape.js'\nimport { useHotkeys } from '../hotkey/hotkey-state.js'\nimport { globalStore } from '../store/global.js'\nimport { Icon } from '../components/icon.js'\nimport { faQuestionCircle } from '@fortawesome/free-solid-svg-icons'\n\nconst confirmAtom = atom<null | {\n  title: React.ReactNode\n  description?: React.ReactNode\n  okCallback: () => void\n  cancelCallback: () => void\n}>(null)\n\nexport function uiConfirm(options: {\n  title: React.ReactNode\n  description?: React.ReactNode\n}): Promise<boolean> {\n  return new Promise<boolean>((resolve) => {\n    globalStore.set(confirmAtom, {\n      ...options,\n      okCallback: () => resolve(true),\n      cancelCallback: () => resolve(false),\n    })\n  })\n}\n\nexport function useConfirm() {\n  const [, setConfirm] = useAtom(confirmAtom)\n\n  const confirm = useCallback(\n    (options: { title: React.ReactNode; description?: React.ReactNode }) => {\n      return new Promise<boolean>((resolve) => {\n        setConfirm({\n          ...options,\n          okCallback: () => resolve(true),\n          cancelCallback: () => resolve(false),\n        })\n      })\n    },\n    [setConfirm],\n  )\n\n  return confirm\n}\n\nexport const useConfirmHotkey = ({\n  enable = true,\n  onOk,\n  onClose,\n  level = 100,\n}: {\n  enable?: boolean\n  onOk: () => void\n  onClose?: () => void\n  level?: number\n}) => {\n  const { addHotkey } = useHotkeys()\n  const onOkRef = useSyncedRef(onOk)\n  const onCloseRef = useSyncedRef(onClose)\n\n  useEffect(() => {\n    if (enable) {\n      return addHotkey(\n        'Enter',\n        t('hotkey.ok'),\n        () => {\n          onOkRef.current()\n        },\n        { level },\n      )\n    }\n  }, [addHotkey, enable, level, onOkRef])\n\n  useKeyEscape(\n    () => {\n      onCloseRef.current?.()\n    },\n    { enable: !!enable && !!onClose },\n  )\n}\n\nfunction ConfirmDialog() {\n  const [confirm, setConfirm] = useAtom(confirmAtom)\n\n  const onClose = useCallback(() => {\n    setConfirm(null)\n  }, [setConfirm])\n\n  const onCancel = useCallback(() => {\n    confirm?.cancelCallback()\n    onClose()\n  }, [confirm, onClose])\n\n  const onOk = useCallback(() => {\n    confirm?.okCallback()\n    onClose()\n  }, [confirm, onClose])\n\n  useConfirmHotkey({\n    enable: !!confirm,\n    onOk,\n    onClose: onCancel,\n  })\n\n  return (\n    <>\n      <Modal\n        open={!!confirm}\n        onOk={onOk}\n        onCancel={onClose}\n        title={\n          <Space>\n            <Icon icon={faQuestionCircle} size=\"lg\" color=\"#ff4d4f\" />\n            {confirm?.title}\n          </Space>\n        }\n        footer={false}\n      >\n        <Space direction=\"vertical\">\n          {confirm?.description}\n          <Space>\n            <Button type=\"primary\" onClick={onClose}>\n              {t('confirm.cancel')}\n            </Button>\n            <Button type=\"primary\" onClick={onOk}>\n              {t('confirm.ok')}\n            </Button>\n          </Space>\n        </Space>\n      </Modal>\n    </>\n  )\n}\n\nexport function ConfirmProvider() {\n  const [confirm] = useAtom(confirmAtom)\n\n  if (!confirm) return <></>\n\n  return <ConfirmDialog></ConfirmDialog>\n}\n","import { atom, useAtom } from 'jotai'\nimport { useCallback, useMemo } from 'react'\nimport styles from './hint-text.module.scss'\n\nconst hintTextAtom = atom<null | string>(null)\nlet timer: NodeJS.Timeout | undefined = undefined\n\nexport function useHintText() {\n  const [, setHint] = useAtom(hintTextAtom)\n\n  const openHint = useCallback(\n    (\n      hint: string,\n      options: {\n        /** seconds */\n        timeout?: number\n      } = {},\n    ) => {\n      clearTimeout(timer)\n      const timeout = options.timeout ?? 3\n      setHint(hint)\n      timer = setTimeout(() => {\n        setHint(null)\n      }, timeout * 1000)\n    },\n    [setHint],\n  )\n\n  return useMemo(() => ({ openHint }), [openHint])\n}\n\nexport function HintTextProvider() {\n  const [hint] = useAtom(hintTextAtom)\n  return (\n    <div\n      className={styles.hint}\n      style={{ display: hint ? 'inline-block' : 'none' }}\n    >\n      {hint}\n    </div>\n  )\n}\n","import { atom, useAtom } from 'jotai'\nimport { PinchZoomPan } from '../components/pinch-zoom-pan.js'\n\nexport const previewImgSrcAtom = atom<string | null>(null)\n\nexport function PreviewImageProvider() {\n  const [src, setSrc] = useAtom(previewImgSrcAtom)\n\n  if (!src) return <></>\n\n  return (\n    <PinchZoomPan\n      onClose={() => {\n        setSrc(null)\n      }}\n    >\n      <img\n        src={src}\n        onLoad={(event) => {\n          const img = event.currentTarget\n          const imgRate = img.naturalWidth / img.naturalHeight\n          const winRate = window.innerWidth / window.innerHeight\n          if (imgRate > winRate) {\n            if (img.naturalWidth > window.innerWidth) {\n              img.width = window.innerWidth\n              img.height = window.innerWidth / imgRate\n            }\n          } else {\n            if (img.naturalHeight > window.innerHeight) {\n              img.height = window.innerHeight\n              img.width = window.innerHeight * imgRate\n            }\n          }\n        }}\n        alt=\"preview\"\n      />\n    </PinchZoomPan>\n  )\n}\n","import { useEffect, useRef, type CSSProperties, useState } from 'react'\nimport { eventBan } from '../../core/util/dom.js'\n\ntype SwipeAction = {\n  width: number\n  trigger: () => void\n}\n\nfunction mountSwipe(\n  element: HTMLElement,\n  {\n    left,\n    leftElement,\n    right,\n    rightElement,\n  }: {\n    left?: SwipeAction\n    leftElement?: HTMLDivElement\n    right?: SwipeAction\n    rightElement?: HTMLDivElement\n  },\n) {\n  if (!left && !right) return\n\n  let start: { x: number; y: number } | null = null\n  let curX: number | null = null\n\n  const getXY = (touch: Touch) => {\n    const { clientX, clientY } = touch\n    return [clientX, clientY] as const\n  }\n\n  const onStart = (event: TouchEvent) => {\n    if (!event.touches[0]) return\n    start = { x: event.touches[0].clientX, y: event.touches[0].clientY }\n    curX = 0\n  }\n\n  const onMove = (event: TouchEvent) => {\n    if (!start) return\n    const touch = event.touches[0]\n    if (!touch) return\n    const [x, y] = getXY(touch)\n    const oX = x - start.x\n    const dX = Math.abs(oX)\n    const oY = y - start.y\n    const dY = Math.abs(oY)\n    if (dY > 30) return\n    if (dX > 5) eventBan(event)\n    if (left && leftElement && oX > 0) {\n      const mX = Math.min(dX, left.width + 10)\n      curX = mX\n      element.style.transform = `translateX(${mX}px)`\n      leftElement.style.opacity = dX > left.width ? '1' : '0.5'\n    } else if (right && rightElement && oX < 0) {\n      const mX = Math.min(dX, right.width + 10)\n      curX = -mX\n      element.style.transform = `translateX(${-mX}px)`\n      rightElement.style.opacity = dX > right.width ? '1' : '0.5'\n    }\n  }\n\n  const onEnd = () => {\n    if (!start) return\n    start = null\n\n    element.style.transform = ''\n    if (leftElement) leftElement.style.opacity = '0'\n    if (rightElement) rightElement.style.opacity = '0'\n\n    if (!curX) return\n    if (left && curX > left.width) {\n      left.trigger()\n    } else if (right && rightElement && curX < -right.width) {\n      right.trigger()\n    }\n    curX = null\n  }\n\n  element.addEventListener('touchstart', onStart)\n  element.addEventListener('touchmove', onMove)\n  element.addEventListener('touchend', onEnd)\n\n  return () => {\n    element.removeEventListener('touchstart', onStart)\n    element.removeEventListener('touchmove', onMove)\n    element.removeEventListener('touchend', onEnd)\n  }\n}\n\nconst getNodeStyle = (\n  node: {\n    color?: string\n    background?: string\n    node: React.ReactNode\n  } & SwipeAction,\n): CSSProperties => ({\n  position: 'absolute',\n  top: 0,\n  width: node.width + 10,\n  height: '100%',\n  display: 'flex',\n  justifyContent: 'center',\n  alignItems: 'center',\n  color: node.color ?? 'var(--main-fg-blue)',\n  background: node.background ?? 'var(--main-bg-blue)',\n  opacity: 0,\n})\n\nexport function SwipeAction({\n  children,\n  left,\n  right,\n}: {\n  children: React.ReactNode\n  left?: {\n    color?: string\n    background?: string\n    node: React.ReactNode\n  } & SwipeAction\n  right?: {\n    color?: string\n    background?: string\n    node: React.ReactNode\n  } & SwipeAction\n}) {\n  const refElement = useRef<HTMLDivElement>(null)\n  const [leftElement, setLeftElement] = useState<HTMLDivElement>()\n  const [rightElement, setRightElement] = useState<HTMLDivElement>()\n\n  useEffect(() => {\n    if (!refElement.current) return\n    return mountSwipe(refElement.current, {\n      left,\n      leftElement,\n      right,\n      rightElement,\n    })\n  }, [left, leftElement, right, rightElement])\n\n  return (\n    <div\n      style={{\n        position: 'relative',\n        willChange: 'transform',\n      }}\n      ref={refElement}\n    >\n      {left && (\n        <div\n          ref={(element) => setLeftElement(element ?? undefined)}\n          className=\"swipe-left-node\"\n          style={{\n            ...getNodeStyle(left),\n            right: '100%',\n          }}\n        >\n          {left.node}\n        </div>\n      )}\n      {children}\n      {right && (\n        <div\n          ref={(element) => setRightElement(element ?? undefined)}\n          className=\"swipe-right-node\"\n          style={{\n            ...getNodeStyle(right),\n            left: '100%',\n          }}\n        >\n          {right.node}\n        </div>\n      )}\n    </div>\n  )\n}\n","import { faUpload } from '@fortawesome/free-solid-svg-icons'\nimport { Typography } from 'antd'\nimport { useEffect, useState } from 'react'\nimport { FlexBox } from './flex-box.js'\nimport { Icon } from './icon.js'\nimport styles from './file-input.module.scss'\n\nexport const FileInput = ({\n  accept,\n  prompt,\n  value,\n  onChange,\n}: {\n  accept?: string\n  prompt?: string\n  value?: File[]\n  onChange?: (files: File[]) => void\n}) => {\n  const [acceptedFiles, setAcceptedFiles] = useState<File[]>([])\n  useEffect(() => {\n    setAcceptedFiles(value ?? [])\n  }, [value])\n\n  return (\n    <label className={styles.fileInput}>\n      <input\n        style={{ display: 'none' }}\n        accept={accept}\n        multiple\n        type=\"file\"\n        onChange={(event) => {\n          const files = [...(event.target.files ?? [])]\n          setAcceptedFiles(files)\n          onChange?.(files)\n        }}\n      />\n      {acceptedFiles.length ? (\n        <FlexBox gap={5}>\n          {acceptedFiles.map((file, i) => {\n            return (\n              <FlexBox\n                key={i}\n                dir=\"row\"\n                gap={5}\n                style={{ alignItems: 'center' }}\n              >\n                <Icon icon={faUpload} />\n                <div>{file.name}</div>\n              </FlexBox>\n            )\n          })}\n        </FlexBox>\n      ) : (\n        <FlexBox gap={2} style={{ justifyContent: 'center' }}>\n          {prompt && <Typography>{prompt}</Typography>}\n        </FlexBox>\n      )}\n    </label>\n  )\n}\n","export interface ListViewProps extends React.HTMLAttributes<HTMLDivElement> {\n  dir?: 'row' | 'column'\n  gap?: number | string\n  flex?: number\n  children?: React.ReactNode\n}\n\nexport function FlexBox({\n  dir = 'column',\n  gap = 0,\n  flex,\n  style,\n  children,\n  ...props\n}: ListViewProps) {\n  return (\n    <div\n      style={{\n        display: 'flex',\n        flexDirection: dir,\n        gap,\n        flex,\n        ...style,\n      }}\n      {...props}\n    >\n      {children}\n    </div>\n  )\n}\n","import type { IconProp, SizeProp } from '@fortawesome/fontawesome-svg-core'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\n\nexport type IconProps = {\n  icon: IconProp\n  color?: string\n  size?: SizeProp\n  style?: React.CSSProperties\n  onClick?: React.MouseEventHandler\n}\n\nexport function Icon({ icon, size, style, onClick, color }: IconProps) {\n  return (\n    <FontAwesomeIcon\n      icon={icon}\n      size={size ?? 'lg'}\n      color={color}\n      style={{\n        paddingLeft: '6px',\n        paddingRight: '6px',\n        ...style,\n      }}\n      onClick={onClick}\n    ></FontAwesomeIcon>\n  )\n}\n","import { faArrowDown, faArrowUp } from '@fortawesome/free-solid-svg-icons'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { Button, InputNumber, Space, type InputNumberProps } from 'antd'\nimport { isMobile } from '../../core/util/browser.js'\n\nexport function RInputNumber(props: InputNumberProps<number>) {\n  if (isMobile) {\n    let step = 1\n    if (props.step !== undefined)\n      if (typeof props.step === 'number') step = props.step\n      else if (typeof props.step === 'string') step = parseFloat(props.step)\n    return (\n      <Space.Compact>\n        <Button\n          size={props.size}\n          onClick={() => {\n            const value = props.value ?? 0\n            props.onChange?.(value - step)\n          }}\n        >\n          <FontAwesomeIcon icon={faArrowDown} />\n        </Button>\n        <InputNumber<number> {...props}></InputNumber>\n        <Button\n          size={props.size}\n          onClick={() => {\n            const value = props.value ?? 0\n            props.onChange?.(value + step)\n          }}\n        >\n          <FontAwesomeIcon icon={faArrowUp} />\n        </Button>\n      </Space.Compact>\n    )\n  }\n  return <InputNumber<number> {...props}></InputNumber>\n}\n","import { Select } from 'antd'\nimport { t } from 'i18next'\nimport { useOrderedLangOptions } from '../../core/lang.js'\nimport { filterOptionLabel } from '../../core/util/antd.js'\nimport { useMemo, useState } from 'react'\n\nexport type LanguageSelectProps = {\n  value?: string\n  onChange?: (value: string) => void\n}\n\nexport function LanguageSelect({ value, onChange }: LanguageSelectProps) {\n  const langOptions = useOrderedLangOptions()\n\n  const [search, setSearch] = useState('')\n  const filteredLangOptions = useMemo(() => {\n    if (!search) return langOptions\n    const lcSearch = search.toLowerCase()\n    const matchOptions = langOptions.filter((o) => o.value === lcSearch)\n    if (matchOptions.length) return matchOptions\n    return langOptions\n  }, [langOptions, search])\n\n  return (\n    <Select\n      showSearch\n      filterOption={(search, option) => {\n        setSearch(search)\n        return filterOptionLabel(search, option)\n      }}\n      popupMatchSelectWidth={false}\n      value={value}\n      onChange={onChange}\n      placeholder={t('prompt.selectLanguage')}\n      options={filteredLangOptions}\n    ></Select>\n  )\n}\n","import { useHref } from 'react-router-dom'\n\nexport type LinkWrapProps = {\n  to: string\n  children: (href: string) => JSX.Element\n}\n\nexport function LinkWrap({ to, children }: LinkWrapProps) {\n  const href = useHref(to)\n  return children(href)\n}\n","import { useEffect, useRef } from 'react'\nimport { useKeyEscape } from '../hooks/use-escape.js'\nimport styles from './pinch-zoom-pan.module.scss'\nimport { eventBan } from '../../core/util/dom.js'\nimport { useHotkeys } from '../hotkey/hotkey-state.js'\nimport { t } from 'i18next'\n\ninterface PinchZoomPanProps {\n  onClose?: () => void\n  children: React.ReactNode\n}\n\nfunction getTouchesPageCenter(a: Touch, b: Touch) {\n  return {\n    pageX: (a.pageX + b.pageX) / 2,\n    pageY: (a.pageY + b.pageY) / 2,\n  }\n}\n\nfunction getTouchesDistance(a: Touch, b: Touch) {\n  return Math.hypot(b.clientX - a.clientX, b.clientY - a.clientY)\n}\n\nfunction getRectCenter(rect: DOMRect) {\n  return {\n    x: rect.left + rect.width / 2,\n    y: rect.top + rect.height / 2,\n  }\n}\n\nconst getWheelRate = (event: WheelEvent) => {\n  const delta = event.deltaY\n  return delta === 0 ? 0 : delta < 0 ? 1.1 : 0.9\n}\n\nconst mountPinchZoomPan = (\n  overlay: HTMLElement,\n  container: HTMLElement,\n  onClick: () => void,\n) => {\n  let moved = false\n  let action:\n    | { type: 'pinch'; range: number }\n    | { type: 'move'; x: number; y: number }\n    | null = null\n  const overlayRect = overlay.getBoundingClientRect()\n\n  let current = {\n    x: 0,\n    y: 0,\n    scale: 1,\n  }\n  let cumulative = {\n    x: 0,\n    y: 0,\n    scale: 1,\n  }\n\n  const setTransform = () => {\n    container.style.transform = `translate(${current.x}px, ${current.y}px) scale(${current.scale})`\n  }\n\n  const resetState = () => {\n    current = {\n      ...getRectCenter(overlayRect),\n      scale: 1,\n    }\n    cumulative = { ...current }\n    setTransform()\n  }\n\n  resetState()\n\n  const moving = (offset: { x: number; y: number }) => {\n    if (Math.hypot(offset.x, offset.y) >= 10) moved = true\n    current.x = cumulative.x + offset.x\n    current.y = cumulative.y + offset.y\n    setTransform()\n  }\n\n  const scaling = (offset: { pageX: number; pageY: number; rate: number }) => {\n    const scale = cumulative.scale * offset.rate\n    if (scale < 0.01) return\n    current.scale = scale\n    const rect = overlay.getBoundingClientRect()\n    const offsetX = offset.pageX - rect.left - cumulative.x\n    const offsetY = offset.pageY - rect.top - cumulative.y\n    current.x = cumulative.x + offsetX * (1 - offset.rate)\n    current.y = cumulative.y + offsetY * (1 - offset.rate)\n    setTransform()\n  }\n\n  const touchEnd = () => {\n    cumulative.x = current.x\n    cumulative.y = current.y\n    cumulative.scale = current.scale\n  }\n\n  const disposes: (() => void)[] = []\n\n  function addEventListener<K extends keyof HTMLElementEventMap>(\n    type: K,\n    listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,\n  ): void {\n    overlay.addEventListener(type, listener)\n    disposes.push(() => overlay.removeEventListener(type, listener))\n  }\n\n  // touch\n  addEventListener('touchstart', (event) => {\n    eventBan(event)\n    const touch1 = event.touches[0]\n    if (!touch1) return\n    const touch2 = event.touches[1]\n    if (touch2)\n      action = {\n        type: 'pinch',\n        range: getTouchesDistance(touch1, touch2),\n      }\n    else\n      action = {\n        type: 'move',\n        x: touch1.clientX,\n        y: touch1.clientY,\n      }\n    moved = false\n  })\n  addEventListener('touchmove', (event) => {\n    eventBan(event)\n    if (!action) return\n    const touch1 = event.touches[0]\n    if (!touch1) return\n    const touch2 = event.touches[1]\n    switch (action.type) {\n      case 'move': {\n        moving({\n          x: touch1.clientX - action.x,\n          y: touch1.clientY - action.y,\n        })\n        break\n      }\n      case 'pinch': {\n        if (touch2)\n          scaling({\n            ...getTouchesPageCenter(touch1, touch2),\n            rate: getTouchesDistance(touch1, touch2) / action.range,\n          })\n        break\n      }\n    }\n  })\n  addEventListener('touchend', (event) => {\n    eventBan(event)\n    if (!action) return\n    if (action.type === 'move' && !moved) onClick()\n    action = null\n    touchEnd()\n  })\n\n  // mouse\n  addEventListener('mousedown', (event) => {\n    eventBan(event)\n    action = {\n      type: 'move',\n      x: event.clientX,\n      y: event.clientY,\n    }\n    moved = false\n  })\n  addEventListener('mousemove', (event) => {\n    eventBan(event)\n    if (!action) return\n    if (action.type === 'move') {\n      moving({\n        x: event.clientX - action.x,\n        y: event.clientY - action.y,\n      })\n    }\n  })\n  addEventListener('mouseup', (event) => {\n    eventBan(event)\n    if (!action) return\n    if (action.type === 'move' && !moved) onClick()\n    action = null\n    touchEnd()\n    if (!moved) onClick()\n  })\n  addEventListener('wheel', (event) => {\n    eventBan(event)\n    scaling({\n      pageX: event.pageX,\n      pageY: event.pageY,\n      rate: getWheelRate(event),\n    })\n    touchEnd()\n  })\n\n  const dispose = () => {\n    disposes.forEach((dispose) => dispose())\n  }\n\n  return {\n    move: (offset: { x: number; y: number }) => {\n      moving(offset)\n      touchEnd()\n    },\n    scale: (offset: { rate: number }) => {\n      const center = getRectCenter(overlayRect)\n      scaling({\n        ...offset,\n        pageX: center.x,\n        pageY: center.y,\n      })\n      touchEnd()\n    },\n    reset: () => {\n      resetState()\n    },\n    dispose,\n  }\n}\n\nexport function PinchZoomPan({ onClose, children }: PinchZoomPanProps) {\n  const refOverlay = useRef<HTMLDivElement>(null)\n  const refContainer = useRef<HTMLDivElement>(null)\n  const refOnClose = useRef<() => void>()\n  const { addHotkeys } = useHotkeys()\n  useKeyEscape(() => refOnClose.current?.())\n\n  useEffect(() => {\n    refOnClose.current = onClose\n  }, [onClose])\n\n  useEffect(() => {\n    const overlay = refOverlay.current\n    const container = refContainer.current\n    if (!overlay || !container) return\n    const {\n      move,\n      scale,\n      reset,\n      dispose: disposePinch,\n    } = mountPinchZoomPan(overlay, container, () => refOnClose.current?.())\n\n    const up = () => {\n      move({ x: 0, y: -10 })\n    }\n    const down = () => {\n      move({ x: 0, y: 10 })\n    }\n    const left = () => {\n      move({ x: -10, y: 0 })\n    }\n    const right = () => {\n      move({ x: 10, y: 0 })\n    }\n    const zoomIn = () => {\n      scale({ rate: 1.1 })\n    }\n    const zoomOut = () => {\n      scale({ rate: 0.9 })\n    }\n\n    const disposeHotkeys = addHotkeys(\n      [\n        ['k', t('hotkey.pinchUp'), up],\n        ['j', t('hotkey.pinchDown'), down],\n        ['h', t('hotkey.pinchLeft'), left],\n        ['l', t('hotkey.pinchRight'), right],\n        ['ArrowUp', t('hotkey.pinchUp'), up],\n        ['ArrowDown', t('hotkey.pinchDown'), down],\n        ['ArrowLeft', t('hotkey.pinchLeft'), left],\n        ['ArrowRight', t('hotkey.pinchRight'), right],\n        ['=', t('hotkey.pinchZoomIn'), zoomIn],\n        ['-', t('hotkey.pinchZoomOut'), zoomOut],\n        ['Backspace', t('hotkey.pinchReset'), reset],\n      ],\n      {\n        level: 100,\n      },\n    )\n\n    return () => {\n      disposePinch()\n      disposeHotkeys()\n    }\n  }, [addHotkeys])\n\n  useEffect(() => {}, [addHotkeys])\n\n  return (\n    <div\n      ref={refOverlay}\n      className={styles.overlay}\n      onKeyDown={(event) => {\n        if (event.key.toLowerCase() === 'escape') refOnClose.current?.()\n      }}\n    >\n      <div className={styles.container} ref={refContainer}>\n        <div className={styles.center}>{children}</div>\n      </div>\n    </div>\n  )\n}\n","import { Spin, type SpinProps } from 'antd'\n\nexport function SpinFullscreen(props: SpinProps) {\n  return <Spin fullscreen size=\"large\" {...props}></Spin>\n}\n\nexport function SpinCenter(props: SpinProps) {\n  return (\n    <Spin\n      {...props}\n      style={{ width: '100%', padding: 20, ...props.style }}\n    ></Spin>\n  )\n}\n","import { Input } from 'antd'\nimport type { TextAreaProps } from 'antd/es/input/TextArea.js'\nimport { eventBan } from '../../core/util/dom.js'\n\nexport function Textarea({ ...props }: TextAreaProps) {\n  return (\n    <Input.TextArea\n      rows={4}\n      onKeyDown={(e) => {\n        if (e.ctrlKey && e.key === 'Enter') {\n          const elem = e.target as HTMLTextAreaElement\n          eventBan(e)\n          elem.closest('form')?.dispatchEvent(\n            new Event('submit', {\n              bubbles: true,\n              cancelable: true,\n            }),\n          )\n        }\n      }}\n      {...props}\n    ></Input.TextArea>\n  )\n}\n","import { useEffect, useRef } from 'react'\nimport { useHotkeys } from '../hotkey/hotkey-state.js'\nimport { t } from 'i18next'\n\nexport function useKeyEscape(\n  callback: () => void,\n  options: { enable?: boolean; level?: number } = {},\n) {\n  const { enable = true, level = 100 } = options\n  const refCallback = useRef(callback)\n  const { addHotkey } = useHotkeys()\n\n  useEffect(() => {\n    refCallback.current = callback\n  }, [callback])\n\n  useEffect(() => {\n    if (enable) {\n      return addHotkey(\n        'escape',\n        t('hotkey.escape'),\n        () => {\n          refCallback.current()\n        },\n        { level },\n      )\n    }\n  }, [addHotkey, enable, level])\n}\n","import { useMountEffect } from '@react-hookz/web'\n\nexport function useStyle(styleCSS: string) {\n  useMountEffect(() => {\n    const style = document.createElement('style')\n    style.innerHTML = styleCSS\n    const title = document.head.querySelector('title')\n    if (title && title.nextSibling)\n      document.head.insertBefore(style, title.nextSibling)\n    else document.head.prepend(style)\n  })\n}\n","import { useDebouncedState } from '@react-hookz/web'\nimport { useEffect } from 'react'\n\nexport function useSyncedDebounced<T>(\n  value: T,\n  delay: number,\n  maxWait?: number,\n) {\n  const [state, setState] = useDebouncedState(value, delay, maxWait)\n  useEffect(() => {\n    setState(value)\n  }, [setState, value])\n  return state\n}\n","import { atom, useAtom } from 'jotai'\nimport { useCallback, useEffect, useId } from 'react'\n\nexport const defaultTitle = 'Auditory Reader'\n\nconst titleStackAtom = atom<{ id: string; title: string }[]>([])\nconst titleAtom = atom<string | undefined>((get) => {\n  const titleStack = get(titleStackAtom)\n  const titleItem = titleStack.at(0)\n  return titleItem?.title\n})\n\nexport function useTitle() {\n  const [title] = useAtom(titleAtom)\n  return title\n}\n\nexport function TitleProvider() {\n  const title = useTitle()\n  useEffect(() => {\n    document.title = title ? `${title}: ${defaultTitle}` : defaultTitle\n  }, [title])\n  return <></>\n}\n\nexport function usePushTitle() {\n  const id = useId()\n  const [, setTitleStack] = useAtom(titleStackAtom)\n\n  // pop titles\n  useEffect(() => {\n    return () => {\n      setTitleStack((stack) => stack.filter((item) => id !== item.id))\n    }\n  }, [id, setTitleStack])\n\n  // push title\n  const pushTitle = useCallback(\n    (title: string) => {\n      setTitleStack((stack) => [{ title, id }, ...stack])\n    },\n    [id, setTitleStack],\n  )\n\n  return pushTitle\n}\n","import { Modal } from 'antd'\nimport { t } from 'i18next'\nimport { atom, useAtom } from 'jotai'\nimport { useCallback, useEffect, useState } from 'react'\nimport { orderBy } from '../../core/util/collection.js'\nimport { eventBan, isInputElement } from '../../core/util/dom.js'\nimport { capitalize } from '../../core/util/text.js'\nimport { iframeWinAtom } from '../atoms.js'\nimport { useKeyEscape } from '../hooks/use-escape.js'\nimport { globalStore } from '../store/global.js'\nimport styles from './hotkey-state.module.scss'\n\ntype Hotkey =\n  | string\n  | {\n      ctrl?: boolean\n      shift?: boolean\n      alt?: boolean\n      key: string\n    }\n  | Hotkey[]\n\ntype HotkeyCallback = () => void\ntype HotkeyCallbackMap = Map<number, HotkeyCallback>\ntype HotkeyCompiledItem = [\n  key: string,\n  keyDescription: string[],\n  description: string,\n  callback: HotkeyCallbackMap,\n]\ntype HotkeyCompiledItemList = HotkeyCompiledItem[]\nexport type HotkeyItem = [\n  hotkey: Hotkey,\n  description: string,\n  callback: () => void,\n]\nexport type HotkeyOption = {\n  /**\n   * The default value is 1, and the higher the level, the higher the priority.\n   */\n  level?: number\n}\n\nconst sequenceSymbol = ' '\nconst hotkeyItemsAtom = atom<HotkeyCompiledItemList>([])\nlet curKeySeq = ''\nconst seqTimeout = 1000\n\nfunction getHotkeyKey(hotkey: Hotkey): string {\n  if (Array.isArray(hotkey)) {\n    return hotkey.map(getHotkeyKey).join(sequenceSymbol)\n  } else if (typeof hotkey === 'string') {\n    return hotkey.toLowerCase()\n  } else {\n    let s = ''\n    if (hotkey.shift) s += 'shift+'\n    if (hotkey.ctrl) s += 'ctrl+'\n    if (hotkey.alt) s += 'alt+'\n    s += hotkey.key.toLowerCase()\n    return s\n  }\n}\n\nfunction getKeyDesc(key: string): string {\n  let s = ''\n  if (key.length > 1) s += capitalize(key)\n  else if (key === ' ') s += 'Space'\n  else s += key\n  return s\n}\n\nfunction getHotkeyDesc(hotkey: Hotkey): string[] {\n  if (Array.isArray(hotkey)) {\n    return hotkey.map(getHotkeyDesc).flat()\n  } else if (typeof hotkey === 'string') {\n    return [getKeyDesc(hotkey)]\n  } else {\n    let s = ''\n    const hasModifier = hotkey.shift || hotkey.ctrl || hotkey.alt\n    if (hasModifier) s += '<'\n    if (hotkey.shift) s += 'Shift-'\n    if (hotkey.ctrl) s += 'Ctrl-'\n    if (hotkey.alt) s += 'Alt-'\n    s += getKeyDesc(hotkey.key)\n    if (hasModifier) s += '>'\n    return [s]\n  }\n}\n\nexport function useHotkeys() {\n  const addHotkeys = useCallback(\n    (hotkeys: HotkeyItem[], options: HotkeyOption = {}) => {\n      const hotkeyItems = globalStore.get(hotkeyItemsAtom)\n      const updatedItems: { item: HotkeyCompiledItem; level: number }[] = []\n      for (const [hotkey, description, callback] of hotkeys) {\n        const key = getHotkeyKey(hotkey)\n        const keyDescs = getHotkeyDesc(hotkey)\n        const level = options.level ?? 1\n\n        let item = hotkeyItems.find(([k]) => k === key)\n        if (!item) {\n          const callbackMap: HotkeyCallbackMap = new Map([[level, callback]])\n          item = [key, keyDescs, description, callbackMap]\n          hotkeyItems.push(item)\n        } else {\n          if (item[3].has(level))\n            throw new Error(\n              `Hotkey ${JSON.stringify(hotkey)} level: ${level} already exists`,\n            )\n          item[3].set(level, callback)\n        }\n        updatedItems.push({ item, level })\n      }\n      globalStore.set(hotkeyItemsAtom, [...hotkeyItems])\n\n      return function dispose() {\n        const hotkeyItems = globalStore.get(hotkeyItemsAtom)\n        const removeItems: HotkeyCompiledItemList = []\n        for (const { item, level } of updatedItems) {\n          item[3].delete(level)\n          if (!item[3].size) removeItems.push(item)\n        }\n        globalStore.set(\n          hotkeyItemsAtom,\n          hotkeyItems.filter((item) => !removeItems.includes(item)),\n        )\n      }\n    },\n    [],\n  )\n\n  const addHotkey = useCallback(\n    (\n      hotkey: Hotkey,\n      description: string,\n      callback: () => void,\n      options: HotkeyOption = {},\n    ) => {\n      return addHotkeys([[hotkey, description, callback]], options)\n    },\n    [addHotkeys],\n  )\n\n  return { addHotkey, addHotkeys }\n}\n\nlet sequenceTimer: ReturnType<typeof setTimeout> | undefined = undefined\n\nfunction getListener() {\n  return (e: KeyboardEvent) => {\n    if (isInputElement(e.target)) return\n    const hotkeyItems = globalStore.get(hotkeyItemsAtom)\n    const hotkey: Hotkey = {\n      shift: e.shiftKey,\n      ctrl: e.ctrlKey,\n      alt: e.altKey,\n      key: e.key.toLowerCase(),\n    }\n    const triggeredKey = getHotkeyKey(hotkey)\n    // eslint-disable-next-line no-console\n    console.log('triggered-key:', triggeredKey)\n    const fullKey = curKeySeq + triggeredKey\n    const fullSubKey = fullKey + sequenceSymbol\n    const targetRet = hotkeyItems.find(([key]) => key === fullKey)\n    const hasSubRet = hotkeyItems.find(([key]) => key.startsWith(fullSubKey))\n    if (!targetRet && !hasSubRet) return\n    eventBan(e)\n    curKeySeq = ''\n    clearTimeout(sequenceTimer)\n    if (hasSubRet) {\n      curKeySeq = fullSubKey\n      sequenceTimer = setTimeout(() => {\n        curKeySeq = ''\n      }, seqTimeout)\n    } else if (targetRet) {\n      // callback max level hotkey\n      const levels = targetRet[3].keys()\n      const maxLevel = Math.max(...levels)\n      if (maxLevel) targetRet[3].get(maxLevel)?.()\n    }\n  }\n}\n\nfunction useHotkeysRegister() {\n  const [refWin] = useAtom(iframeWinAtom)\n\n  // global\n  useEffect(() => {\n    const listener = getListener()\n    window.addEventListener('keydown', listener, { passive: false })\n    return () => {\n      window.removeEventListener('keydown', listener)\n    }\n  }, [])\n\n  // iframe\n  useEffect(() => {\n    if (!refWin.win) return\n    const listener = getListener()\n    refWin.win.addEventListener('keydown', listener, { passive: false })\n    return () => {\n      refWin.win?.removeEventListener('keydown', listener)\n    }\n  }, [refWin])\n}\n\nexport function HotkeysProvider() {\n  const [open, setOpen] = useState(false)\n  const { addHotkey } = useHotkeys()\n  const [hotkeyItems] = useAtom(hotkeyItemsAtom)\n  useHotkeysRegister()\n\n  useEffect(() => {\n    return addHotkey({ shift: true, key: '?' }, t('hotkey.helper'), () => {\n      setOpen(true)\n    })\n  }, [addHotkey])\n\n  useKeyEscape(\n    () => {\n      setOpen(false)\n    },\n    { enable: open, level: 200 },\n  )\n\n  return (\n    <Modal\n      open={open}\n      width=\"auto\"\n      style={{ maxWidth: '1000px' }}\n      onCancel={() => {\n        setOpen(false)\n      }}\n      title={t('hotkey.title')}\n      footer={false}\n      zIndex={10000}\n    >\n      <ul className={styles.hotkeyList}>\n        {orderBy(hotkeyItems, 'asc', ([key]) => key).map(\n          ([, keyDescs, description], i) => (\n            <li key={i}>\n              <div className=\"keys\">\n                {keyDescs.map((k, j) => (\n                  <kbd key={j}>{k}</kbd>\n                ))}\n              </div>\n              <div className=\"desc\">{description}</div>\n            </li>\n          ),\n        )}\n      </ul>\n    </Modal>\n  )\n}\n","import ReactDOM from 'react-dom/client'\nimport './api.js'\nimport { App } from './app.js'\nimport './locale/i18n.js'\n\nconst root = ReactDOM.createRoot(document.getElementById('root')!)\n\nroot.render(<App></App>)\n","import i18n from 'i18next'\nimport { langEn } from './langs/en.js'\nimport { langZh } from './langs/zh.js'\n\nconst resources = {\n  en: {\n    translation: langEn,\n  },\n  zh: {\n    translation: langZh,\n  },\n}\n\ndeclare module 'i18next' {\n  interface CustomTypeOptions {\n    resources: (typeof resources)['en']\n  }\n}\n\ni18n\n  .init({\n    resources,\n    lng: global.navigator.languages.at(0) ?? 'en',\n  })\n  .catch(console.error)\n","export const langEn = {\n  setting: {\n    title: 'Settings',\n    autoNextSection: 'Auto Next Section',\n    timer: 'Timer (Minute)',\n    personReplace: '中文人称替换',\n    speed: '$t(speed)',\n    userColorScheme: 'Color Scheme',\n    paragraphRepeat: 'Paragraph Repeat',\n    disabledVertical: 'Disable Vertical Direction',\n    pageList: 'Split Page',\n    pageListType: {\n      none: 'None',\n      auto: 'Auto',\n      single: 'Single',\n      double: 'Double',\n    },\n    fontSize: 'Font Size',\n  },\n  hotkey: {\n    title: 'Hotkeys',\n    escape: 'Quit / Cancel',\n    ok: 'Ok',\n    speedUp: 'Increase speed',\n    speedDown: 'Decrease speed',\n    fontSizeUp: 'Increase font size',\n    fontSizeDown: 'Decrease font size',\n    reload: 'Reload',\n    helper: 'Show the hotkeys',\n    speakBookName: 'Speak selected book name',\n    playToggle: 'Play / Pause',\n    navToggle: 'Toggle table contents panel',\n    prevNav: 'Select previous nav',\n    nextNav: 'Select next nav',\n    gotoNav: 'Go to selected nav',\n    speakNav: 'Speak selected nav',\n    annotationsPanelToggle: 'Toggle annotations panel',\n    annotationToggle: 'Add / Remove annotation for current paragraph',\n    annotationNote: 'Note current annotation',\n    annotationRemoveSelected: 'Remove selected annotation',\n    prevAnnotation: 'Select previous annotation',\n    nextAnnotation: 'Select next annotation',\n    gotoAnnotation: 'Go to selected annotation',\n    speakAnnotation: 'Speak selected annotation',\n    keywordPanelToggle: 'Toggle keywords panel',\n    keywordAdd: 'Add current selected keyword',\n    keywordNote: 'Note current keyword',\n    keywordRemoveSelected: 'Remove selected keyword',\n    prevKeyword: 'Select previous keyword',\n    nextKeyword: 'Select next keyword',\n    gotoKeyword: 'Go to selected keyword',\n    speakKeyword: 'Speak selected keyword',\n    goBack: 'Go back books index',\n    prevSection: 'Go to previous book section',\n    nextSection: 'Go to next book section',\n    firstPage: 'Scroll to first book page',\n    lastPage: 'Scroll to last book page',\n    jumpPrevPage: 'Go to previous book page',\n    jumpNextPage: 'Go to next book page',\n    prevPage: 'Scroll to previous book page',\n    nextPage: 'Scroll to next book page',\n    firstParagraph: 'Go to first paragraph',\n    lastParagraph: 'Go to last paragraph',\n    prevParagraph: 'Go to previous paragraph',\n    nextParagraph: 'Go to next paragraph',\n    prevSearchResult: 'Go to previous search result',\n    nextSearchResult: 'Go to next search result',\n    gotoSearchResult: 'Go to selected search result',\n    goPrev: 'Go to previous',\n    goNext: 'Go to next',\n    goTop: 'Go to the top',\n    goBottom: 'Move selection to bottom',\n    goPagePrev: 'Go to previous page',\n    goPageNext: 'Go to next page',\n    goPageFirst: 'Go to first page',\n    goPageLast: 'Go to last page',\n    goMovePrev: 'Move selection to previous',\n    goMoveNext: 'Move selection to next',\n    goMoveTop: 'Move selection to top',\n    listArchive: 'Toggle display of list archived books',\n    listFavorite: 'Toggle display of list favorited books',\n    archive: 'Toggle archive',\n    favorite: 'Toggle favorite',\n    search: 'Focus to search input',\n    sortOrder: 'Select sort order',\n    edit: 'Edit current selection',\n    select: 'Toggle select',\n    selectShift: 'Mark from last select to current as selected',\n    selectAll: 'Toggle select all',\n    open: 'Open current selection',\n    editBook: 'Edit book',\n    remove: 'Remove current selection',\n    pinchUp: 'Move up',\n    pinchDown: 'Move down',\n    pinchLeft: 'Move left',\n    pinchRight: 'Move right',\n    pinchZoomOut: 'Zoom out',\n    pinchZoomIn: 'Zoom in',\n    pinchReset: 'Reset zoom',\n  },\n  confirm: {\n    ok: 'Ok',\n    cancel: 'Cancel',\n    openLink: '$t(open) $t(link)?',\n  },\n  desc: {\n    bookAddedSuccessful: 'Successfully added a new book',\n    annotationUpdated: 'Updated a $t(annotation)',\n    annotationDeleted: 'Deleted a $t(annotation)',\n    annotationNoSupported: 'No support $t(annotation) type',\n    annotationsEmpty: '$t(annotation)s empty',\n    keywordUpdated: 'Updated a $t(keyword)',\n    keywordDeleted: 'Deleted a $t(keyword)',\n    keywordNoSupported: 'No support $t(keyword) type',\n    keywordsEmpty: '$t(keywords) empty',\n    navEmpty: '$t(nav) empty',\n  },\n  prompt: {\n    inputBookName: 'Please input $t(bookName).',\n    selectLanguage: 'Please select the $t(language).',\n    inputAccount: 'Please input your $t(account).',\n    inputPassword: 'Please input your $t(password).',\n    dropHere: 'drop .epub file、.txt file、text or URL to here.',\n    dropHereToRemove: 'Drop here to remove it.',\n    annotationRemoveConfirm: 'Remove this $t(annotation) with $t(note)?',\n    keywordRemoveConfirm: 'Remove this $t(keyword) with $t(note)?',\n    uploadBook: 'Support .epub and .txt.',\n    noBooks: 'No books here, Add your first book.',\n    noSearchMatches: 'No search matches',\n  },\n  sortOrder: {\n    label: 'Sort order',\n    item: {\n      default: 'Default',\n      reverse: 'Reverse',\n      name: 'Name',\n      nameReverse: 'Name reverse',\n    },\n  },\n  error: {\n    login: '$t(account) or $t(password) error',\n  },\n  title: 'Title',\n  note: 'Note',\n  speed: 'Speed',\n  fontSize: 'Font Size',\n  view: 'View',\n  account: 'Account',\n  password: 'Password',\n  login: 'Login',\n  logout: 'Logout',\n  submit: 'Submit',\n  select: 'Select',\n  add: 'Add',\n  tmpStore: 'Store temporary file',\n  top: 'Top',\n  edit: 'Edit',\n  editBook: 'Edit book',\n  remove: 'Remove',\n  update: 'Update',\n  export: 'Export',\n  bookName: 'Book name',\n  favorite: 'Favorite',\n  archive: 'Archive',\n  unarchive: 'Unarchive',\n  search: 'Search',\n  cover: 'Cover',\n  nav: 'Table contents',\n  annotation: 'Annotation',\n  keyword: 'Keyword',\n  alias: 'Alias',\n  open: 'open',\n  url: 'URL',\n  extractUrlInfo: 'Extract URL info',\n  bookContent: 'Book content',\n  language: 'Language',\n  empty: 'Empty',\n  file: 'File',\n  text: 'Text',\n  system: 'System',\n  dark: 'Dark',\n  light: 'Light',\n  cancel: 'Cancel',\n  all: 'All',\n}\n\nexport type LangEn = typeof langEn\n","import type { LangEn } from './en.js'\n\nexport const langZh: LangEn = {\n  setting: {\n    title: '设置',\n    autoNextSection: '自动下一章节',\n    timer: '计时器 (分钟)',\n    personReplace: '中文人称替换',\n    speed: '$t(speed)',\n    userColorScheme: '颜色主题',\n    paragraphRepeat: '段落重复',\n    disabledVertical: '禁用垂直方向',\n    pageList: '分页',\n    pageListType: {\n      none: '无',\n      auto: '自动',\n      single: '单页',\n      double: '双页',\n    },\n    fontSize: '字体大小',\n  },\n  hotkey: {\n    title: '快捷键',\n    escape: '退出 / 取消',\n    ok: '确定',\n    speedUp: '提高速度',\n    speedDown: '降低速度',\n    fontSizeUp: '提高字体大小',\n    fontSizeDown: '降低字体大小',\n    reload: '刷新页面',\n    helper: '显示快捷键',\n    speakBookName: '朗读选择的书名',\n    playToggle: '播放 / 暂停',\n    navToggle: '开关显示导航',\n    prevNav: '选择上一个导航',\n    nextNav: '选择下一个导航',\n    gotoNav: '跳转到选择的导航',\n    speakNav: '朗读选择的导航',\n    annotationsPanelToggle: '开关显示注解',\n    annotationToggle: '添加或删除当前段落的注解',\n    annotationNote: '添加当前段落的注解的备注',\n    annotationRemoveSelected: '删除选择的注解',\n    prevAnnotation: '选择上一个注解',\n    nextAnnotation: '选择下一个注解',\n    gotoAnnotation: '跳转到选择的注解',\n    speakAnnotation: '朗读选择的注解',\n    keywordPanelToggle: '开关显示关键字',\n    keywordAdd: '添加当前选择关键字',\n    keywordNote: '添加当前关键字的备注',\n    keywordRemoveSelected: '删除选择的关键字',\n    prevKeyword: '选择上一个关键字',\n    nextKeyword: '选择下一个关键字',\n    gotoKeyword: '跳转到选择的关键字',\n    speakKeyword: '朗读选择的关键字',\n    goBack: '回到书本目录',\n    prevSection: '跳到本书上一部份',\n    nextSection: '跳到本书下一部份',\n    firstPage: '滚动到本书第一页',\n    lastPage: '滚动到本书最后一页',\n    jumpPrevPage: '跳到本书上一页面',\n    jumpNextPage: '跳到本书下一页面',\n    prevPage: '滚动到本书上一页面',\n    nextPage: '滚动到本书下一页面',\n    firstParagraph: '跳到本书第一段落',\n    lastParagraph: '跳到本书最后一段落',\n    prevParagraph: '跳到本书上一段落',\n    nextParagraph: '跳到本书下一段落',\n    prevSearchResult: '选择上一个搜索结果',\n    nextSearchResult: '选择下一个搜索结果',\n    gotoSearchResult: '跳转到选择的搜索结果',\n    goPrev: '去到上一个',\n    goNext: '去到下一个',\n    goTop: '去到顶部',\n    goBottom: '去到底部',\n    goPagePrev: '去到上一页面',\n    goPageNext: '去到下一页面',\n    goPageFirst: '去到第一页',\n    goPageLast: '去到最后一页',\n    goMovePrev: '挪到上一个',\n    goMoveNext: '挪到下一个',\n    goMoveTop: '挪到顶部',\n    listArchive: '开关显示存档列表',\n    listFavorite: '开关显示喜欢列表',\n    archive: '开关存档',\n    favorite: '开关喜欢',\n    search: '聚焦到搜索输入框',\n    sortOrder: '选择排序',\n    edit: '编辑当前选择',\n    select: '开关选择',\n    selectShift: '把最后一次选择至当位置的标记为选择',\n    selectAll: '开关选择全部',\n    open: '打开当前选择',\n    editBook: '编辑本书',\n    remove: '删除当前选择',\n    pinchUp: '上移',\n    pinchDown: '下移',\n    pinchLeft: '左移',\n    pinchRight: '右移',\n    pinchZoomOut: '缩小',\n    pinchZoomIn: '放大',\n    pinchReset: '重置',\n  },\n  confirm: {\n    ok: '确定',\n    cancel: '取消',\n    openLink: '$t(open)$t(link)?',\n  },\n  desc: {\n    bookAddedSuccessful: '成功添加了一本新书',\n    annotationUpdated: '更新了一个$t(annotation)',\n    annotationDeleted: '删除了一个$t(annotation)',\n    annotationNoSupported: '不支持的$t(annotation)类型',\n    annotationsEmpty: '$t(annotation)为空',\n    keywordUpdated: '更新了一个$t(keyword)',\n    keywordDeleted: '删除了一个$t(keyword)',\n    keywordNoSupported: 'No support $t(keyword) type',\n    keywordsEmpty: '$t(keyword)为空',\n    navEmpty: '$t(nav)为空',\n  },\n  prompt: {\n    inputBookName: '请输入$t(bookName)',\n    selectLanguage: '请选择$t(language)',\n    inputAccount: '请输入$t(account)',\n    inputPassword: '请输入$t(password)',\n    dropHere: '拖动 .epub 文件、.txt 文件、文本或 URL 到这里。',\n    dropHereToRemove: '拖放到这里删除。',\n    annotationRemoveConfirm: '删除此$t(annotation)和$t(note)吗?',\n    keywordRemoveConfirm: '删除此$t(keyword)吗?',\n    uploadBook: '支持 .epub 和 .txt',\n    noBooks: '这里没有书籍，添加你的第一本书吧。',\n    noSearchMatches: '没有找到匹配项',\n  },\n  sortOrder: {\n    label: '排序',\n    item: {\n      default: '默认',\n      reverse: '反序',\n      name: '名称',\n      nameReverse: '名称反序',\n    },\n  },\n  error: {\n    login: '$t(account)或$t(password)错误',\n  },\n  title: '标题',\n  note: '备注',\n  speed: '速度',\n  fontSize: '字体大小',\n  view: '浏览',\n  account: '帐号',\n  password: '密码',\n  login: '登录',\n  logout: '登出',\n  submit: '提交',\n  select: '选择',\n  add: '添加',\n  tmpStore: '存储临时文件',\n  top: '置顶',\n  edit: '编辑',\n  editBook: '编辑本书',\n  remove: '删除',\n  update: '更新',\n  export: '导出',\n  bookName: '书名',\n  favorite: '喜欢',\n  archive: '存档',\n  unarchive: '取消存档',\n  search: '搜索',\n  cover: '封面',\n  nav: '导航',\n  annotation: '注解',\n  keyword: '关键词',\n  alias: '别名',\n  open: '打开',\n  url: 'URL',\n  extractUrlInfo: '提取URL信息',\n  bookContent: '文本内容',\n  language: '语言',\n  empty: '空',\n  file: '文件',\n  text: '文本',\n  system: '系统',\n  dark: '暗色',\n  light: '亮色',\n  cancel: '取消',\n  all: '全部',\n}\n","import { faEye } from '@fortawesome/free-solid-svg-icons'\nimport { Alert, Button } from 'antd'\nimport { t } from 'i18next'\nimport { useParams } from 'react-router-dom'\nimport { FlexBox } from '../../components/flex-box.js'\nimport { Icon } from '../../components/icon.js'\nimport { LinkWrap } from '../../components/link-wrap.js'\nimport { NotFound } from '../not-found.js'\n\nexport function BookAddSuccessful() {\n  const { uuid } = useParams<{ uuid: string }>()\n\n  if (!uuid) return <NotFound title=\"book\"></NotFound>\n\n  return (\n    <FlexBox gap={4}>\n      <Alert type=\"success\" message={t('desc.bookAddedSuccessful')}></Alert>\n      <LinkWrap to={`/books/view/${uuid}`}>\n        {(href) => (\n          <Button type=\"primary\" href={href} icon={<Icon icon={faEye} />}>\n            {t('view')}\n          </Button>\n        )}\n      </LinkWrap>\n    </FlexBox>\n  )\n}\n","import { t } from 'i18next'\nimport { useState } from 'react'\nimport { AddFile } from './add/file.js'\nimport { AddText } from './add/text.js'\nimport { AddUrl } from './add/url.js'\nimport { Tabs } from 'antd'\n\ntype TabType = 'text' | 'file' | 'url'\n\nexport function BookAdd() {\n  const [tab, setTab] = useState<TabType>('text')\n  return (\n    <Tabs\n      defaultActiveKey={tab}\n      onChange={(k) => setTab(k as TabType)}\n      destroyInactiveTabPane\n      items={[\n        {\n          key: 'text',\n          label: t('text'),\n          children: <AddText />,\n        },\n        {\n          key: 'file',\n          label: t('file'),\n          children: <AddFile />,\n        },\n        {\n          key: 'url',\n          label: t('url'),\n          children: <AddUrl />,\n        },\n      ]}\n    ></Tabs>\n  )\n}\n","import { Button, Form, Input } from 'antd'\nimport { t } from 'i18next'\nimport path from '@file-services/path'\nimport { useEffect, useState } from 'react'\nimport { useNavigate } from 'react-router-dom'\nimport { booksCreateRouter } from '../../../../core/api/books/create.js'\nimport { BookEpub } from '../../../../core/book/book-epub.js'\nimport { parseLangCode, type LangCode } from '../../../../core/lang.js'\nimport { arrayBufferToBase64 } from '../../../../core/util/converter.js'\nimport { async } from '../../../../core/util/promise.js'\nimport { FileInput } from '../../../components/file-input.js'\nimport { LanguageSelect } from '../../../components/language-select.js'\n\ntype Values = {\n  name: string\n  langCode: LangCode\n  file: File\n}\n\nexport function AddFile() {\n  const nav = useNavigate()\n  const [submitted, setSubmitted] = useState(false)\n  const [form] = Form.useForm<Values>()\n  const file = Form.useWatch('file', form)\n\n  useEffect(() => {\n    async(async () => {\n      if (file.name.endsWith('.epub')) {\n        const buf = await file.arrayBuffer()\n        const epub = await BookEpub.read(buf)\n        if (!epub) return\n        const ext = path.extname(file.name)\n        const basename = path.basename(file.name, ext)\n        form.setFieldValue('name', epub.title ?? basename)\n        const langCode = parseLangCode(epub.language)\n        if (langCode) {\n          form.setFieldValue('langCode', langCode)\n        }\n      }\n    })\n  }, [file, form])\n\n  return (\n    <Form<Values>\n      form={form}\n      style={{\n        margin: '20px auto 0',\n        maxWidth: '800px',\n      }}\n      initialValues={{\n        name: '',\n        langCode: null,\n        file: null,\n      }}\n      onFinish={(values) => {\n        async(async () => {\n          try {\n            setSubmitted(true)\n            if (values.file.name.endsWith('.epub')) {\n              const buf = await values.file.arrayBuffer()\n              const fileBase64 = arrayBufferToBase64(buf)\n              const entity = await booksCreateRouter.action({\n                name: values.name,\n                langCode: values.langCode,\n                bufferBase64: fileBase64,\n                type: 'epub',\n              })\n              nav(`/books/added-successful/${entity.uuid}`)\n            } else if (values.file.name.endsWith('.txt')) {\n              const buf = await values.file.arrayBuffer()\n              const fileBase64 = arrayBufferToBase64(buf)\n              const entity = await booksCreateRouter.action({\n                name: values.name,\n                langCode: values.langCode,\n                bufferBase64: fileBase64,\n                type: 'text',\n              })\n              nav(`/books/added-successful/${entity.uuid}`)\n            }\n          } finally {\n            setSubmitted(false)\n          }\n        })\n      }}\n    >\n      <Form.Item label={t('bookName')} name=\"name\" rules={[{ required: true }]}>\n        <Input placeholder={t('prompt.inputBookName')}></Input>\n      </Form.Item>\n      <Form.Item\n        label={t('language')}\n        name=\"langCode\"\n        rules={[{ required: true }]}\n      >\n        <LanguageSelect />\n      </Form.Item>\n      <Form.Item label={t('file')} name=\"file\" rules={[{ required: true }]}>\n        <FileInput\n          onChange={(files) => {\n            const file = files.at(0)\n            if (!file) return\n            async(async () => {})\n          }}\n          prompt={t('prompt.uploadBook')}\n        ></FileInput>\n      </Form.Item>\n      <Form.Item>\n        <Button block type=\"primary\" htmlType=\"submit\" loading={submitted}>\n          {t('add')}\n        </Button>\n      </Form.Item>\n    </Form>\n  )\n}\n","import { Button, Form, Input } from 'antd'\nimport { t } from 'i18next'\nimport { useEffect, useState } from 'react'\nimport { useNavigate } from 'react-router-dom'\nimport { booksCreateRouter } from '../../../../core/api/books/create.js'\nimport { type LangCode } from '../../../../core/lang.js'\nimport { arrayBufferToBase64 } from '../../../../core/util/converter.js'\nimport { async } from '../../../../core/util/promise.js'\nimport { splitLines } from '../../../../core/util/text.js'\nimport { LanguageSelect } from '../../../components/language-select.js'\nimport { Textarea } from '../../../components/textarea.js'\n\ntype Values = {\n  name: string\n  langCode: LangCode\n  content: string\n}\n\nexport function AddText() {\n  const nav = useNavigate()\n  const [submitted, setSubmitted] = useState(false)\n  const [form] = Form.useForm<Values>()\n  const content = Form.useWatch('content', form)\n\n  useEffect(() => {\n    if (!content) return\n    const name = form.getFieldValue('name')\n    if (!name) {\n      const lines = splitLines(content)\n      const newName = lines.find((line) => !!line.trim())\n      if (newName) form.setFieldValue('name', newName)\n    }\n  }, [content, form])\n\n  return (\n    <Form<Values>\n      form={form}\n      style={{\n        margin: '20px auto 0',\n        maxWidth: '800px',\n      }}\n      initialValues={{\n        name: '',\n        langCode: null,\n        content: '',\n      }}\n      onFinish={(values) => {\n        async(async () => {\n          try {\n            setSubmitted(true)\n            const buf = new TextEncoder().encode(values.content)\n            const fileBase64 = arrayBufferToBase64(buf)\n            const entity = await booksCreateRouter.action({\n              name: values.name,\n              langCode: values.langCode,\n              bufferBase64: fileBase64,\n              type: 'text',\n            })\n            nav(`/books/added-successful/${entity.uuid}`)\n          } finally {\n            setSubmitted(false)\n          }\n        })\n      }}\n    >\n      <Form.Item label={t('bookName')} name=\"name\" rules={[{ required: true }]}>\n        <Input placeholder={t('prompt.inputBookName')}></Input>\n      </Form.Item>\n      <Form.Item\n        label={t('language')}\n        name=\"langCode\"\n        rules={[{ required: true }]}\n      >\n        <LanguageSelect />\n      </Form.Item>\n      <Form.Item\n        label={t('bookContent')}\n        name=\"content\"\n        rules={[{ required: true }]}\n      >\n        <Textarea rows={6}></Textarea>\n      </Form.Item>\n      <Form.Item>\n        <Button block htmlType=\"submit\" type=\"primary\" loading={submitted}>\n          {t('add')}\n        </Button>\n      </Form.Item>\n    </Form>\n  )\n}\n","import { Button, Form, Input, Space } from 'antd'\nimport { t } from 'i18next'\nimport { useState } from 'react'\nimport { useNavigate } from 'react-router-dom'\nimport { booksCreateByUrlRouter } from '../../../../core/api/books/create-by-url.js'\nimport { booksFetchUrlInfoRouter } from '../../../../core/api/books/fetch-url-info.js'\nimport { type LangCode } from '../../../../core/lang.js'\nimport { async } from '../../../../core/util/promise.js'\nimport { LanguageSelect } from '../../../components/language-select.js'\n\ntype Values = {\n  name: string\n  langCode: LangCode\n  url: string\n}\n\nexport function AddUrl() {\n  const nav = useNavigate()\n  const [isFetchingURL, setIsFetchingURL] = useState(false)\n  const [submitted, setSubmitted] = useState(false)\n  const [form] = Form.useForm<Values>()\n\n  return (\n    <>\n      <Form\n        form={form}\n        style={{\n          margin: '20px auto 0',\n          maxWidth: '800px',\n        }}\n        initialValues={{\n          name: '',\n          langCode: null,\n          url: '',\n        }}\n        onFinish={(values) => {\n          async(async () => {\n            try {\n              setSubmitted(true)\n              const entity = await booksCreateByUrlRouter.action({\n                name: values.name,\n                langCode: values.langCode,\n                url: values.url,\n              })\n              nav(`/books/added-successful/${entity.uuid}`)\n            } finally {\n              setSubmitted(false)\n            }\n          })\n        }}\n      >\n        <Form.Item\n          label={t('bookName')}\n          name=\"name\"\n          rules={[{ required: true }]}\n        >\n          <Input placeholder={t('prompt.inputBookName')}></Input>\n        </Form.Item>\n        <Form.Item\n          label={t('language')}\n          name=\"langCode\"\n          rules={[{ required: true }]}\n        >\n          <LanguageSelect />\n        </Form.Item>\n        <Form.Item label={t('url')} name=\"url\" rules={[{ required: true }]}>\n          <Space.Compact style={{ width: '100%' }}>\n            <Input></Input>\n            <Button\n              style={{ alignSelf: 'center' }}\n              type=\"primary\"\n              loading={isFetchingURL}\n              onClick={() => {\n                const url = form.getFieldValue('url')\n                if (!url) return\n                setIsFetchingURL(true)\n                booksFetchUrlInfoRouter\n                  .action({ url })\n                  .then((info) => {\n                    form.setFieldValue('name', info.title)\n                    if (info.lang) form.setFieldValue('langCode', info.lang)\n                  })\n                  .catch(console.error)\n                  .finally(() => setIsFetchingURL(false))\n              }}\n            >\n              {t('extractUrlInfo')}\n            </Button>\n          </Space.Compact>\n        </Form.Item>\n        <Form.Item>\n          <Button block htmlType=\"submit\" type=\"primary\" loading={submitted}>\n            {t('add')}\n          </Button>\n        </Form.Item>\n      </Form>\n    </>\n  )\n}\n","import { useSyncedRef } from '@react-hookz/web'\nimport { Button, Form, Input, Modal } from 'antd'\nimport { t } from 'i18next'\nimport { atom, useAtom } from 'jotai'\nimport { useCallback, useEffect } from 'react'\nimport { booksShowRouter } from '../../../core/api/books/show.js'\nimport { booksUpdateRouter } from '../../../core/api/books/update.js'\nimport type { BookTypes } from '../../../core/book/types.js'\nimport { type LangCode } from '../../../core/lang.js'\nimport { useAction } from '../../../core/route/action.js'\nimport { async } from '../../../core/util/promise.js'\nimport { LanguageSelect } from '../../components/language-select.js'\nimport { SpinCenter } from '../../components/spin.js'\n\ntype Values = {\n  name: string\n  langCode: LangCode\n}\n\nfunction UpdateForm({\n  book,\n  reload,\n}: {\n  book: BookTypes.Entity\n  reload: () => void\n}) {\n  const [form] = Form.useForm<Values>()\n\n  return (\n    <Form\n      form={form}\n      initialValues={{\n        name: book.name,\n        langCode: book.langCode,\n      }}\n      onFinish={(values) => {\n        async(async () => {\n          await booksUpdateRouter.action({\n            uuid: book.uuid,\n            update: {\n              name: values.name,\n              langCode: values.langCode,\n            },\n          })\n          reload()\n        })\n      }}\n    >\n      <Form.Item label={t('bookName')} name=\"name\" rules={[{ required: true }]}>\n        <Input autoFocus placeholder={t('prompt.inputBookName')}></Input>\n      </Form.Item>\n      <Form.Item\n        label={t('language')}\n        name=\"langCode\"\n        rules={[{ required: true }]}\n      >\n        <LanguageSelect />\n      </Form.Item>\n      <Form.Item>\n        <Button block htmlType=\"submit\" type=\"primary\">\n          {t('update')}\n        </Button>\n      </Form.Item>\n    </Form>\n  )\n}\n\nfunction BookEditReq({ uuid, reload }: { uuid: string; reload: () => void }) {\n  const { data: bookItem } = useAction(booksShowRouter, { uuid })\n\n  if (!bookItem) return <SpinCenter></SpinCenter>\n\n  return <UpdateForm book={bookItem} reload={reload}></UpdateForm>\n}\n\nconst bookEditDialogAtom = atom<{\n  uuid: string | null\n  reloads: (() => void)[]\n}>({ uuid: null, reloads: [] })\n\nexport function useBookEditDialog(reload: () => void) {\n  const reloadRef = useSyncedRef(reload)\n  const [, setBookEditDialog] = useAtom(bookEditDialogAtom)\n\n  const openBookEdit = useCallback(\n    (uuid: string) => {\n      setBookEditDialog((s) => ({ ...s, uuid }))\n    },\n    [setBookEditDialog],\n  )\n\n  useEffect(() => {\n    const reloadHook = () => {\n      reloadRef.current()\n    }\n    setBookEditDialog((s) => ({ ...s, reloads: [...s.reloads, reloadHook] }))\n    return () => {\n      setBookEditDialog((s) => ({\n        ...s,\n        reloads: s.reloads.filter((r) => r !== reloadHook),\n      }))\n    }\n  }, [reloadRef, setBookEditDialog])\n\n  return { openBookEdit }\n}\n\nexport function BookEditDialog() {\n  const [bookEditDialog, setBookEditDialog] = useAtom(bookEditDialogAtom)\n  const onClose = useCallback(() => {\n    setBookEditDialog((s) => ({ ...s, uuid: null }))\n  }, [setBookEditDialog])\n\n  return (\n    <Modal\n      open={!!bookEditDialog.uuid}\n      onCancel={onClose}\n      title={t('editBook')}\n      footer={false}\n    >\n      {bookEditDialog.uuid && (\n        <BookEditReq\n          uuid={bookEditDialog.uuid}\n          reload={() => {\n            onClose()\n            bookEditDialog.reloads.forEach((r) => r())\n          }}\n        ></BookEditReq>\n      )}\n    </Modal>\n  )\n}\n","import { Route, Routes } from 'react-router-dom'\nimport { NotFound } from '../not-found.js'\nimport { BookAddSuccessful } from './add-successful.js'\nimport { BookAdd } from './add.js'\nimport { BookEditDialog } from './edit.js'\nimport { BookList } from './index.js'\nimport { BookView } from './view.js'\n\nexport function BooksEntry() {\n  return (\n    <>\n      <BookEditDialog></BookEditDialog>\n      <Routes>\n        <Route path=\"/\" element={<BookList></BookList>}></Route>\n        <Route path=\"/add\" element={<BookAdd></BookAdd>}></Route>\n        <Route\n          path=\"/added-successful/:uuid\"\n          element={<BookAddSuccessful></BookAddSuccessful>}\n        ></Route>\n        <Route path=\"/view/:uuid\" element={<BookView></BookView>}></Route>\n        <Route path=\"*\" element={<NotFound title=\"page\"></NotFound>}></Route>\n      </Routes>\n    </>\n  )\n}\n","import { atom, useAtom } from 'jotai'\nimport type { SortOrder } from '../../../core/book/enums.js'\nimport { useCallback, type SetStateAction } from 'react'\n\nconst pageAtom = atom(1)\n\nexport const perPageAtom = atom(15)\nexport const activatedIndexAtom = atom(0)\nexport const archivedAtom = atom(false)\nexport const favoritedAtom = atom(false)\nexport const searchAtom = atom('')\nexport const orderAtom = atom<SortOrder>('default')\n\nexport const usePage = () => {\n  const [page, setPage] = useAtom(pageAtom)\n  const [, setActivatedIndex] = useAtom(activatedIndexAtom)\n  const goPage = useCallback(\n    (action: SetStateAction<number>) => {\n      setActivatedIndex(0)\n      setPage(action)\n    },\n    [setActivatedIndex, setPage],\n  )\n  return [page, goPage] as const\n}\n","import { faStar as faStarRegular } from '@fortawesome/free-regular-svg-icons'\nimport {\n  faAdd,\n  faEllipsisVertical,\n  faGripVertical,\n  faStar,\n  faTrash,\n} from '@fortawesome/free-solid-svg-icons'\nimport {\n  Alert,\n  Button,\n  Checkbox,\n  Dropdown,\n  Form,\n  Input,\n  Pagination,\n  Select,\n  Space,\n  Switch,\n  Tag,\n  type InputRef,\n} from 'antd'\nimport { t } from 'i18next'\nimport { useAtom } from 'jotai'\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport { useDrag, useDrop } from 'react-dnd'\nimport { useNavigate } from 'react-router-dom'\nimport { getBooksCoverPath } from '../../../core/api/books/cover.js'\nimport { booksDownloadRouter } from '../../../core/api/books/download.js'\nimport { booksMoveAfterRouter } from '../../../core/api/books/move-after.js'\nimport { booksMoveTopRouter } from '../../../core/api/books/move-top.js'\nimport type { BookPage } from '../../../core/api/books/page.js'\nimport { booksPageRouter } from '../../../core/api/books/page.js'\nimport { booksRemoveRouter } from '../../../core/api/books/remove.js'\nimport { booksUpdateRouter } from '../../../core/api/books/update.js'\nimport { sortOrders } from '../../../core/book/enums.js'\nimport type { BookTypes } from '../../../core/book/types.js'\nimport { useAction } from '../../../core/route/action.js'\nimport { filterOptionLabel } from '../../../core/util/antd.js'\nimport { async } from '../../../core/util/promise.js'\nimport { Speech } from '../../../core/util/speech.js'\nimport { uiConfirm } from '../../common/confirm.js'\nimport { previewImgSrcAtom } from '../../common/preview-image.js'\nimport { Icon } from '../../components/icon.js'\nimport { LinkWrap } from '../../components/link-wrap.js'\nimport { SpinCenter } from '../../components/spin.js'\nimport { useSyncedDebounced } from '../../hooks/use-synced-debounce.js'\nimport { useHotkeys, type HotkeyItem } from '../../hotkey/hotkey-state.js'\nimport { useGetVoice, usePersonReplace, useSpeechSpeed } from '../../store.js'\nimport { globalStore } from '../../store/global.js'\nimport { useAppBarSync } from '../layout/use-app-bar.js'\nimport {\n  activatedIndexAtom,\n  archivedAtom,\n  favoritedAtom,\n  orderAtom,\n  perPageAtom,\n  searchAtom,\n  usePage,\n} from './index-atoms.js'\nimport { useBookEditDialog } from './edit.js'\nimport styles from './index.module.scss'\n\nconst DragType = 'book'\n\ntype DragItem = {\n  name: string\n  uuid: string\n  startIndex: number\n  hoverIndex: number\n}\n\nfunction viewPath(uuid: string) {\n  return `/books/view/${uuid}`\n}\n\nconst moveOffset = async (\n  books: BookTypes.Entity[],\n  currentIndex: number,\n  offset: number,\n) => {\n  if (offset === 0) return\n  const currentEntity = books.at(currentIndex)\n  if (!currentEntity) return\n  const uuid = currentEntity.uuid\n  const targetIndex = currentIndex + offset\n  if (targetIndex <= 0) return await booksMoveTopRouter.action({ uuid })\n  const afterIndex = targetIndex < currentIndex ? targetIndex - 1 : targetIndex\n  const afterBook = books.at(afterIndex)\n  if (!afterBook) return\n  await booksMoveAfterRouter.action({\n    uuid,\n    afterUuid: afterBook.uuid,\n  })\n}\n\nfunction useRemoveBooks(reload: () => void) {\n  const removeBooks = useCallback(\n    (books: BookTypes.Entity[]) => {\n      async(async () => {\n        if (\n          await uiConfirm({\n            title: t('remove'),\n            description: (\n              <ul>\n                {books.map((book) => (\n                  <li key={book.uuid}>{book.name}</li>\n                ))}\n              </ul>\n            ),\n          })\n        ) {\n          for (const book of books) {\n            await booksRemoveRouter.action({\n              uuid: book.uuid,\n            })\n          }\n          reload()\n        }\n      })\n    },\n    [reload],\n  )\n\n  return removeBooks\n}\n\nfunction useSelector(books: BookTypes.Entity[] | null) {\n  const [lastSelectedIndex, setLastSelectedIndex] = useState<number>()\n  const [selectedUuids, setSelectedUuids] = useState<string[]>([])\n\n  const selectedBooks = useMemo(\n    () => books?.filter((book) => selectedUuids.includes(book.uuid)) ?? [],\n    [books, selectedUuids],\n  )\n\n  const allSelected = useMemo(\n    () => books?.every((book) => selectedUuids.includes(book.uuid)),\n    [books, selectedUuids],\n  )\n\n  // if books reload, cancel selected\n  useEffect(() => {\n    if (books) setSelectedUuids([])\n  }, [books])\n\n  const selectTo = useCallback(\n    (index: number, shift: boolean) => {\n      const book = books?.[index]\n      if (!book) return\n      setLastSelectedIndex(index)\n      let checked = false\n      let targetUuids: string[]\n      if (\n        lastSelectedIndex !== undefined &&\n        lastSelectedIndex !== index &&\n        shift\n      ) {\n        if (lastSelectedIndex < index)\n          targetUuids = books\n            .slice(lastSelectedIndex, index + 1)\n            .map((it) => it.uuid)\n        else\n          targetUuids = books\n            .slice(index, lastSelectedIndex + 1)\n            .map((it) => it.uuid)\n        checked = true\n      } else {\n        targetUuids = [book.uuid]\n        checked = !selectedUuids.includes(book.uuid)\n      }\n\n      let tmpUuids = [...selectedUuids]\n      for (const targetUuid of targetUuids) {\n        if (checked) {\n          if (!tmpUuids.includes(targetUuid))\n            tmpUuids = [...tmpUuids, targetUuid]\n        } else {\n          tmpUuids = tmpUuids.filter((uuid) => uuid !== targetUuid)\n        }\n        setSelectedUuids(tmpUuids)\n      }\n    },\n    [books, lastSelectedIndex, selectedUuids],\n  )\n\n  const selectAll = useCallback(() => {\n    if (allSelected) setSelectedUuids([])\n    else setSelectedUuids(books?.map((book) => book.uuid) ?? [])\n  }, [allSelected, books])\n\n  return {\n    selectedBooks,\n    allSelected,\n    selectedUuids,\n    selectTo,\n    selectAll,\n  }\n}\n\nfunction useHomeHotKeys({\n  focusSearchInput,\n  orderSelectPrev,\n  orderSelectNext,\n  dataBooks,\n  selectTo,\n  selectAll,\n  selectedBooks,\n  reload,\n  moveBooksTop,\n  removeBooks,\n  hasOrder,\n}: {\n  focusSearchInput: () => void\n  orderSelectPrev: () => void\n  orderSelectNext: () => void\n  dataBooks: BookPage | null | undefined\n  selectTo: (index: number, shift: boolean) => void\n  selectAll: () => void\n  selectedBooks: BookTypes.Entity[]\n  reload: () => void\n  moveBooksTop: (books: BookTypes.Entity[]) => Promise<void>\n  removeBooks: (books: BookTypes.Entity[]) => void\n  hasOrder: boolean\n}) {\n  const [activatedIndex, setActivatedIndex] = useAtom(activatedIndexAtom)\n  const [, setPage] = usePage()\n  const [, setArchived] = useAtom(archivedAtom)\n  const [, setFavorited] = useAtom(favoritedAtom)\n  const [isPersonReplace] = usePersonReplace()\n  const [speechSpeed] = useSpeechSpeed()\n  const { getVoice } = useGetVoice()\n  const { addHotkeys } = useHotkeys()\n  const { openBookEdit } = useBookEditDialog(reload)\n  const nav = useNavigate()\n\n  const currentBook = useMemo(\n    () => dataBooks?.items[activatedIndex],\n    [activatedIndex, dataBooks],\n  )\n\n  const actionBooks = useMemo(\n    () =>\n      selectedBooks.length ? selectedBooks : currentBook ? [currentBook] : [],\n    [currentBook, selectedBooks],\n  )\n\n  useEffect(() => {\n    const count = dataBooks?.items.length ?? 0\n\n    const goPrev = () => {\n      setActivatedIndex((activatedIndex) =>\n        activatedIndex > 0 ? activatedIndex - 1 : 0,\n      )\n    }\n\n    const goTop = () => {\n      setActivatedIndex(0)\n    }\n\n    const goNext = () => {\n      setActivatedIndex((activatedIndex) =>\n        activatedIndex < count - 1 ? activatedIndex + 1 : activatedIndex,\n      )\n    }\n\n    const goBottom = () => {\n      setActivatedIndex(count - 1)\n    }\n\n    const pagePrev = () => {\n      if (dataBooks) {\n        setPage((page) => (page > 1 ? page - 1 : dataBooks.pageCount))\n      }\n    }\n\n    const pageFirst = () => {\n      if (dataBooks) setPage(1)\n    }\n\n    const pageNext = () => {\n      if (dataBooks) {\n        setPage((page) => (page < dataBooks.pageCount ? page + 1 : 1))\n      }\n    }\n\n    const pageLast = () => {\n      if (dataBooks) setPage(dataBooks.pageCount)\n    }\n\n    const movePrev = async () => {\n      if (!currentBook || !dataBooks) return\n      goPrev()\n      await moveOffset(dataBooks.items, activatedIndex, -1)\n      reload()\n    }\n\n    const moveNext = async () => {\n      if (!currentBook || !dataBooks) return\n      goNext()\n      await moveOffset(dataBooks.items, activatedIndex, 1)\n      reload()\n    }\n\n    const select = (shift: boolean) => {\n      selectTo(activatedIndex, shift)\n    }\n\n    const removeBook = () => {\n      if (currentBook) removeBooks(actionBooks)\n    }\n\n    const moveBookTop = () => {\n      if (currentBook) void moveBooksTop(actionBooks)\n    }\n\n    const toggleListArchive = () => {\n      setArchived((v) => !v)\n    }\n\n    const toggleListFavorite = () => {\n      setFavorited((v) => !v)\n    }\n\n    const toggleArchive = () => {\n      async(async () => {\n        for (const book of actionBooks) {\n          await booksUpdateRouter.action({\n            uuid: book.uuid,\n            update: {\n              isArchived: !book.isArchived,\n            },\n          })\n        }\n        reload()\n      })\n    }\n\n    const toggleFavorite = () => {\n      async(async () => {\n        for (const book of actionBooks) {\n          await booksUpdateRouter.action({\n            uuid: book.uuid,\n            update: {\n              isFavorited: !book.isFavorited,\n            },\n          })\n        }\n        reload()\n      })\n    }\n\n    const speech = new Speech()\n    const speakBookName = () => {\n      if (!currentBook) return\n      const voice = getVoice(currentBook)\n      if (!voice) return\n      void speech.speak(currentBook.name, {\n        voice,\n        speed: speechSpeed,\n        isPersonReplace,\n      })\n    }\n\n    const hotkeys: HotkeyItem[] = [\n      // move\n      ['k', t('hotkey.goPrev'), goPrev],\n      ['j', t('hotkey.goNext'), goNext],\n      ['ArrowUp', t('hotkey.goPrev'), goPrev],\n      ['ArrowDown', t('hotkey.goNext'), goNext],\n      ['h', t('hotkey.goPagePrev'), pagePrev],\n      ['l', t('hotkey.goPageNext'), pageNext],\n      ['ArrowLeft', t('hotkey.goPagePrev'), pagePrev],\n      ['ArrowRight', t('hotkey.goPageNext'), pageNext],\n      [['g', 'g'], t('hotkey.goTop'), goTop],\n      [{ shift: true, key: 'g' }, t('hotkey.goBottom'), goBottom],\n      [{ shift: true, key: 'h' }, t('hotkey.goPageFirst'), pageFirst],\n      [{ shift: true, key: 'l' }, t('hotkey.goPageLast'), pageLast],\n      [{ shift: true, key: 'ArrowUp' }, t('hotkey.goTop'), goTop],\n      [{ shift: true, key: 'ArrowDown' }, t('hotkey.goBottom'), goBottom],\n      [{ shift: true, key: 'ArrowLeft' }, t('hotkey.goPageFirst'), pageFirst],\n      [{ shift: true, key: 'ArrowRight' }, t('hotkey.goPageLast'), pageLast],\n\n      // filter\n      [\n        ['s', { shift: true, key: 'E' }],\n        t('hotkey.listArchive'),\n        toggleListArchive,\n      ],\n      [['s', 'b'], t('hotkey.listFavorite'), toggleListFavorite],\n      ['b', t('hotkey.favorite'), toggleFavorite],\n      [{ shift: true, key: 'E' }, t('hotkey.archive'), toggleArchive],\n      ['/', t('hotkey.search'), focusSearchInput],\n      [['s', 's', 'n'], t('hotkey.sortOrder'), orderSelectNext],\n      [['s', 's', 'p'], t('hotkey.sortOrder'), orderSelectPrev],\n\n      // selection\n      ['x', t('hotkey.select'), () => select(false)],\n      ['v', t('hotkey.select'), () => select(false)],\n      [{ shift: true, key: 'x' }, t('hotkey.selectShift'), () => select(true)],\n      [{ shift: true, key: 'v' }, t('hotkey.selectShift'), () => select(true)],\n      [{ shift: true, key: 'a' }, t('hotkey.selectAll'), () => selectAll()],\n\n      // action\n      ['t', t('hotkey.goMoveTop'), moveBookTop],\n      [\n        'e',\n        t('hotkey.edit'),\n        () => currentBook && openBookEdit(currentBook.uuid),\n      ],\n      [\n        'Enter',\n        t('hotkey.open'),\n        () => {\n          if (!currentBook) return\n          nav(viewPath(currentBook.uuid))\n        },\n      ],\n      [{ shift: true, key: '#' }, t('hotkey.remove'), removeBook],\n      [['d', 'd'], t('hotkey.remove'), removeBook],\n      [{ shift: true, key: 'K' }, t('hotkey.speakBookName'), speakBookName],\n    ]\n\n    if (!hasOrder)\n      hotkeys.push(\n        [{ ctrl: true, key: 'k' }, t('hotkey.goMovePrev'), movePrev],\n        [{ ctrl: true, key: 'j' }, t('hotkey.goMoveNext'), moveNext],\n        [{ ctrl: true, key: 'ArrowUp' }, t('hotkey.goMovePrev'), movePrev],\n        [{ ctrl: true, key: 'ArrowDown' }, t('hotkey.goMoveNext'), moveNext],\n      )\n\n    return addHotkeys(hotkeys)\n  }, [\n    actionBooks,\n    activatedIndex,\n    addHotkeys,\n    currentBook,\n    dataBooks,\n    focusSearchInput,\n    getVoice,\n    hasOrder,\n    isPersonReplace,\n    moveBooksTop,\n    nav,\n    openBookEdit,\n    orderSelectNext,\n    orderSelectPrev,\n    reload,\n    removeBooks,\n    selectAll,\n    selectTo,\n    setActivatedIndex,\n    setArchived,\n    setFavorited,\n    setPage,\n    speechSpeed,\n  ])\n}\n\nfunction BookButtons({\n  book,\n  reload,\n}: {\n  book: BookTypes.Entity\n  reload: () => void\n}) {\n  const { openBookEdit } = useBookEditDialog(reload)\n\n  const exportBook = useCallback(() => {\n    window.open(\n      `${booksDownloadRouter.fullRoutePath}?uuid=${book.uuid}`,\n      '_blank',\n    )\n  }, [book.uuid])\n\n  const removeBooks = useRemoveBooks(reload)\n\n  return (\n    <Dropdown\n      trigger={['click']}\n      menu={{\n        items: [\n          {\n            key: 'edit',\n            label: t('edit'),\n            onClick: () => openBookEdit(book.uuid),\n          },\n          {\n            key: 'archive',\n            label: book.isArchived ? t('unarchive') : t('archive'),\n            onClick: () => {\n              async(async () => {\n                await booksUpdateRouter.action({\n                  uuid: book.uuid,\n                  update: {\n                    isArchived: !book.isArchived,\n                  },\n                })\n                reload()\n              })\n            },\n          },\n          {\n            key: 'export',\n            label: `${t('export')} Epub`,\n            onClick: () => exportBook(),\n          },\n          {\n            key: 'remove',\n            label: t('remove'),\n            onClick: () => removeBooks([book]),\n          },\n        ],\n      }}\n    >\n      <Button shape=\"circle\" type=\"text\">\n        <Icon icon={faEllipsisVertical} />\n      </Button>\n    </Dropdown>\n  )\n}\n\nfunction BookRow({\n  index,\n  activated,\n  book,\n  books,\n  onHoverMove,\n  onDrop,\n  onCancel,\n  selectedUuids,\n  selectTo,\n  reload,\n  hasOrder,\n}: {\n  index: number\n  activated: boolean\n  book: BookTypes.Entity\n  books: BookTypes.Entity[]\n  onHoverMove: (dragIndex: number, hoverIndex: number) => void\n  onDrop: (item: DragItem) => void\n  onCancel: () => void\n  selectedUuids: string[]\n  selectTo: (index: number, shift: boolean) => void\n  reload: () => void\n  hasOrder: boolean\n}) {\n  const nav = useNavigate()\n  const [, setActivatedIndex] = useAtom(activatedIndexAtom)\n  const refEl = useRef<HTMLTableRowElement>(null)\n\n  const [, drop] = useDrop<DragItem, void>({\n    accept: DragType,\n    hover(item) {\n      const dragIndex = books.findIndex((book) => book.uuid === item.uuid)\n      if (dragIndex === -1) return\n\n      const hoverIndex = index\n\n      if (dragIndex === hoverIndex) {\n        return\n      }\n\n      onHoverMove(dragIndex, hoverIndex)\n\n      item.hoverIndex = hoverIndex\n    },\n    drop(item) {\n      onDrop(item)\n    },\n  })\n\n  const [{ isDragging }, drag] = useDrag({\n    type: DragType,\n    item: (): DragItem => {\n      return {\n        name: book.name,\n        uuid: book.uuid,\n        startIndex: index,\n        hoverIndex: index,\n      }\n    },\n    collect: (monitor) => ({\n      isDragging: monitor.isDragging(),\n    }),\n    end(_item, monitor) {\n      if (!monitor.didDrop()) onCancel()\n    },\n  })\n\n  useEffect(() => {\n    if (activated)\n      refEl.current?.scrollIntoView({\n        block: 'center',\n      })\n  }, [activated, drop])\n\n  const [coverLoaded, setCoverLoaded] = useState(false)\n\n  const coverUrl = `${getBooksCoverPath(book.uuid)}`\n\n  const opacity = isDragging ? 0.2 : 1\n  if (!hasOrder) drop(refEl)\n  return (\n    <tr\n      ref={refEl}\n      key={book.uuid}\n      style={{\n        opacity,\n        background: activated ? 'var(--main-bg-active)' : 'var(--main-bg)',\n      }}\n    >\n      <td\n        ref={drag}\n        style={{\n          cursor: 'move',\n        }}\n      >\n        {!hasOrder && (\n          <Icon size=\"lg\" icon={faGripVertical} style={{ marginLeft: 4 }} />\n        )}\n      </td>\n      <td>\n        <Checkbox\n          checked={selectedUuids.includes(book.uuid)}\n          onClick={(event) => {\n            selectTo(index, event.shiftKey)\n          }}\n        ></Checkbox>\n      </td>\n      <td align=\"center\" style={{ cursor: 'pointer' }}>\n        {book.isFavorited ? (\n          <Icon\n            icon={faStar}\n            onClick={() => {\n              async(async () => {\n                await booksUpdateRouter.action({\n                  uuid: book.uuid,\n                  update: {\n                    isFavorited: false,\n                  },\n                })\n                reload()\n              })\n            }}\n          />\n        ) : (\n          <Icon\n            icon={faStarRegular}\n            onClick={() => {\n              async(async () => {\n                await booksUpdateRouter.action({\n                  uuid: book.uuid,\n                  update: {\n                    isFavorited: true,\n                  },\n                })\n                reload()\n              })\n            }}\n          />\n        )}\n      </td>\n      <td>\n        <div className=\"cell-center\">\n          <img\n            onClick={() => {\n              globalStore.set(previewImgSrcAtom, coverUrl)\n            }}\n            onLoad={() => {\n              setCoverLoaded(true)\n            }}\n            style={{\n              visibility: coverLoaded ? 'visible' : 'hidden',\n              cursor: 'pointer',\n            }}\n            src={coverUrl}\n            alt={`${book.name} ${t('cover')}`}\n          />\n        </div>\n      </td>\n      <td\n        className={styles.hover}\n        title={book.createdAt.toLocaleString()}\n        onClick={() => {\n          setActivatedIndex(index)\n          nav(viewPath(book.uuid))\n        }}\n      >\n        {book.name}\n      </td>\n      <td>\n        <BookButtons book={book} reload={reload}></BookButtons>\n      </td>\n    </tr>\n  )\n}\n\nfunction BookRemoveButton({ onRemove }: { onRemove: (uuid: string) => void }) {\n  const [{ canDrop, isOver }, drop] = useDrop({\n    accept: DragType,\n    drop(item: DragItem) {\n      onRemove(item.uuid)\n    },\n    collect: (monitor) => ({\n      isOver: monitor.isOver(),\n      canDrop: monitor.canDrop(),\n    }),\n  })\n\n  if (!canDrop) return <></>\n\n  return (\n    <Tag\n      ref={drop}\n      color={isOver ? 'error' : 'warning'}\n      icon={isOver ? <Icon icon={faTrash} /> : null}\n    >\n      {t('prompt.dropHereToRemove')}\n    </Tag>\n  )\n}\n\nexport function BookList() {\n  const [page, setPage] = usePage()\n  const [perPage, setPerPage] = useAtom(perPageAtom)\n  const [activatedIndex, setActivatedIndex] = useAtom(activatedIndexAtom)\n  const [archived, setArchived] = useAtom(archivedAtom)\n  const [favorited, setFavorited] = useAtom(favoritedAtom)\n\n  const [search, setSearch] = useAtom(searchAtom)\n  const searchDeferred = useSyncedDebounced(search, 500)\n  const refSearchInput = useRef<InputRef | null>(null)\n\n  const [order, setOrder] = useAtom(orderAtom)\n  const hasOrder = order !== 'default'\n\n  const { data: dataBooks, reload } = useAction(\n    booksPageRouter,\n    {\n      filter: {\n        archive: archived ? 'archived' : 'active',\n        favorite: favorited ? 'favorited' : 'all',\n        search: searchDeferred,\n        order,\n      },\n      page: { page, perPage },\n    },\n    {\n      clearWhenReload: false,\n    },\n  )\n  const [loading, setLoading] = useState<boolean>(false)\n\n  const [books, setBooks] = useState<BookTypes.Entity[] | null>(null)\n  const resetBooks = useCallback(() => {\n    setBooks(dataBooks ? [...dataBooks.items] : null)\n  }, [dataBooks])\n  useEffect(() => {\n    resetBooks()\n  }, [resetBooks])\n\n  const { selectedBooks, allSelected, selectedUuids, selectTo, selectAll } =\n    useSelector(books)\n\n  const focusSearchInput = useCallback(() => {\n    if (refSearchInput.current) {\n      refSearchInput.current.focus()\n    }\n  }, [])\n\n  const orderSelectPrev = useCallback(() => {\n    const i = sortOrders.indexOf(order)\n    const prevOrder = sortOrders[i - 1]\n    if (prevOrder) setOrder(prevOrder)\n    else {\n      const lastOrder = sortOrders[sortOrders.length - 1]\n      if (lastOrder) setOrder(lastOrder)\n    }\n  }, [order, setOrder])\n\n  const orderSelectNext = useCallback(() => {\n    const i = sortOrders.indexOf(order)\n    const nextOrder = sortOrders[i + 1]\n    if (nextOrder) setOrder(nextOrder)\n    else setOrder(sortOrders[0])\n  }, [order, setOrder])\n\n  const removeBooks = useRemoveBooks(reload)\n\n  const moveBooksTop = useCallback(\n    async (books: BookTypes.Entity[]) => {\n      for (const book of [...books.reverse()]) {\n        await booksMoveTopRouter.action({\n          uuid: book.uuid,\n        })\n      }\n      setPage(1)\n      reload()\n    },\n    [reload, setPage],\n  )\n\n  useHomeHotKeys({\n    focusSearchInput,\n    orderSelectPrev,\n    orderSelectNext,\n    dataBooks,\n    reload,\n    selectTo,\n    selectAll,\n    selectedBooks,\n    moveBooksTop,\n    removeBooks,\n    hasOrder,\n  })\n\n  const onHoverMove = useCallback(\n    (dragIndex: number, hoverIndex: number) => {\n      if (!books) return\n      const newBooks = [...books]\n      const [entityJson] = newBooks.splice(dragIndex, 1)\n      if (entityJson) newBooks.splice(hoverIndex, 0, entityJson)\n      setBooks(newBooks)\n    },\n    [books],\n  )\n\n  const onDrop = useCallback(\n    (item: DragItem) => {\n      async(async () => {\n        if (!dataBooks) return\n        setLoading(true)\n        await moveOffset(\n          dataBooks.items,\n          item.startIndex,\n          item.hoverIndex - item.startIndex,\n        )\n        reload()\n        setLoading(false)\n      })\n    },\n    [dataBooks, reload],\n  )\n\n  const onCancel = useCallback(() => {\n    resetBooks()\n  }, [resetBooks])\n\n  const onRemove = useCallback(\n    (uuid: string) => {\n      resetBooks()\n      const book = books?.find((book) => book.uuid === uuid)\n      if (!book) return\n      removeBooks([book])\n    },\n    [books, removeBooks, resetBooks],\n  )\n\n  const OperationBtnGroup = useMemo(() => {\n    return (\n      !!selectedUuids.length && (\n        <Button.Group>\n          <Button\n            type=\"primary\"\n            size=\"small\"\n            onClick={() => {\n              async(async () => {\n                await moveBooksTop(selectedBooks)\n                reload()\n              })\n            }}\n          >\n            {t('top')}\n          </Button>\n          <Button\n            type=\"primary\"\n            size=\"small\"\n            danger\n            onClick={() => {\n              removeBooks(selectedBooks)\n            }}\n          >\n            {t('remove')}\n          </Button>\n        </Button.Group>\n      )\n    )\n  }, [moveBooksTop, reload, removeBooks, selectedBooks, selectedUuids.length])\n\n  const TopRightBar = useMemo(() => {\n    return (\n      <>\n        <BookRemoveButton onRemove={onRemove}></BookRemoveButton>\n        {OperationBtnGroup}\n      </>\n    )\n  }, [OperationBtnGroup, onRemove])\n\n  const AddBtn = useMemo(\n    () => (\n      <LinkWrap to=\"/books/add\">\n        {(href) => (\n          <Button type=\"text\" shape=\"circle\" href={href} title={t('add')}>\n            <Icon icon={faAdd} />\n          </Button>\n        )}\n      </LinkWrap>\n    ),\n    [],\n  )\n\n  useAppBarSync({\n    topRight: TopRightBar,\n    bottomRight: AddBtn,\n  })\n\n  // reset page & activatedIndex\n  useEffect(() => {\n    if (!books) return\n    if (books.length <= 0) {\n      if (page > 1) setPage(1)\n    } else if (activatedIndex > books.length - 1) {\n      setActivatedIndex(books.length - 1)\n    }\n  }, [activatedIndex, books, page, setActivatedIndex, setPage])\n\n  if (loading || !dataBooks || !books) return <SpinCenter />\n\n  const Pager =\n    dataBooks.pageCount > 1 ? (\n      <Pagination\n        onChange={(page) => setPage(page)}\n        pageSize={perPage}\n        onShowSizeChange={(_, size) => setPerPage(size)}\n        current={page}\n        total={dataBooks.count}\n      ></Pagination>\n    ) : null\n\n  return (\n    <>\n      <Space direction=\"vertical\" style={{ width: '100%' }}>\n        <Form layout=\"inline\">\n          <Form.Item label={t('archive')}>\n            <Switch checked={archived} onChange={(v) => setArchived(v)} />\n          </Form.Item>\n          <Form.Item label={t('favorite')}>\n            <Switch checked={favorited} onChange={(v) => setFavorited(v)} />\n          </Form.Item>\n          <Form.Item label={t('search')}>\n            <Input\n              value={search}\n              placeholder={t('search')}\n              onChange={(e) => setSearch(e.target.value)}\n              ref={refSearchInput}\n              onKeyDown={(e) => {\n                if (e.key === 'Escape') refSearchInput.current?.blur()\n              }}\n            ></Input>\n          </Form.Item>\n          <Form.Item label={t('sortOrder.label')}>\n            <Select\n              showSearch\n              filterOption={filterOptionLabel}\n              popupMatchSelectWidth={false}\n              value={order}\n              onChange={(v) => setOrder(v)}\n              options={[\n                {\n                  label: t('sortOrder.item.default'),\n                  value: 'default',\n                },\n                {\n                  label: t('sortOrder.item.reverse'),\n                  value: 'reverse',\n                },\n                {\n                  label: t('sortOrder.item.name'),\n                  value: 'name',\n                },\n                {\n                  label: t('sortOrder.item.nameReverse'),\n                  value: 'name-reverse',\n                },\n              ]}\n            ></Select>\n          </Form.Item>\n        </Form>\n        {books.length <= 0 ? (\n          <Alert type=\"warning\" message={t('prompt.noBooks')}></Alert>\n        ) : (\n          <>\n            {Pager}\n            <table className={styles.table}>\n              <thead>\n                <tr>\n                  <th></th>\n                  <th>\n                    <Checkbox\n                      title={t('all')}\n                      checked={allSelected}\n                      onClick={() => {\n                        selectAll()\n                      }}\n                    ></Checkbox>\n                  </th>\n                  <th>{t('favorite')}</th>\n                  <th>{t('cover')}</th>\n                  <th>{t('bookName')}</th>\n                  <th></th>\n                </tr>\n              </thead>\n              <tbody>\n                {books.map((book, index) => {\n                  return (\n                    <BookRow\n                      book={book}\n                      books={books}\n                      index={index}\n                      activated={activatedIndex === index}\n                      onHoverMove={onHoverMove}\n                      onDrop={onDrop}\n                      onCancel={onCancel}\n                      selectTo={selectTo}\n                      selectedUuids={selectedUuids}\n                      reload={reload}\n                      hasOrder={hasOrder}\n                      key={book.uuid}\n                    ></BookRow>\n                  )\n                })}\n              </tbody>\n            </table>\n            {Pager}\n          </>\n        )}\n      </Space>\n    </>\n  )\n}\n","import { atom, useAtom } from 'jotai'\nimport type { BookView } from '../../../core/book/book-base.js'\nimport type { BookTypes } from '../../../core/book/types.js'\n\nexport type BookContextProps = {\n  uuid: string\n  book: BookView\n  pos: BookTypes.PropertyPosition\n  setPos: React.Dispatch<\n    React.SetStateAction<BookTypes.PropertyPosition | undefined>\n  >\n  reload: () => void\n}\n\nexport const bookContextAtom = atom<BookContextProps | null>(null)\n\nexport const useBookContext = () => {\n  const [bookContext] = useAtom(bookContextAtom)\n  if (!bookContext)\n    throw new Error('BookContext must be used within a BookProvider')\n  return bookContext\n}\n","import { useAtom } from 'jotai'\nimport { useCallback, useEffect, useMemo, useState } from 'react'\nimport { useParams } from 'react-router-dom'\nimport { booksPositionSyncRouter } from '../../../core/api/books/position-sync.js'\nimport { booksPositionRouter } from '../../../core/api/books/position.js'\nimport { booksViewRouter } from '../../../core/api/books/view.js'\nimport type { BookView } from '../../../core/book/book-base.js'\nimport type { BookTypes } from '../../../core/book/types.js'\nimport { useAction } from '../../../core/route/action.js'\nimport { useFetch } from '../../../core/route/use-fetch.js'\nimport { FlexBox } from '../../components/flex-box.js'\nimport { SpinCenter } from '../../components/spin.js'\nimport { usePushTitle } from '../../hooks/use-title.js'\nimport { NotFound } from '../not-found.js'\nimport { bookContextAtom, useBookContext } from './view.context.js'\nimport styles from './view.module.scss'\nimport { useViewer } from './view/viewer.js'\n\nexport const useBookView = (uuid: string) => {\n  const {\n    data: bookData,\n    error,\n    reload: reloadBook,\n  } = useAction(booksViewRouter, { uuid })\n  const {\n    data: posData,\n    error: posError,\n    reload: reloadPos,\n  } = useFetch(\n    [bookData],\n    async (bookData): Promise<BookTypes.PropertyPosition | undefined> => {\n      if (!bookData) return\n      return booksPositionRouter.action({ uuid: bookData.item.uuid })\n    },\n  )\n  const [pos, setPos] = useState<BookTypes.PropertyPosition>()\n  const section = pos?.section\n  const paragraph = pos?.paragraph\n\n  // flatten navs\n  const book: BookView | undefined = useMemo(() => {\n    if (!bookData) return undefined\n    const flattenedNavs = []\n    const stack = [...bookData.navs]\n    while (stack.length) {\n      const cur = stack.shift()!\n      flattenedNavs.push(cur)\n      stack.unshift(...cur.children)\n    }\n    return {\n      ...bookData,\n      flattenedNavs,\n    }\n  }, [bookData])\n\n  // get pos\n  useEffect(() => {\n    if (posData) setPos(posData)\n  }, [posData])\n\n  // sync pos\n  useEffect(() => {\n    if (book === undefined || section === undefined || paragraph === undefined)\n      return\n    booksPositionSyncRouter\n      .action({ uuid: book.item.uuid, pos: { section, paragraph } })\n      .catch(console.error)\n  }, [book, paragraph, section])\n\n  const reload = useCallback(() => {\n    reloadBook()\n    reloadPos()\n  }, [reloadBook, reloadPos])\n\n  return {\n    error: error || posError,\n    pos,\n    setPos,\n    book,\n    reload,\n  }\n}\n\nfunction BookViewContent() {\n  const { book } = useBookContext()\n  const { BookPanelView, MainContent, activeNavs } = useViewer()\n  const pushTitle = usePushTitle()\n\n  const lastNav = useMemo(() => activeNavs?.at(-1), [activeNavs])\n\n  useEffect(() => {\n    let mainTitle = `${book.item.name}`\n    if (lastNav) mainTitle = `${lastNav.label} - ${mainTitle}`\n    pushTitle(mainTitle)\n  }, [book, lastNav, pushTitle])\n\n  return (\n    <FlexBox dir=\"row\" className={styles.contentWrapper}>\n      {BookPanelView}\n      {MainContent}\n    </FlexBox>\n  )\n}\n\nfunction BookViewReq({ uuid }: { uuid: string }) {\n  const { error, pos, setPos, book, reload } = useBookView(uuid)\n  const [bookContext, setBookContext] = useAtom(bookContextAtom)\n\n  useEffect(() => {\n    if (book && pos)\n      setBookContext({\n        uuid: book.item.uuid,\n        book,\n        pos,\n        setPos,\n        reload,\n      })\n    else setBookContext(null)\n  }, [book, pos, reload, setBookContext, setPos])\n\n  if (error) return <NotFound title=\"book\"></NotFound>\n\n  if (!book || !pos) return <SpinCenter></SpinCenter>\n\n  if (!bookContext) return <SpinCenter></SpinCenter>\n\n  return <BookViewContent></BookViewContent>\n}\n\nexport function BookView() {\n  const { uuid } = useParams<{ uuid: string }>()\n\n  if (!uuid) return <NotFound title=\"book\"></NotFound>\n\n  return <BookViewReq uuid={uuid} />\n}\n","import { faSearch } from '@fortawesome/free-solid-svg-icons'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { useMountEffect } from '@react-hookz/web'\nimport { Alert, Button, Drawer, Input, type InputRef } from 'antd'\nimport { t } from 'i18next'\nimport { useCallback, useEffect, useRef, useState } from 'react'\nimport {\n  booksSearchRouter,\n  type BookSearchMatch,\n  type BookSearchResponse,\n} from '../../../../core/api/books/search.js'\nimport { eventBan } from '../../../../core/util/dom.js'\nimport { FlexBox } from '../../../components/flex-box.js'\nimport { useKeyEscape } from '../../../hooks/use-escape.js'\nimport { useHotkeys } from '../../../hotkey/hotkey-state.js'\nimport { useBookContext } from '../view.context.js'\nimport styles from './book-search.module.scss'\nimport type { Player } from './player.js'\nimport { atom, useAtom } from 'jotai'\n\nconst openAtom = atom(false)\n\nconst searchTriggerRef: {\n  callback?: (search: string) => Promise<void>\n} = {}\n\nexport function useBookSearch() {\n  const bookSearch = useCallback(async (search: string) => {\n    void searchTriggerRef.callback?.(search)\n  }, [])\n  return bookSearch\n}\n\nfunction BookSearchResult({\n  open,\n  player,\n  searchResponse,\n}: {\n  open: boolean\n  player: Player\n  searchResponse: BookSearchResponse | null\n}) {\n  const [selectedIndex, setSelectedIndex] = useState<number>(0)\n  const refSearchResult = useRef<HTMLDivElement>(null)\n\n  const gotoMatch = useCallback(\n    async (match: BookSearchMatch) => {\n      await player.gotoPos({\n        section: match.section,\n        paragraph: match.paragraph,\n      })\n    },\n    [player],\n  )\n\n  // scroll to selected\n  useEffect(() => {\n    if (selectedIndex < 0) return\n    const resultDiv = refSearchResult.current\n    if (!resultDiv) return\n    const selectedDiv = resultDiv.querySelector('li.text.selected')\n    selectedDiv?.scrollIntoView({\n      block: 'center',\n    })\n  }, [selectedIndex])\n\n  const { addHotkeys } = useHotkeys()\n\n  useEffect(() => {\n    if (!open || !searchResponse) return\n    const matches = searchResponse.matches\n\n    const prevSearch = () => {\n      setSelectedIndex((idx) => (idx <= 0 ? 0 : idx - 1))\n    }\n\n    const nextSearch = () => {\n      setSelectedIndex((idx) =>\n        idx >= matches.length - 1 ? matches.length - 1 : idx + 1,\n      )\n    }\n\n    const gotoSearch = async () => {\n      const match = matches.at(selectedIndex)\n      if (match) await gotoMatch(match)\n    }\n\n    return addHotkeys(\n      [\n        ['p', t('hotkey.prevSearchResult'), prevSearch],\n        ['n', t('hotkey.nextSearchResult'), nextSearch],\n        ['enter', t('hotkey.gotoSearchResult'), gotoSearch],\n      ],\n      { level: 2 },\n    )\n  }, [addHotkeys, gotoMatch, open, searchResponse, selectedIndex])\n\n  if (!searchResponse) return null\n  if (searchResponse.matches.length === 0)\n    return <Alert type=\"warning\" message={t('prompt.noSearchMatches')}></Alert>\n  const searchLength = searchResponse.search.length\n  return (\n    <div className={styles.bookSearchResult} ref={refSearchResult}>\n      <ul>\n        {searchResponse.matches.map((match, i) => {\n          const isSelected = i === selectedIndex\n          const textCls: string[] = ['text', 'clickable']\n          if (isSelected) textCls.push('selected')\n          const firstText = match.text.slice(0, match.start)\n          const lastText = match.text.slice(match.start + searchLength)\n          return (\n            <li\n              className={textCls.join(' ')}\n              key={i}\n              onClick={() => {\n                void gotoMatch(match)\n                setSelectedIndex(i)\n              }}\n            >\n              {match.nav && <strong>{match.nav}</strong>}\n              <div>\n                {firstText}\n                <span className=\"highlight\">{searchResponse.search}</span>\n                {lastText}\n              </div>\n            </li>\n          )\n        })}\n      </ul>\n      <div className=\"stats\">\n        {selectedIndex + 1} / {searchResponse.matches.length}\n      </div>\n    </div>\n  )\n}\n\nfunction BookSearchView({\n  refSearchInput,\n  player,\n}: {\n  refSearchInput: React.MutableRefObject<InputRef | null>\n  player: Player\n}) {\n  const [open, setOpen] = useAtom(openAtom)\n  const { uuid } = useBookContext()\n  const [search, setSearch] = useState('')\n  const [loading, setLoading] = useState(false)\n  const [searchResponse, setSearchResponse] =\n    useState<BookSearchResponse | null>(null)\n  const bookSearch = useBookSearch()\n\n  searchTriggerRef.callback = useCallback(\n    async (newSearch: string) => {\n      setOpen(true)\n      setSearch(newSearch)\n      if (loading) return\n      setSearchResponse(null)\n      setLoading(true)\n      const res = await booksSearchRouter.action({ uuid, search: newSearch })\n      setSearchResponse(res)\n      setLoading(false)\n      refSearchInput.current?.blur()\n    },\n    [loading, refSearchInput, setOpen, uuid],\n  )\n\n  useMountEffect(() => {\n    setTimeout(() => {\n      if (refSearchInput.current) {\n        refSearchInput.current.focus()\n      }\n    }, 100)\n  })\n\n  return (\n    <FlexBox style={{ width: '100%', height: '100%' }} gap={8}>\n      <FlexBox dir=\"row\" gap={8}>\n        <Input\n          className=\"flex-1\"\n          ref={refSearchInput}\n          value={search}\n          onChange={(e) => setSearch(e.target.value)}\n          onKeyDown={(e) => {\n            if (e.key === 'Escape') {\n              eventBan(e)\n              refSearchInput.current?.blur()\n            } else if (e.key === 'Enter') {\n              void bookSearch(search)\n            }\n          }}\n        ></Input>\n        <Button\n          onClick={() => {\n            void bookSearch(search)\n          }}\n          loading={loading}\n        >\n          <FontAwesomeIcon icon={faSearch} />\n        </Button>\n      </FlexBox>\n      <BookSearchResult\n        open={open}\n        player={player}\n        searchResponse={searchResponse}\n      />\n    </FlexBox>\n  )\n}\n\nexport function BookSearchButton({ player }: { player: Player }) {\n  const [open, setOpen] = useAtom(openAtom)\n  const refSearchInput = useRef<InputRef | null>(null)\n  const openSearch = useCallback(() => {\n    setOpen(true)\n    setTimeout(() => {\n      refSearchInput.current?.focus()\n    }, 100)\n  }, [setOpen])\n\n  const { addHotkeys } = useHotkeys()\n  useEffect(() => {\n    return addHotkeys([['/', t('search'), openSearch]], {\n      level: 2,\n    })\n  }, [addHotkeys, openSearch])\n\n  useKeyEscape(\n    () => {\n      setOpen(false)\n    },\n    { enable: open },\n  )\n\n  return (\n    <>\n      <Button\n        block\n        type=\"primary\"\n        icon={<FontAwesomeIcon icon={faSearch} />}\n        onClick={() => {\n          openSearch()\n        }}\n      >\n        {t('search')}\n      </Button>\n      <Drawer\n        forceRender\n        title={t('search')}\n        open={open}\n        onClose={() => setOpen(false)}\n      >\n        <BookSearchView refSearchInput={refSearchInput} player={player} />\n      </Drawer>\n    </>\n  )\n}\n","import { ROOT_ANNOTATION_HIGHLIGHT_CLASS } from '../../../../../core/consts.js'\nimport { BaseHighlight } from './highlight.js'\n\nexport class AnnotationHighlight extends BaseHighlight {\n  rootClass = ROOT_ANNOTATION_HIGHLIGHT_CLASS\n  ignoreClass = null\n}\n","import { sum } from '../../../../../core/util/collection.js'\nimport { isElement, isTextNode } from '../../../../../core/util/dom.js'\nimport type { ReadablePart } from '../../../../../core/util/readable.js'\nimport { throttleFn } from '../../../../../core/util/timer.js'\nimport type { PlayerIframeController } from '../player-iframe-controller.js'\nimport type { PlayerStatesManager } from '../player-states.js'\n\nconst enum FindRangePosType {\n  found,\n  skip,\n}\n\nexport type HighlightBlock = {\n  node: ReadablePart\n  charIndex: number\n  charLength: number\n  color?: string\n}\n\nexport type HighlightRange = {\n  range: Range\n  color?: string\n}\n\nexport type HighlightRect = {\n  top: number\n  bottom: number\n  left: number\n  right: number\n  width: number\n  height: number\n  color?: string\n}\n\nexport abstract class BaseHighlight {\n  highlightedElems: HTMLElement[] = []\n  abstract rootClass: string\n  abstract ignoreClass: string | null\n\n  constructor(\n    protected iframeCtrl: PlayerIframeController,\n    protected states: PlayerStatesManager,\n  ) {}\n\n  get doc() {\n    return this.iframeCtrl.doc\n  }\n\n  #hlRoot: HTMLDivElement | undefined\n  #cacheHlRectMap = new Map<number, HTMLDivElement>()\n\n  public reCreateRoot(doc: Document) {\n    doc.querySelectorAll(`.${this.rootClass}`).forEach((div) => div.remove())\n\n    this.#hlRoot = doc.createElement('div')\n    this.#hlRoot.classList.add(this.rootClass)\n    doc.documentElement.appendChild(this.#hlRoot)\n    this.#cacheHlRectMap.clear()\n  }\n\n  #highlightHide() {\n    const hlRoot = this.#hlRoot\n    if (!hlRoot) return\n    Array.from(hlRoot.children).forEach((div) => {\n      ;(div as HTMLDivElement).style.display = 'none'\n    })\n  }\n\n  #highlightCharsByRects(ranges: HighlightRange[], scrollTo: boolean) {\n    const doc = this.doc\n    const hlRoot = this.#hlRoot\n    if (!doc || !hlRoot) return\n\n    const getRectDiv = (idx: number, color: string | undefined) => {\n      let div = this.#cacheHlRectMap.get(idx)\n      if (!div) {\n        div = doc.createElement('div')\n        if (color) div.style.backgroundColor = color\n        this.#cacheHlRectMap.set(idx, div)\n        hlRoot.appendChild(div)\n      }\n      return div\n    }\n\n    const containerRect = doc.documentElement.getBoundingClientRect()\n    const rects: HighlightRect[] = ranges\n      .map((range) =>\n        [...range.range.getClientRects()].map((rect) => ({\n          width: rect.width,\n          height: rect.height,\n          left: rect.left - containerRect.left,\n          right: rect.right - containerRect.right,\n          top: rect.top - containerRect.top,\n          bottom: rect.bottom - containerRect.top,\n        })),\n      )\n      .flat()\n    this.#highlightHide()\n    for (const [idx, rect] of rects.entries()) {\n      const div = getRectDiv(idx, rect.color)\n      div.style.display = 'block'\n      div.style.top = `${rect.top}px`\n      div.style.left = `${rect.left}px`\n      div.style.width = `${rect.width}px`\n      div.style.height = `${rect.height}px`\n    }\n\n    if (scrollTo) this.#scrollToRects(rects)\n  }\n\n  #scrollToRects = throttleFn(1000, (rects: HighlightRect[]) => {\n    if (!this.doc) return\n    if (!rects.length) return\n\n    if (this.iframeCtrl.enabledPageList) {\n      const left = sum(rects.map((r) => r.left)) / rects.length\n      this.iframeCtrl.pageListScrollToLeft(left).catch(console.error)\n    } else if (this.iframeCtrl.isVertical) {\n      const right = sum(rects.map((r) => r.right)) / rects.length\n      this.iframeCtrl.scrollToRight(right).catch(console.error)\n    } else {\n      const top = sum(rects.map((r) => r.top)) / rects.length\n      this.iframeCtrl.scrollToTop(top).catch(console.error)\n    }\n  })\n\n  #findRangePos(\n    node: Node,\n    index: number,\n  ):\n    | { type: FindRangePosType.found; node: Node; index: number }\n    | { type: FindRangePosType.skip; remainIndex: number } {\n    if (!node.childNodes.length)\n      return {\n        type: FindRangePosType.skip,\n        remainIndex: index,\n      }\n    let remainIndex = index\n    for (const child of node.childNodes) {\n      if (isTextNode(child)) {\n        // text\n        if (!child.textContent) continue\n        if (remainIndex <= child.textContent.length) {\n          return {\n            type: FindRangePosType.found,\n            node: child,\n            index: remainIndex,\n          }\n        } else {\n          remainIndex -= child.textContent.length\n        }\n        continue\n      }\n\n      if (\n        this.ignoreClass &&\n        isElement(child) &&\n        child.closest(`.${this.ignoreClass}`)\n      )\n        // ignore class\n        continue\n\n      // recursion\n      const result = this.#findRangePos(child, remainIndex)\n      switch (result.type) {\n        case FindRangePosType.found:\n          return result\n        case FindRangePosType.skip:\n          remainIndex = result.remainIndex\n          continue\n      }\n    }\n    return {\n      type: FindRangePosType.skip,\n      remainIndex,\n    }\n  }\n\n  #getChildAndIndex(\n    node: Node,\n    index: number,\n  ): { node: Node; index: number } | null {\n    const result = this.#findRangePos(node, index)\n    if (result.type === FindRangePosType.found) {\n      return result\n    } else {\n      return null\n    }\n  }\n\n  #highlightChars(blocks: HighlightBlock[], scrollTo: boolean) {\n    if (!this.doc) return\n\n    const ranges: HighlightRange[] = []\n    for (const block of blocks) {\n      const { node, charIndex, charLength, color } = block\n      // get range\n      const range = document.createRange()\n      const start = this.#getChildAndIndex(node.elem, charIndex)\n      if (!start) continue\n      const end = this.#getChildAndIndex(node.elem, charIndex + charLength)\n      if (!end) continue\n      try {\n        range.setStart(start.node, start.index)\n        range.setEnd(end.node, end.index)\n      } catch (error) {\n        console.error(error)\n        // skip range index error\n        continue\n      }\n\n      ranges.push({ range, color })\n    }\n\n    this.#highlightCharsByRects(ranges, scrollTo)\n  }\n\n  highlight(blocks: HighlightBlock[], scrollTo: boolean) {\n    this.iframeCtrl\n      .tryManipulateDOM(() => {\n        this.#highlightChars(blocks, scrollTo)\n      })\n      .catch(console.error)\n  }\n\n  highlightHide() {\n    this.iframeCtrl\n      .tryManipulateDOM(() => {\n        this.#highlightHide()\n      })\n      .catch(console.error)\n  }\n}\n","import { ROOT_KEYWORD_HIGHLIGHT_CLASS } from '../../../../../core/consts.js'\nimport { BaseHighlight } from './highlight.js'\n\nexport class KeywordHighlight extends BaseHighlight {\n  rootClass = ROOT_KEYWORD_HIGHLIGHT_CLASS\n  ignoreClass = null\n}\n","import {\n  PARA_IGNORE_CLASS,\n  ROOT_UTTERER_HIGHLIGHT_CLASS,\n} from '../../../../../core/consts.js'\nimport { BaseHighlight } from './highlight.js'\n\nexport class UttererHighlight extends BaseHighlight {\n  rootClass = ROOT_UTTERER_HIGHLIGHT_CLASS\n  ignoreClass = PARA_IGNORE_CLASS\n}\n","import { Button, Form, Modal, Typography } from 'antd'\nimport { t } from 'i18next'\nimport { useCallback, useEffect, useState } from 'react'\nimport type { BookTypes } from '../../../../../core/book/types.js'\nimport { eventBan } from '../../../../../core/util/dom.js'\nimport { FlexBox } from '../../../../components/flex-box.js'\nimport { Textarea } from '../../../../components/textarea.js'\nimport type { Player } from '../player.js'\n\nexport function useAnnotationNoteDialog({ player }: { player: Player }) {\n  const [editAnnotation, setEditAnnotation] =\n    useState<BookTypes.PropertyAnnotation | null>(null)\n  const [note, setNote] = useState<string>()\n\n  useEffect(() => {\n    if (!editAnnotation) return\n    setNote(editAnnotation.note)\n  }, [editAnnotation])\n\n  const onOk = useCallback(() => {\n    if (editAnnotation)\n      void player.annotations.upsert(\n        {\n          pos: editAnnotation.pos,\n          range: editAnnotation.range,\n          uuid: editAnnotation.uuid,\n        },\n        {\n          color: editAnnotation.color,\n          group: editAnnotation.group,\n          note,\n        },\n      )\n    setEditAnnotation(null)\n  }, [editAnnotation, note, player.annotations])\n\n  const onClose = useCallback(() => {\n    setEditAnnotation(null)\n  }, [])\n\n  return {\n    openNoteEdit: setEditAnnotation,\n    NoteEditDialog: (\n      <Modal\n        open={!!editAnnotation}\n        onCancel={onClose}\n        footer={false}\n        title={`${t('annotation')} ${t('note')}`}\n      >\n        <Typography>{editAnnotation?.brief}</Typography>\n        <form\n          onSubmit={(e) => {\n            eventBan(e)\n            void onOk()\n          }}\n        >\n          <Form.Item label={t('note')}>\n            <FlexBox gap={8}>\n              <Textarea\n                autoFocus\n                value={note}\n                onChange={(e) => setNote(e.target.value)}\n              ></Textarea>\n            </FlexBox>\n          </Form.Item>\n          <Form.Item>\n            <Button type=\"primary\" htmlType=\"submit\">\n              {t('update')}\n            </Button>\n          </Form.Item>\n        </form>\n      </Modal>\n    ),\n  }\n}\n","import {\n  faEllipsisVertical,\n  faNoteSticky,\n  faTrash,\n} from '@fortawesome/free-solid-svg-icons'\nimport { Dropdown } from 'antd'\nimport { t } from 'i18next'\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport { booksAnnotationsRouter } from '../../../../../core/api/books/annotations.js'\nimport type { BookView } from '../../../../../core/book/book-base.js'\nimport type { BookTypes } from '../../../../../core/book/types.js'\nimport { useAction } from '../../../../../core/route/action.js'\nimport { isMobile } from '../../../../../core/util/browser.js'\nimport { eventBan } from '../../../../../core/util/dom.js'\nimport { SwipeAction } from '../../../../common/swipe-action.js'\nimport { Icon } from '../../../../components/icon.js'\nimport { useHotkeys } from '../../../../hotkey/hotkey-state.js'\nimport type { Player } from '../player.js'\nimport { useAnnotationNoteDialog } from './annotations-dialogs.js'\n\nfunction AnnotationItem({\n  annotation,\n  openNoteEdit,\n  isSelected,\n  isActivated,\n  player,\n}: {\n  annotation: BookTypes.PropertyAnnotation\n  openNoteEdit: (\n    annotation: BookTypes.PropertyAnnotation,\n    player: Player,\n  ) => void\n  isSelected: boolean\n  isActivated: boolean\n  player: Player\n}) {\n  const textCls: string[] = ['text', 'clickable']\n  if (isActivated) textCls.push('active')\n  if (isSelected) textCls.push('selected')\n\n  const menuItems = [\n    {\n      key: 'note',\n      icon: <Icon icon={faNoteSticky} size=\"sm\" />,\n      label: t('note'),\n      onClick: () => {\n        openNoteEdit(annotation, player)\n      },\n    },\n    {\n      key: 'remove',\n      icon: <Icon icon={faTrash} size=\"sm\" />,\n      label: t('remove'),\n      onClick: () => {\n        void player.annotations.remove(annotation)\n      },\n    },\n  ]\n\n  return (\n    <li\n      data-pos-section={annotation.pos.section}\n      data-pos-paragraph={annotation.pos.paragraph}\n    >\n      <SwipeAction\n        left={{\n          node: <Icon icon={faNoteSticky} size=\"sm\" />,\n          width: 30,\n          trigger: () => {\n            openNoteEdit(annotation, player)\n          },\n        }}\n        right={{\n          node: <Icon icon={faTrash} size=\"sm\" />,\n          width: 30,\n          trigger: () => {\n            void player.annotations.remove(annotation)\n          },\n        }}\n      >\n        <Dropdown\n          menu={{\n            items: menuItems,\n          }}\n          trigger={['contextMenu']}\n        >\n          <div className=\"item\">\n            <div\n              className={textCls.join(' ')}\n              style={{ fontSize: 13 }}\n              onClick={(event) => {\n                eventBan(event)\n                player\n                  .gotoSection(annotation.pos.section, annotation.pos.paragraph)\n                  .catch(console.error)\n              }}\n            >\n              {annotation.brief}\n              {annotation.range && (\n                <div className=\"range\">\n                  <span className=\"selected-text\">\n                    {annotation.range.selectedText}\n                  </span>\n                </div>\n              )}\n              {annotation.note && (\n                <div className=\"note\">note: {annotation.note}</div>\n              )}\n            </div>\n            {!isMobile && (\n              <div className=\"btn\">\n                <Dropdown\n                  menu={{\n                    items: menuItems,\n                  }}\n                >\n                  <div>\n                    <Icon\n                      icon={faEllipsisVertical}\n                      style={{\n                        paddingLeft: '8px',\n                        paddingRight: '8px',\n                      }}\n                    />\n                  </div>\n                </Dropdown>\n              </div>\n            )}\n          </div>\n        </Dropdown>\n      </SwipeAction>\n    </li>\n  )\n}\n\nfunction Annotations({\n  annotations,\n  activeAnnotationIndex,\n  closestAnnotationIndex,\n  player,\n}: {\n  annotations: BookTypes.PropertyAnnotation[] | undefined | null\n  activeAnnotationIndex: number | null\n  closestAnnotationIndex: number | null\n  player: Player\n}) {\n  const { addHotkeys } = useHotkeys()\n  const [selectedIndex, setSelectedIndex] = useState<number>(0)\n  const refAnnotation = useRef<HTMLDivElement>(null)\n\n  const { openNoteEdit, NoteEditDialog } = useAnnotationNoteDialog({ player })\n\n  const selectedAnnotation = useMemo(() => {\n    return annotations?.at(selectedIndex)\n  }, [annotations, selectedIndex])\n\n  const removeSelectedAnnotation = useCallback(async () => {\n    if (selectedAnnotation) await player.annotations.remove(selectedAnnotation)\n  }, [player.annotations, selectedAnnotation])\n\n  // selected hotkeys\n  useEffect(() => {\n    const prevAnnotation = () => {\n      setSelectedIndex((idx) => (idx <= 0 ? 0 : idx - 1))\n    }\n    const nextAnnotation = () => {\n      annotations &&\n        setSelectedIndex((idx) =>\n          idx >= annotations.length - 1 ? annotations.length - 1 : idx + 1,\n        )\n    }\n    const gotoAnnotation = () => {\n      const selectedAnnotation = annotations?.[selectedIndex]\n      if (!selectedAnnotation) return\n      player\n        .gotoSection(\n          selectedAnnotation.pos.section,\n          selectedAnnotation.pos.paragraph,\n        )\n        .catch(console.error)\n    }\n    const speakAnnotation = () => {\n      if (!selectedAnnotation) return\n      player.utterer.speakText(selectedAnnotation.brief).catch(console.error)\n    }\n\n    return addHotkeys([\n      ['p', t('hotkey.prevAnnotation'), prevAnnotation],\n      ['n', t('hotkey.nextAnnotation'), nextAnnotation],\n      ['enter', t('hotkey.gotoAnnotation'), gotoAnnotation],\n      [\n        ['d', 'b'],\n        t('hotkey.annotationRemoveSelected'),\n        () => removeSelectedAnnotation(),\n      ],\n      [\n        ['g', 'n'],\n        t('hotkey.annotationNote'),\n        () => openNoteEdit(selectedAnnotation ?? null),\n      ],\n      [{ shift: true, key: 'K' }, t('hotkey.speakAnnotation'), speakAnnotation],\n    ])\n  }, [\n    addHotkeys,\n    annotations,\n    openNoteEdit,\n    player,\n    removeSelectedAnnotation,\n    selectedAnnotation,\n    selectedIndex,\n  ])\n\n  // change selected annotation\n  useEffect(() => {\n    if (closestAnnotationIndex === null) return\n    setSelectedIndex(closestAnnotationIndex)\n  }, [closestAnnotationIndex])\n\n  // scroll to selected annotation\n  useEffect(() => {\n    if (!selectedAnnotation) return\n    const annotationDiv = refAnnotation.current\n    if (!annotationDiv) return\n    const selectedAnnotationDiv =\n      annotationDiv.querySelector('div.text.selected')\n    selectedAnnotationDiv?.scrollIntoView({\n      block: 'center',\n    })\n  }, [selectedAnnotation])\n\n  return (\n    <div className=\"panel-content book-annotations\" ref={refAnnotation}>\n      {!annotations?.length ? (\n        t('desc.annotationsEmpty')\n      ) : (\n        <ul>\n          {annotations.map((annotation, idx) => (\n            <AnnotationItem\n              key={idx}\n              annotation={annotation}\n              openNoteEdit={openNoteEdit}\n              isActivated={activeAnnotationIndex === idx}\n              isSelected={selectedIndex === idx}\n              player={player}\n            ></AnnotationItem>\n          ))}\n        </ul>\n      )}\n      {NoteEditDialog}\n    </div>\n  )\n}\n\nexport function useBookViewAnnotations(\n  book: BookView,\n  player: Player,\n  pos: BookTypes.PropertyPosition,\n  selection: BookTypes.PropertyRange | undefined,\n) {\n  const uuid = book.item.uuid\n\n  const { data: annotations, reload } = useAction(\n    booksAnnotationsRouter,\n    {\n      uuid,\n    },\n    {\n      clearWhenReload: false,\n    },\n  )\n\n  useEffect(() => {\n    player.annotations.reload = reload\n    return () => {\n      player.annotations.reload = undefined\n    }\n  }, [player.annotations, reload])\n\n  const activeAnnotationIndex = useMemo(() => {\n    return player.annotations.indexByPos(pos, selection ?? null)\n  }, [player.annotations, pos, selection])\n\n  const closestAnnotationIndex = useMemo(() => {\n    return player.annotations.closestIndexByPos(pos)\n  }, [player.annotations, pos])\n\n  const activeAnnotation = useMemo(\n    () =>\n      activeAnnotationIndex !== null\n        ? annotations?.at(activeAnnotationIndex)\n        : undefined,\n    [annotations, activeAnnotationIndex],\n  )\n\n  const closestAnnotation = useMemo(\n    () =>\n      closestAnnotationIndex !== null\n        ? annotations?.at(closestAnnotationIndex)\n        : undefined,\n    [annotations, closestAnnotationIndex],\n  )\n\n  return {\n    annotations,\n    AnnotationView: (\n      <Annotations\n        annotations={annotations}\n        closestAnnotationIndex={closestAnnotationIndex}\n        activeAnnotationIndex={activeAnnotationIndex}\n        player={player}\n      ></Annotations>\n    ),\n    closestAnnotation,\n  }\n}\n","import { Button, Form, Modal, Typography } from 'antd'\nimport { t } from 'i18next'\nimport { useCallback, useEffect, useState } from 'react'\nimport type { BookTypes } from '../../../../../core/book/types.js'\nimport { eventBan } from '../../../../../core/util/dom.js'\nimport { FlexBox } from '../../../../components/flex-box.js'\nimport { Textarea } from '../../../../components/textarea.js'\nimport type { Player } from '../player.js'\n\nexport function useKeywordDialog({ player }: { player: Player }) {\n  const [editKeyword, setEditKeyword] =\n    useState<BookTypes.PropertyKeyword | null>(null)\n  const [alias, setAlias] = useState<string>()\n  const [note, setNote] = useState<string>()\n\n  useEffect(() => {\n    if (!editKeyword) return\n    setAlias(editKeyword.alias?.join('\\n'))\n    setNote(editKeyword.note)\n  }, [editKeyword])\n\n  const onOk = useCallback(() => {\n    if (editKeyword)\n      void player.keywords.upsert(\n        {\n          pos: editKeyword.pos,\n          uuid: editKeyword.uuid,\n          keyword: editKeyword.keyword,\n        },\n        {\n          color: editKeyword.color,\n          note,\n          alias: alias\n            ?.split('\\n')\n            .map((a) => a.trim())\n            .filter((a) => a),\n        },\n      )\n    setEditKeyword(null)\n  }, [alias, editKeyword, note, player.keywords])\n\n  const onClose = useCallback(() => {\n    setEditKeyword(null)\n  }, [])\n\n  return {\n    openEdit: setEditKeyword,\n    EditDialog: (\n      <Modal\n        open={!!editKeyword}\n        onCancel={onClose}\n        footer={false}\n        title={`${t('keyword')} ${t('note')}`}\n      >\n        <Typography>{editKeyword?.keyword}</Typography>\n        <form\n          onSubmit={(e) => {\n            eventBan(e)\n            void onOk()\n          }}\n        >\n          <Form.Item label={t('alias')}>\n            <FlexBox gap={8}>\n              <Textarea\n                autoFocus\n                value={alias}\n                onChange={(e) => setAlias(e.target.value)}\n              ></Textarea>\n            </FlexBox>\n          </Form.Item>\n          <Form.Item label={t('note')}>\n            <FlexBox gap={8}>\n              <Textarea\n                value={note}\n                onChange={(e) => setNote(e.target.value)}\n              ></Textarea>\n            </FlexBox>\n          </Form.Item>\n          <Form.Item>\n            <Button type=\"primary\" htmlType=\"submit\">\n              {t('update')}\n            </Button>\n          </Form.Item>\n        </form>\n      </Modal>\n    ),\n  }\n}\n","import {\n  faEllipsisVertical,\n  faNoteSticky,\n  faSearch,\n  faTrash,\n} from '@fortawesome/free-solid-svg-icons'\nimport { Dropdown, Space } from 'antd'\nimport { t } from 'i18next'\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport { booksKeywordsRouter } from '../../../../../core/api/books/keywords.js'\nimport type { BookView } from '../../../../../core/book/book-base.js'\nimport type { BookTypes } from '../../../../../core/book/types.js'\nimport { useAction } from '../../../../../core/route/action.js'\nimport { eventBan } from '../../../../../core/util/dom.js'\nimport { SwipeAction } from '../../../../common/swipe-action.js'\nimport { Icon } from '../../../../components/icon.js'\nimport { useHotkeys } from '../../../../hotkey/hotkey-state.js'\nimport { useBookSearch } from '../book-search.js'\nimport type { Player } from '../player.js'\nimport { useKeywordDialog } from './keywords-dialogs.js'\n\nfunction KeywordItem({\n  keyword,\n  openEdit,\n  isSelected,\n  player,\n}: {\n  keyword: BookTypes.PropertyKeyword\n  openEdit: (keyword: BookTypes.PropertyKeyword, player: Player) => void\n  isSelected: boolean\n  player: Player\n}) {\n  const bookSearch = useBookSearch()\n  const textCls: string[] = ['text', 'clickable']\n  if (isSelected) textCls.push('selected')\n\n  const menuItems = [\n    {\n      key: 'note',\n      icon: <Icon icon={faNoteSticky} size=\"sm\" />,\n      label: t('note'),\n      onClick: () => {\n        openEdit(keyword, player)\n      },\n    },\n    {\n      key: 'remove',\n      icon: <Icon icon={faTrash} size=\"sm\" />,\n      label: t('remove'),\n      onClick: () => {\n        void player.keywords.remove(keyword)\n      },\n    },\n    {\n      key: 'search',\n      icon: <Icon icon={faSearch} size=\"sm\" />,\n      label: t('search'),\n      onClick: () => {\n        void bookSearch(keyword.keyword)\n      },\n    },\n  ]\n\n  return (\n    <li>\n      <SwipeAction\n        left={{\n          node: <Icon icon={faNoteSticky} size=\"sm\" />,\n          width: 30,\n          trigger: () => {\n            openEdit(keyword, player)\n          },\n        }}\n        right={{\n          node: <Icon icon={faTrash} size=\"sm\" />,\n          width: 30,\n          trigger: () => {\n            void player.keywords.remove(keyword)\n          },\n        }}\n      >\n        <Dropdown\n          menu={{\n            items: menuItems,\n          }}\n          trigger={['contextMenu']}\n        >\n          <div className=\"item\">\n            <div\n              className={textCls.join(' ')}\n              style={{ fontSize: 13 }}\n              onClick={(event) => {\n                eventBan(event)\n                player\n                  .gotoSection(keyword.pos.section, keyword.pos.paragraph)\n                  .catch(console.error)\n              }}\n            >\n              {keyword.keyword}\n              {keyword.alias && (\n                <div className=\"alias\">\n                  <Space wrap>\n                    {keyword.alias.map((a, i) => (\n                      <span key={i} className=\"selected-text\">\n                        {a}\n                      </span>\n                    ))}\n                  </Space>\n                </div>\n              )}\n              <div className=\"range\">\n                <span className=\"selected-text\">{keyword.brief}</span>\n              </div>\n              {keyword.note && <div className=\"note\">note: {keyword.note}</div>}\n            </div>\n            <div className=\"btn\">\n              <Dropdown\n                menu={{\n                  items: menuItems,\n                }}\n              >\n                <div>\n                  <Icon\n                    icon={faEllipsisVertical}\n                    style={{\n                      paddingLeft: '8px',\n                      paddingRight: '8px',\n                    }}\n                  />\n                </div>\n              </Dropdown>\n            </div>\n          </div>\n        </Dropdown>\n      </SwipeAction>\n    </li>\n  )\n}\n\nfunction Keywords({\n  keywords,\n  player,\n}: {\n  keywords: BookTypes.PropertyKeyword[] | undefined | null\n  player: Player\n}) {\n  const { addHotkeys } = useHotkeys()\n  const [selectedIndex, setSelectedIndex] = useState<number>(0)\n  const refKeyword = useRef<HTMLDivElement>(null)\n\n  const { openEdit, EditDialog } = useKeywordDialog({ player })\n\n  const selectedKeyword = useMemo(() => {\n    return keywords?.at(selectedIndex)\n  }, [keywords, selectedIndex])\n\n  const removeSelectedKeyword = useCallback(async () => {\n    if (selectedKeyword) await player.keywords.remove(selectedKeyword)\n  }, [player.keywords, selectedKeyword])\n\n  // selected hotkeys\n  useEffect(() => {\n    const prevKeyword = () => {\n      setSelectedIndex((idx) => (idx <= 0 ? 0 : idx - 1))\n    }\n    const nextKeyword = () => {\n      keywords &&\n        setSelectedIndex((idx) =>\n          idx >= keywords.length - 1 ? keywords.length - 1 : idx + 1,\n        )\n    }\n    const gotoKeyword = () => {\n      const selectedKeyword = keywords?.[selectedIndex]\n      if (!selectedKeyword) return\n      player\n        .gotoSection(selectedKeyword.pos.section, selectedKeyword.pos.paragraph)\n        .catch(console.error)\n    }\n    const speakKeyword = () => {\n      if (!selectedKeyword) return\n      player.utterer.speakText(selectedKeyword.keyword).catch(console.error)\n    }\n\n    return addHotkeys([\n      ['p', t('hotkey.prevKeyword'), prevKeyword],\n      ['n', t('hotkey.nextKeyword'), nextKeyword],\n      ['enter', t('hotkey.gotoKeyword'), gotoKeyword],\n      [\n        ['d', 'b'],\n        t('hotkey.keywordRemoveSelected'),\n        () => removeSelectedKeyword(),\n      ],\n      [\n        ['g', 'n'],\n        t('hotkey.keywordNote'),\n        () => openEdit(selectedKeyword ?? null),\n      ],\n      [{ shift: true, key: 'K' }, t('hotkey.speakKeyword'), speakKeyword],\n    ])\n  }, [\n    addHotkeys,\n    keywords,\n    openEdit,\n    player,\n    removeSelectedKeyword,\n    selectedKeyword,\n    selectedIndex,\n  ])\n\n  // scroll to selected keyword\n  useEffect(() => {\n    if (!selectedKeyword) return\n    const keywordDiv = refKeyword.current\n    if (!keywordDiv) return\n    const selectedKeywordDiv = keywordDiv.querySelector('div.text.selected')\n    selectedKeywordDiv?.scrollIntoView({\n      block: 'center',\n    })\n  }, [selectedKeyword])\n\n  return (\n    <div className=\"panel-content book-keywords\" ref={refKeyword}>\n      {!keywords?.length ? (\n        t('desc.keywordsEmpty')\n      ) : (\n        <ul>\n          {keywords.map((keyword, idx) => (\n            <KeywordItem\n              key={idx}\n              keyword={keyword}\n              openEdit={openEdit}\n              isSelected={selectedIndex === idx}\n              player={player}\n            ></KeywordItem>\n          ))}\n        </ul>\n      )}\n      {EditDialog}\n    </div>\n  )\n}\n\nexport function useBookViewKeywords(book: BookView, player: Player) {\n  const uuid = book.item.uuid\n\n  const { data: keywords, reload } = useAction(\n    booksKeywordsRouter,\n    {\n      uuid,\n    },\n    {\n      clearWhenReload: false,\n    },\n  )\n\n  useEffect(() => {\n    player.keywords.reload = reload\n    return () => {\n      player.keywords.reload = undefined\n    }\n  }, [player.keywords, reload])\n\n  return {\n    keywords,\n    KeywordView: <Keywords keywords={keywords} player={player}></Keywords>,\n  }\n}\n","import { t } from 'i18next'\nimport { useEffect, useMemo, useRef, useState } from 'react'\nimport type { BookNav, BookView } from '../../../../../core/book/book-base.js'\nimport { eventBan } from '../../../../../core/util/dom.js'\nimport { useHotkeys } from '../../../../hotkey/hotkey-state.js'\nimport type { Player } from '../player.js'\n\nfunction NavList({\n  navs,\n  activeNavs,\n  selectedNav,\n  player,\n}: {\n  navs: BookNav[]\n  activeNavs: BookNav[]\n  selectedNav: BookNav | undefined\n  player: Player\n}) {\n  if (!navs.length) return null\n\n  return (\n    <ul>\n      {navs.map((nav, idx) => {\n        const isSelected = selectedNav === nav\n        const isActivated =\n          nav.spineIndex !== undefined && activeNavs.includes(nav)\n        const textCls: string[] = ['text']\n        if (isActivated) textCls.push('active')\n        if (nav.href) textCls.push('clickable')\n        if (isSelected) textCls.push('selected')\n        return (\n          <li key={idx} data-href={nav.href} data-spine-index={nav.spineIndex}>\n            <div\n              className=\"item\"\n              onClick={(event) => {\n                eventBan(event)\n                if (nav.href) player.gotoUrlPath(nav.href).catch(console.error)\n              }}\n            >\n              <div className={textCls.join(' ')}>{nav.label}</div>\n            </div>\n            <NavList\n              navs={nav.children}\n              activeNavs={activeNavs}\n              selectedNav={selectedNav}\n              player={player}\n            ></NavList>\n          </li>\n        )\n      })}\n    </ul>\n  )\n}\n\nfunction NavTree({\n  book,\n  activeNavs,\n  player,\n}: {\n  book: BookView\n  activeNavs?: BookNav[]\n  player: Player\n}) {\n  const { addHotkeys } = useHotkeys()\n  const refNav = useRef<HTMLDivElement>(null)\n  const [selectedIndex, setSelectedIndex] = useState<number>(0)\n\n  const selectedNav = useMemo(() => {\n    return book.flattenedNavs[selectedIndex] as BookNav | undefined\n  }, [book.flattenedNavs, selectedIndex])\n\n  // selected hotkeys\n  useEffect(() => {\n    const prevNav = () => {\n      setSelectedIndex((idx) => (idx <= 0 ? 0 : idx - 1))\n    }\n    const nextNav = () => {\n      setSelectedIndex((idx) =>\n        idx >= book.flattenedNavs.length - 1\n          ? book.flattenedNavs.length - 1\n          : idx + 1,\n      )\n    }\n    const gotoNav = () => {\n      if (!selectedNav?.href) return\n      player.gotoUrlPath(selectedNav.href).catch(console.error)\n    }\n    const speakNav = () => {\n      if (!selectedNav) return\n      player.utterer.speakText(selectedNav.label).catch(console.error)\n    }\n\n    return addHotkeys([\n      ['p', t('hotkey.prevNav'), prevNav],\n      ['n', t('hotkey.nextNav'), nextNav],\n      ['enter', t('hotkey.gotoNav'), gotoNav],\n      [{ shift: true, key: 'K' }, t('hotkey.speakNav'), speakNav],\n    ])\n  }, [addHotkeys, book.flattenedNavs, player, selectedNav])\n\n  const lastActiveNav = useMemo(() => {\n    return activeNavs?.at(-1)\n  }, [activeNavs])\n\n  // change selected nav item\n  useEffect(() => {\n    if (lastActiveNav === undefined) return\n    const lastActiveNavIndex = book.flattenedNavs.indexOf(lastActiveNav)\n    if (lastActiveNavIndex === -1) return\n    setSelectedIndex(lastActiveNavIndex)\n  }, [book.flattenedNavs, lastActiveNav])\n\n  // scroll to selected nav\n  useEffect(() => {\n    if (!selectedNav) return\n    const navDiv = refNav.current\n    if (!navDiv) return\n    const selectedNavDiv = navDiv.querySelector('div.text.selected')\n    selectedNavDiv?.scrollIntoView({\n      block: 'center',\n    })\n  }, [selectedNav])\n\n  return (\n    <div ref={refNav} className=\"panel-content book-nav\">\n      {book.navs.length ? (\n        <NavList\n          navs={book.navs}\n          activeNavs={activeNavs ?? []}\n          selectedNav={selectedNav}\n          player={player}\n        />\n      ) : (\n        t('desc.navEmpty')\n      )}\n    </div>\n  )\n}\n\nexport function useBookViewNav(\n  book: BookView,\n  player: Player,\n  activeNavs?: BookNav[],\n) {\n  return {\n    NavTreeView: (\n      <NavTree book={book} player={player} activeNavs={activeNavs}></NavTree>\n    ),\n  }\n}\n","import { t } from 'i18next'\nimport { useMemo } from 'react'\nimport type { BookNav, BookView } from '../../../../../core/book/book-base.js'\nimport type { BookTypes } from '../../../../../core/book/types.js'\nimport { useViewPanelType } from '../../../../store.js'\nimport type { Player } from '../player.js'\nimport { useBookViewAnnotations } from './annotations.js'\nimport { useBookViewNav } from './nav.js'\nimport { useBookViewKeywords } from './keywords.js'\n\nexport function useBookPanel(\n  book: BookView,\n  player: Player,\n  activeNavs: BookNav[] | undefined,\n  pos: BookTypes.PropertyPosition,\n  selection: BookTypes.PropertyRange | undefined,\n) {\n  const [viewPanelType, setViewPanelType] = useViewPanelType()\n  const { NavTreeView } = useBookViewNav(book, player, activeNavs)\n  const { annotations, AnnotationView } = useBookViewAnnotations(\n    book,\n    player,\n    pos,\n    selection,\n  )\n  const { keywords, KeywordView } = useBookViewKeywords(book, player)\n\n  const BookPanelView = useMemo(\n    () => (\n      <>\n        <div\n          className={[\n            'book-panel',\n            viewPanelType === 'none' ? 'hidden' : '',\n          ].join(' ')}\n        >\n          {viewPanelType === 'nav' && (\n            <>\n              <h3>{t('nav')}</h3>\n              {NavTreeView}\n            </>\n          )}\n          {viewPanelType === 'annotation' && (\n            <>\n              <h3>{t('annotation')}</h3>\n              {AnnotationView}\n            </>\n          )}\n          {viewPanelType === 'keyword' && (\n            <>\n              <h3>{t('keyword')}</h3>\n              {KeywordView}\n            </>\n          )}\n        </div>\n        <div\n          className={[\n            'book-panel-overlay',\n            viewPanelType === 'none' ? 'hidden' : '',\n          ].join(' ')}\n          onClick={() => setViewPanelType('none')}\n        ></div>\n      </>\n    ),\n    [AnnotationView, KeywordView, NavTreeView, setViewPanelType, viewPanelType],\n  )\n\n  return useMemo(\n    () => ({\n      annotations,\n      keywords,\n      setViewPanelType,\n      BookPanelView,\n    }),\n    [annotations, keywords, setViewPanelType, BookPanelView],\n  )\n}\n","import { t } from 'i18next'\nimport invert from 'invert-color'\nimport { booksAnnotationsDeleteRouter } from '../../../../core/api/books/annotations-delete.js'\nimport { booksAnnotationsUpsertRouter } from '../../../../core/api/books/annotations-upsert.js'\nimport type { BookTypes } from '../../../../core/book/types.js'\nimport { uiConfirm } from '../../../common/confirm.js'\nimport { messageApi } from '../../../common/notification.js'\nimport type { Player } from './player.js'\n\nexport class PlayerAnnotations {\n  /** book uuid */\n  uuid: string\n  reload?: () => void\n\n  constructor(public readonly player: Player) {\n    this.uuid = player.book.item.uuid\n  }\n\n  async upsert(\n    {\n      uuid,\n      pos,\n      range,\n    }: {\n      uuid: string | null\n      pos: BookTypes.PropertyPosition\n      range?: BookTypes.PropertyRange | null\n    },\n    {\n      note,\n      color,\n      group,\n    }: {\n      note?: string\n      color?: string\n      group?: string\n    },\n  ): Promise<undefined | BookTypes.PropertyAnnotation> {\n    const node = this.player.iframeCtrler.readableParts.at(pos.paragraph)\n    if (!node) return\n    if (node.type !== 'text') {\n      void messageApi().error(t('desc.annotationNoSupported'))\n      return\n    }\n    const brief = node.text.slice(0, 30)\n    const res = await booksAnnotationsUpsertRouter.action({\n      annotations: [\n        {\n          uuid,\n          pos,\n          range: range ?? undefined,\n          brief,\n          type: 'text',\n          content: node.text,\n          note: note || undefined,\n          color,\n          group,\n        },\n      ],\n      uuid: this.uuid,\n    })\n    this.reload?.()\n    void messageApi().info(`${t('desc.annotationUpdated')} ${brief}`)\n    return res.annotations.at(0)\n  }\n\n  async remove(annotation: BookTypes.PropertyAnnotation) {\n    if (annotation.note || annotation.range) {\n      const fgColor = annotation.color\n        ? invert(annotation.color, {\n            black: '#3a3a3a',\n            white: '#fafafa',\n          })\n        : 'var(--main-fg-blue)'\n      if (\n        !(await uiConfirm({\n          title: t('prompt.annotationRemoveConfirm'),\n          description: (\n            <>\n              <p>{annotation.brief}</p>\n              {annotation.note && <p>Note: {annotation.note}</p>}\n              {annotation.range && (\n                <p>\n                  Selected:{' '}\n                  <span\n                    style={{\n                      backgroundColor:\n                        annotation.color ?? 'var(--main-bg-blue)',\n                      color: fgColor,\n                    }}\n                  >\n                    {annotation.range.selectedText}\n                  </span>\n                </p>\n              )}\n            </>\n          ),\n        }))\n      )\n        return\n    }\n\n    await booksAnnotationsDeleteRouter.action({\n      uuid: this.uuid,\n      annotationUuids: [annotation.uuid],\n    })\n    this.reload?.()\n    void messageApi().info(`${t('desc.annotationDeleted')} ${annotation.brief}`)\n  }\n\n  indexByPos(\n    pos: BookTypes.PropertyPosition,\n    range: BookTypes.PropertyRange | null,\n  ): number | null {\n    const annotations = this.player.states.annotations\n    if (!annotations) return null\n    const index = annotations.findIndex(\n      (n) =>\n        n.pos.section === pos.section &&\n        n.pos.paragraph === pos.paragraph &&\n        n.range?.start === range?.start &&\n        n.range?.end === range?.end,\n    )\n    if (index === -1) return null\n    return index\n  }\n\n  closestIndexByPos(pos: BookTypes.PropertyPosition) {\n    const annotations = this.player.states.annotations\n    if (!annotations) return null\n    const index = annotations.findLastIndex(\n      (n) => n.pos.section === pos.section && n.pos.paragraph <= pos.paragraph,\n    )\n    if (index === -1) return null\n    return index\n  }\n\n  protected byPos(\n    pos: BookTypes.PropertyPosition,\n    range: BookTypes.PropertyRange | null,\n  ) {\n    const index = this.indexByPos(pos, range)\n    if (index === null) return null\n    return this.player.states.annotations?.at(index) ?? null\n  }\n\n  async toggle(\n    pos: BookTypes.PropertyPosition,\n    range: BookTypes.PropertyRange | null,\n  ) {\n    const annotation = this.byPos(pos, range)\n    if (annotation) {\n      await this.remove(annotation)\n    } else {\n      await this.upsert({ pos, range, uuid: null }, {})\n    }\n  }\n}\n","import { useMountEffect } from '@react-hookz/web'\nimport { t } from 'i18next'\nimport path from '@file-services/path'\nimport type { RefObject } from 'react'\nimport { getBooksRenderPath } from '../../../../core/api/books/render.js'\nimport type { BookNav } from '../../../../core/book/book-base.js'\nimport { NAV_TOC_SELECTOR } from '../../../../core/book/book-epub.js'\nimport type { BookTypes } from '../../../../core/book/types.js'\nimport {\n  COLOR_SCHEME_DARK_CLASS,\n  COLUMN_BREAK_CLASS,\n  IMG_MAX_HEIGHT_CLASS,\n  IMG_MAX_WIDTH_CLASS,\n  PARA_ACTIVE_CLASS,\n  PARA_ANNOTATION_CLASS,\n  PARA_BOX_CLASS,\n  ROOT_ANNOTATION_HIGHLIGHT_CLASS,\n  ROOT_KEYWORD_HIGHLIGHT_CLASS,\n  ROOT_UTTERER_HIGHLIGHT_CLASS,\n} from '../../../../core/consts.js'\nimport {\n  isFirefox,\n  isMobile,\n  isSafari,\n  supportedTouch,\n} from '../../../../core/util/browser.js'\nimport {\n  findLast,\n  findLastIndex,\n  findLastPair,\n  range,\n} from '../../../../core/util/collection.js'\nimport {\n  eventBan,\n  isInputElement,\n  svgToDataUri,\n} from '../../../../core/util/dom.js'\nimport { Emitter, SingleEmitter } from '../../../../core/util/emitter.js'\nimport { async, sleep } from '../../../../core/util/promise.js'\nimport {\n  ReadableExtractor,\n  type ReadablePart,\n  type TextAlias,\n} from '../../../../core/util/readable.js'\nimport { keywordMatches } from '../../../../core/util/text.js'\nimport {\n  debounceFn,\n  iterateAnimate,\n  type IterateAnimateOptions,\n} from '../../../../core/util/timer.js'\nimport { urlSplitAnchor } from '../../../../core/util/url.js'\nimport { iframeWinAtom } from '../../../atoms.js'\nimport { uiConfirm } from '../../../common/confirm.js'\nimport { messageApi } from '../../../common/notification.js'\nimport { previewImgSrcAtom } from '../../../common/preview-image.js'\nimport type { ColorScheme } from '../../../store.js'\nimport { globalStore } from '../../../store/global.js'\nimport { globalStyle } from '../../../style.js'\nimport { AnnotationHighlight } from './highlight/annotation-highlight.js'\nimport type { HighlightBlock } from './highlight/highlight.js'\nimport { KeywordHighlight } from './highlight/keyword-highlight.js'\nimport type { Player } from './player'\nimport type { PlayerStatesManager } from './player-states.js'\n\ntype PageListNode = {\n  topmost?: {\n    paragraph: number\n    readablePart: ReadablePart\n  }\n  offsetLeft: number\n}\n\ninterface ScrollOptions extends IterateAnimateOptions {\n  /**\n   * @default true\n   */\n  animated?: boolean\n  /**\n   * @default 'center'\n   */\n  position?: 'center' | 'start'\n  /**\n   * @default true\n   */\n  userOperator?: boolean\n}\n\ntype PlayerIFrameEvent = {\n  scroll: null\n  swipeLeft: null\n  swipeRight: null\n  click: HTMLAnchorElement\n}\n\nexport class PlayerIframeController {\n  public readableParts: ReadablePart[] = []\n  public alias: TextAlias[] = []\n\n  public doc?: Document\n  public events = new Emitter<PlayerIFrameEvent>()\n  public unmount = new SingleEmitter<void>({ once: true })\n  public isVertical = false\n  public annotationHl: AnnotationHighlight\n  public keywordHl: KeywordHighlight\n\n  protected mainContentRootPath: string\n  protected mainContentRootUrl: string\n  protected colorScheme: ColorScheme = 'light'\n  protected viewWidth?: number\n  protected viewOffsetWidth?: number\n  protected viewHeight?: number\n  protected pageList?: PageListNode[]\n  protected pageListGap = 12\n  protected pageListScrollWidth = 0\n  protected pageListScrollLeft = 0\n  /** page list: single page width */\n  protected pageListColumnWidth?: number\n  protected pageListCount: number | undefined\n  /** page list: current index */\n  protected pageListCurIndex = 0\n  /** page list: focus to part after resize */\n  protected pageListResizeCurFocusPart?: ReadablePart\n  protected win?: Window\n\n  get book() {\n    return this.player.book\n  }\n\n  get iframe() {\n    return this.iframeRef.current\n  }\n\n  get enabledPageList() {\n    if (this.states.pageList === 'none') return false\n    return !this.isVertical\n  }\n\n  get isFirstPageList() {\n    return this.pageListCurIndex <= 0\n  }\n\n  get isLastPageList() {\n    if (!this.pageListCount) return true\n    return this.pageListCurIndex >= this.pageListCount - 1\n  }\n\n  constructor(\n    protected player: Player,\n    protected states: PlayerStatesManager,\n    protected iframeRef: RefObject<HTMLIFrameElement>,\n  ) {\n    this.mainContentRootPath = getBooksRenderPath(this.book.item.uuid, '')\n\n    this.mainContentRootUrl = new URL(\n      this.mainContentRootPath,\n      location.href,\n    ).toString()\n\n    this.annotationHl = new AnnotationHighlight(this, states)\n    this.keywordHl = new KeywordHighlight(this, states)\n\n    this.states.events.on('pos', () => {\n      this.updateParagraphActive()\n      this.updateActiveNavs()\n    })\n\n    this.states.events.on('started', (started) => {\n      if (!started) {\n        this.player.utterer.hl.highlightHide()\n      }\n    })\n\n    this.states.uiEvents.on('annotations', () => {\n      this.updateAnnotations()\n    })\n\n    this.states.uiEvents.on('keywords', () => {\n      this.updateKeywords()\n    })\n\n    let firstPageListChanged = true\n    this.states.uiEvents.on('pageList', async () => {\n      if (firstPageListChanged) {\n        firstPageListChanged = false\n        return\n      }\n      if (this.iframe) await this.load({ force: true })\n    })\n\n    let firstDisabledVerticalChanged = true\n    this.states.uiEvents.on('disabledVertical', async () => {\n      if (firstDisabledVerticalChanged) {\n        firstDisabledVerticalChanged = false\n        return\n      }\n      if (this.iframe) await this.load({ force: true })\n    })\n\n    this.states.uiEvents.on('fontSize', async () => {\n      if (!this.doc) return\n      this.updateFontSize(this.doc)\n      this.onResized(this.doc)\n    })\n\n    this.player.unmount.on(() => this.unmount.fire())\n  }\n\n  protected pageListType(): 'none' | 'double' | 'single' {\n    if (this.states.pageList === 'auto') {\n      if (this.win) {\n        return this.win.innerWidth > 700 ? 'double' : 'single'\n      } else {\n        return 'single'\n      }\n    }\n    return this.states.pageList\n  }\n\n  public async tryManipulateDOM(callback: () => unknown) {\n    await Promise.race([callback(), sleep(100)])\n  }\n\n  protected getReadablePartIndexByAnchorId(anchorId: string): number | null {\n    if (!anchorId) return null\n    // goto anchorId\n    const doc = this.doc\n    if (!doc) return null\n    try {\n      const index = this.readableParts.findIndex((part) => {\n        if (part.anchorIds?.includes(anchorId)) return true\n      })\n      return index === -1 ? null : index\n    } catch {\n      // ignore selector syntax error\n    }\n    return null\n  }\n\n  public async scrollToCurParagraph(animated = true) {\n    // goto paragraph\n    const item = this.readableParts.at(this.states.pos.paragraph)\n    if (item) await this.scrollToElem(item.elem, { animated })\n    else if (this.enabledPageList)\n      // reset to current page list position\n      await this.pageListScrollToLeft(this.pageListScrollLeft, { animated })\n  }\n\n  public async scrollToElem(element: HTMLElement, options: ScrollOptions = {}) {\n    await this.tryManipulateDOM(async () => {\n      if (!this.doc) return\n      const html = this.doc.documentElement\n      const containerRect = html.getBoundingClientRect()\n      const elemRect = element.getBoundingClientRect()\n      if (this.enabledPageList) {\n        const left =\n          elemRect.left + element.offsetWidth / 2 - containerRect.left\n        await this.pageListScrollToLeft(left, options)\n      } else if (this.isVertical) {\n        const right =\n          elemRect.right + element.offsetWidth / 2 - containerRect.right\n        await this.scrollToRight(right, options)\n      } else {\n        const top = elemRect.top - containerRect.top\n        await this.scrollToTop(top, options)\n      }\n    })\n  }\n\n  /**\n   * scroll to left offset with animation\n   */\n  public async scrollToRight(\n    left: number,\n    {\n      iteration = 10,\n      duration = 100,\n      animated = true,\n      abortCtrl,\n      position = 'center',\n    }: ScrollOptions = {},\n  ) {\n    if (!this.win) return\n    const scrollElement = this.doc?.scrollingElement\n    if (!scrollElement) return\n\n    // get center left\n    const finalLeft =\n      position === 'center' ? left + this.win.innerWidth / 2 : left\n\n    if (!animated) {\n      scrollElement.scrollLeft = finalLeft\n    } else {\n      const startLeft = scrollElement.scrollLeft\n      const offset = finalLeft - startLeft\n      const unit = offset / iteration\n      await iterateAnimate(\n        {\n          duration,\n          iteration,\n          abortCtrl,\n        },\n        (index) => {\n          scrollElement.scrollLeft = startLeft + index * unit\n        },\n      )\n    }\n  }\n\n  /**\n   * scroll to top offset with animation\n   */\n  public async scrollToTop(\n    top: number,\n    {\n      iteration = 10,\n      duration = 100,\n      animated = true,\n      abortCtrl,\n      position = 'center',\n    }: ScrollOptions = {},\n  ) {\n    if (!this.win) return\n    const scrollElement = this.doc?.scrollingElement\n    if (!scrollElement) return\n\n    // get center top\n    const finalTop =\n      position === 'center' ? top - this.win.innerHeight / 2 : top\n\n    if (!animated) {\n      scrollElement.scrollTop = finalTop\n    } else {\n      const startTop = scrollElement.scrollTop\n      const offset = finalTop - startTop\n      const unit = offset / iteration\n      await iterateAnimate(\n        {\n          duration,\n          iteration,\n          abortCtrl,\n        },\n        (index) => {\n          scrollElement.scrollTop = startTop + index * unit\n        },\n      )\n    }\n  }\n\n  protected pageListSetScrollLeft(scrollLeft: number) {\n    if (!this.doc) return\n    this.pageListScrollLeft = scrollLeft\n    this.doc.documentElement.style.transform = `translateX(${-scrollLeft}px)`\n    this.events.fire('scroll', null)\n  }\n\n  /**\n   * scroll to page by left offset with animation\n   */\n  public async pageListScrollToLeft(\n    left: number,\n    {\n      iteration = 10,\n      duration = 100,\n      animated = true,\n      abortCtrl,\n      userOperator = true,\n    }: ScrollOptions = {},\n  ) {\n    if (!this.enabledPageList) return\n    if (!this.pageList) return\n\n    const finalLeft = findLast(\n      this.pageList,\n      (page) => page.offsetLeft <= left,\n    )?.offsetLeft\n    if (finalLeft === undefined) return\n\n    if (!animated) {\n      this.pageListSetScrollLeft(finalLeft)\n    } else {\n      const startLeft = this.pageListScrollLeft\n      const offset = finalLeft - startLeft\n      const unit = offset / iteration\n      await iterateAnimate(\n        {\n          duration,\n          iteration,\n          abortCtrl,\n        },\n        (index) => {\n          this.pageListSetScrollLeft(startLeft + index * unit)\n        },\n      )\n    }\n\n    if (this.viewOffsetWidth)\n      this.pageListCurIndex = Math.round(\n        this.pageListScrollLeft / this.viewOffsetWidth,\n      )\n    if (userOperator) this.updatePageListCurFocus()\n  }\n\n  public async pageListScrollToPage(\n    pageIndex: number,\n    jump: boolean,\n    scrollOptions: ScrollOptions = {},\n  ) {\n    if (!this.enabledPageList) return\n    if (!this.pageList) return\n    const page = this.pageList.at(pageIndex)\n    if (!page) return\n    if (jump)\n      await this.player.gotoParagraph(\n        page.topmost?.paragraph ?? this.states.pos.paragraph,\n      )\n    else await this.pageListScrollToLeft(page.offsetLeft, scrollOptions)\n  }\n\n  #pushPageListLast?: {\n    abortCtrl: AbortController\n    pageIndex: number\n  }\n  public async pageListPushAdjust(offsetPage: number, jump: boolean) {\n    if (!this.viewOffsetWidth || !this.pageListCount || !this.pageList) return\n\n    let goalPageIndex: number\n    if (this.#pushPageListLast) {\n      goalPageIndex = this.#pushPageListLast.pageIndex + offsetPage\n    } else {\n      goalPageIndex = this.pageListCurIndex + offsetPage\n    }\n\n    // exceed section range\n    if (jump) {\n      if (goalPageIndex < 0) {\n        return await this.player.prevSection(-1)\n      } else if (goalPageIndex >= this.pageListCount) {\n        return await this.player.nextSection()\n      }\n    } else {\n      if (goalPageIndex < 0) goalPageIndex = 0\n      else if (goalPageIndex >= this.pageListCount)\n        goalPageIndex = this.pageListCount - 1\n    }\n\n    this.#pushPageListLast?.abortCtrl.abort()\n    const abortCtrl = new AbortController()\n    this.#pushPageListLast = {\n      abortCtrl,\n      pageIndex: goalPageIndex,\n    }\n\n    const goalLeft = goalPageIndex * this.viewOffsetWidth\n    await this.pageListScrollToLeft(goalLeft, { abortCtrl })\n    if (jump) {\n      const page = this.pageList.at(goalPageIndex)\n      if (page?.topmost)\n        await this.player.gotoParagraph(page.topmost.paragraph, false)\n    }\n\n    this.#pushPageListLast = undefined\n  }\n\n  public async scrollToPercent(percent: number, jump: boolean) {\n    const scrollElement = this.doc?.scrollingElement\n    // eslint-disable-next-line no-console\n    console.debug(`scrollElement: ${scrollElement?.tagName ?? 'null'}`)\n    if (!scrollElement) return\n\n    if (!this.enabledPageList) {\n      const scrollTop =\n        (scrollElement.scrollHeight - scrollElement.clientHeight) * percent\n      await this.scrollToTop(scrollTop, { position: 'start' })\n      return\n    }\n\n    // page list\n    if (!this.viewOffsetWidth) return\n\n    const targetIndex = Math.floor(\n      (this.pageListScrollWidth * percent) / this.viewOffsetWidth,\n    )\n    const offsetIndex = targetIndex - this.pageListCurIndex\n    await this.pageListPushAdjust(offsetIndex, jump)\n  }\n\n  #curAbsPath?: string\n\n  /**\n   * @param locate default is this.states.pos\n   */\n  public async load(\n    locate: {\n      section?: number\n      anchorId?: string\n      paragraph?: number\n      /** @default false */\n      animated?: boolean\n      /** @default false */\n      force?: boolean\n    } = {},\n  ) {\n    const iframe = this.iframe\n    if (!iframe) return\n    const force = locate.force ?? false\n\n    // get spine\n    const section = locate.section ?? this.states.pos.section\n    let spine = this.book.spines.at(section)\n    if (!spine) spine = this.book.spines.at(0)\n    if (!spine) return messageApi().error('book spine is empty')\n    // update section\n    this.states.pos = { ...this.states.pos, section }\n\n    const absPath = spine.href\n\n    const isLoadNewPath = force || absPath !== this.#curAbsPath\n    this.#curAbsPath = absPath\n\n    try {\n      // load iframe\n      if (isLoadNewPath) {\n        this.states.loading = true\n        // NOTE: (visibility = none) has BUG in Safari\n        this.iframe.style.opacity = '0'\n        this.unmount.fire()\n\n        const loaded = new Promise<void>((resolve) => {\n          iframe.addEventListener(\n            'load',\n            () => {\n              resolve()\n            },\n            { once: true },\n          )\n        })\n        iframe.src = getBooksRenderPath(this.book.item.uuid, absPath)\n        await loaded\n\n        const doc = iframe.contentDocument\n        if (!doc) return messageApi().error('iframe load failed')\n\n        // load readableParts & alias\n        const readableExtractor = new ReadableExtractor(\n          doc,\n          this.book.flattenedNavs,\n        )\n        this.readableParts = readableExtractor.toReadableParts()\n        this.alias = readableExtractor.alias()\n\n        // loaded\n        await this.onLoaded(iframe)\n      }\n\n      // update paragraph\n      let paragraph = this.states.pos.paragraph\n      if (locate.paragraph !== undefined) {\n        paragraph =\n          locate.paragraph < 0\n            ? this.readableParts.length + locate.paragraph\n            : locate.paragraph\n        // if exceeds readablePart range\n        if (paragraph < 0) paragraph = 0\n        else if (paragraph >= this.readableParts.length)\n          paragraph = this.readableParts.length - 1\n      } else if (locate.anchorId)\n        paragraph = this.getReadablePartIndexByAnchorId(locate.anchorId) ?? 0\n\n      this.states.pos = {\n        ...this.states.pos,\n        paragraph,\n      }\n\n      // scroll to paragraph\n      await this.scrollToCurParagraph(locate.animated ?? false)\n    } finally {\n      if (isLoadNewPath) {\n        this.states.loading = false\n        this.iframe.style.opacity = '1'\n      }\n    }\n  }\n\n  public async gotoUrlPath(path: string) {\n    const [urlMain, anchorId] = urlSplitAnchor(path)\n    const section = this.book.spines.findIndex((s) => s.href === urlMain)\n    if (section === -1) return\n    if (anchorId) await this.load({ section, anchorId })\n    else await this.load({ section, paragraph: 0 })\n  }\n\n  /**\n   * When loaded a new page\n   */\n  protected async onLoaded(iframe: HTMLIFrameElement) {\n    const win = iframe.contentWindow\n    const doc = iframe.contentDocument\n    // load inject and hook\n    if (win && doc) {\n      this.win = win\n      this.doc = doc\n\n      globalStore.set(iframeWinAtom, { win })\n\n      if (!this.states.disabledVertical)\n        this.isVertical = win\n          .getComputedStyle(doc.body)\n          .writingMode.startsWith('vertical')\n      else this.isVertical = false\n\n      this.updateColorTheme(this.colorScheme)\n      this.injectCSS(doc)\n      this.updateFontSize(doc)\n\n      this.viewCalculate(doc)\n      this.hookResize(win, doc)\n      this.resizeImgs(doc)\n      this.hookTouch()\n      if (this.enabledPageList) {\n        await this.pageListCalculate(doc)\n        this.hookPageWheel()\n        this.hookSwipe()\n      }\n      if (this.isVertical) {\n        this.hookVerticalWheel()\n      }\n      this.hookSelection()\n      this.hookScroll()\n      this.hookALinks(doc)\n      this.hookLinkClick()\n      this.hookImgs(doc)\n      this.hookParagraphClick()\n      this.player.utterer.hl.reCreateRoot(doc)\n      this.annotationHl.reCreateRoot(doc)\n      this.keywordHl.reCreateRoot(doc)\n      this.updateAnnotations()\n      this.updateKeywords()\n    }\n  }\n\n  public updateColorTheme(colorScheme: ColorScheme) {\n    this.colorScheme = colorScheme\n    if (!this.doc) return\n    if (colorScheme === 'dark') {\n      this.doc.documentElement.classList.add(COLOR_SCHEME_DARK_CLASS)\n    } else {\n      this.doc.documentElement.classList.remove(COLOR_SCHEME_DARK_CLASS)\n    }\n  }\n\n  protected injectCSS(doc: Document) {\n    const styleElem = doc.createElement('style')\n    let pageStyle = ''\n    if (this.enabledPageList) {\n      pageStyle += `\n        /* page list */\n        html {\n          width: 100% !important;\n          height: 100% !important;\n          box-sizing: border-box !important;\n          margin: 0 !important;\n          padding: 0 !important;\n          overflow: hidden !important;\n          will-change: transform !important;\n        }\n        body {\n          width: auto !important;\n          height: 100% !important;\n          box-sizing: border-box !important;\n          word-break: break-word !important;\n          margin: 0 !important;\n          padding: 0 !important;\n          /* Safari iOS not support\n            columns: var(--main-column-count) auto !important;\n          */\n          columns: var(--main-column-count) var(--main-column-width) !important;\n          column-gap: ${this.pageListGap}px !important;\n          column-fill: auto !important;\n        }\n        .${COLUMN_BREAK_CLASS} {\n          content: ' ';\n          break-before: column;\n          ${isSafari || isFirefox ? 'height: 100%' : ''}\n        }\n      `\n    } else {\n      pageStyle += `\n        html {\n          width: 100%;\n          height: 100%;\n          box-sizing: border-box !important;\n          margin: 0 !important;\n          padding: 8px !important;\n        }\n        body {\n          ${\n            this.isVertical\n              ? `\n                width: auto;\n                height: 100%;\n                overflow-y: hidden;\n              `\n              : `\n                height: auto;\n                width: 100%;\n                overflow-x: hidden;\n              `\n          }\n          box-sizing: border-box !important;\n        }\n      `\n    }\n\n    if (this.states.disabledVertical) {\n      pageStyle += `\n        body {\n          writing-mode: initial !important;\n        }\n      `\n    }\n\n    let hoverStyle = ''\n    if (!isMobile) {\n      hoverStyle = `\n        .${PARA_BOX_CLASS}:hover {\n          outline: 1px dashed var(--main-fg-hover);\n        }\n      `\n    }\n\n    styleElem.innerHTML = `\n      ${globalStyle}\n      ${pageStyle}\n\n      /* scrollbar */\n      ::-webkit-scrollbar-thumb {\n        background: var(--main-fg);\n      }\n\n      /* wrap */\n      pre {\n        white-space: pre-wrap;\n      }\n\n      /* image */\n      svg {\n        max-width: 90% !important;\n        max-height: 90vh;\n      }\n      img.${IMG_MAX_WIDTH_CLASS} {\n        max-width: 90% !important;\n        height: auto;\n      }\n      img.${IMG_MAX_HEIGHT_CLASS} {\n        width: auto;\n        max-height: 90vh;\n      }\n\n      /* scheme */\n      .${COLOR_SCHEME_DARK_CLASS} body,\n      .${COLOR_SCHEME_DARK_CLASS} body * {\n        background-color: var(--main-bg);\n        color: var(--main-fg) !important;\n      }\n\n      /* paragraph */\n      .${PARA_BOX_CLASS} {\n        cursor: pointer;\n      }\n\n      .${PARA_BOX_CLASS}.${PARA_ACTIVE_CLASS},\n      .${PARA_BOX_CLASS}.${PARA_ACTIVE_CLASS} * {\n        background: var(--main-bg-active) !important;\n      }\n\n      ${hoverStyle}\n\n      .${ROOT_UTTERER_HIGHLIGHT_CLASS} > div, .${ROOT_ANNOTATION_HIGHLIGHT_CLASS} > div, .${ROOT_KEYWORD_HIGHLIGHT_CLASS} > div {\n        background-color: var(--main-bg-highlight) !important;\n        color: var(--main-fg-highlight) !important;\n        position: absolute;\n        user-select: none;\n        pointer-events: none;\n      }\n\n      .${PARA_ANNOTATION_CLASS} {\n        text-decoration-line: underline;\n        text-decoration-style: solid;\n        text-decoration-thickness: 2px;\n        text-decoration-color: var(--main-bg-blue);\n        text-underline-offset: 4px;\n      }\n    `\n    doc.head.appendChild(styleElem)\n\n    doc.querySelectorAll('svg').forEach((svg) => {\n      svg.setAttribute('preserveAspectRatio', 'xMinYMin meet')\n    })\n  }\n\n  protected updateFontSize(doc: Document) {\n    this.tryManipulateDOM(() => {\n      doc.documentElement.style.fontSize = `${this.states.fontSize}px`\n    }).catch(console.error)\n  }\n\n  protected hookResize(win: Window, doc: Document) {\n    const onResized = () => this.onResized(doc)\n\n    win.addEventListener('resize', onResized)\n    this.unmount.on(() => {\n      win.removeEventListener('resize', onResized)\n    })\n  }\n\n  protected onResized = debounceFn(300, (doc: Document) => {\n    async(async () => {\n      this.viewCalculate(doc)\n      this.resizeImgs(doc)\n      if (this.enabledPageList) {\n        await this.pageListCalculate(doc)\n        const resizeFocusPart = this.pageListResizeCurFocusPart\n        if (resizeFocusPart)\n          await this.scrollToElem(resizeFocusPart.elem, {\n            animated: false,\n            userOperator: false,\n          })\n        else\n          await this.pageListScrollToLeft(this.pageListScrollLeft, {\n            animated: false,\n            userOperator: false,\n          })\n        this.player.utterer.hl.highlightHide()\n        this.updateAnnotations()\n        this.updateKeywords()\n      }\n    })\n  })\n\n  protected resizeImgs(doc: Document) {\n    const imgClasses = [IMG_MAX_WIDTH_CLASS, IMG_MAX_HEIGHT_CLASS]\n    const imgs = doc.querySelectorAll('img')\n\n    // remove classes\n    for (const img of imgs) {\n      img.classList.remove(...imgClasses)\n    }\n\n    if (!this.viewWidth) return\n\n    if (this.pageListType() === 'none') {\n      for (const img of imgs) {\n        if (img.width > this.viewWidth) img.classList.add(IMG_MAX_WIDTH_CLASS)\n      }\n    }\n  }\n\n  protected hookTouch() {\n    if (!supportedTouch) return\n    const doc = this.doc\n    const win = this.win\n    const viewWidth = this.viewWidth\n    if (!doc || !win || !viewWidth) return\n\n    let startPoint:\n      | {\n          x: number\n          y: number\n          offsetLeft: number\n          timestamp: number\n        }\n      | undefined = undefined\n    const speedLimit = 0.3\n    const viewRateLimit = 0.2\n\n    const onStart = (event: TouchEvent) => {\n      const touch = event.touches[0] as Touch | undefined\n      if (!touch) return\n      startPoint = {\n        x: touch.clientX,\n        y: touch.clientY,\n        offsetLeft: this.pageListScrollLeft,\n        timestamp: Date.now(),\n      }\n    }\n\n    const onMove = (event: TouchEvent) => {\n      eventBan(event)\n      if (startPoint === undefined) return\n      const selection = doc.getSelection()\n      if (selection?.type === 'Range') {\n        startPoint = undefined\n        return\n      }\n      const touch = event.touches[0] as Touch | undefined\n      if (!touch) return\n      const deltaX = touch.clientX - startPoint.x\n      this.pageListSetScrollLeft(startPoint.offsetLeft - deltaX)\n    }\n\n    const onEnd = (event: TouchEvent) => {\n      if (startPoint === undefined) return\n      const touch = event.changedTouches[0] as Touch | undefined\n      if (!touch) return\n      const deltaX = touch.clientX - startPoint.x\n      const speed = deltaX / (Date.now() - startPoint.timestamp)\n      const minX = viewWidth * viewRateLimit\n      if (speed < -speedLimit || deltaX < -minX) {\n        if (!this.isLastPageList || !this.player.isLastSection) {\n          this.events.fire('swipeRight', null)\n          return\n        }\n      } else if (speed > speedLimit || deltaX > minX) {\n        if (!this.isFirstPageList || !this.player.isFirstSection) {\n          this.events.fire('swipeLeft', null)\n          return\n        }\n      }\n      // restore\n      void this.pageListPushAdjust(0, false)\n    }\n\n    doc.addEventListener('touchstart', onStart)\n    doc.addEventListener('touchmove', onMove)\n    doc.addEventListener('touchend', onEnd)\n    this.unmount.on(() => {\n      doc.removeEventListener('touchstart', onStart)\n      doc.removeEventListener('touchmove', onMove)\n      doc.removeEventListener('touchend', onEnd)\n    })\n  }\n\n  protected hookPageWheel() {\n    const doc = this.doc\n    if (!doc) return\n\n    const onWheel = (e: WheelEvent) => {\n      eventBan(e)\n      if (isInputElement(e.target)) return\n      if (e.deltaY === 0) return\n      if (e.deltaY > 0) {\n        this.events.fire('swipeRight', null)\n      } else {\n        this.events.fire('swipeLeft', null)\n      }\n    }\n\n    doc.documentElement.addEventListener('wheel', onWheel)\n    this.unmount.on(() => {\n      doc.documentElement.removeEventListener('wheel', onWheel)\n    })\n  }\n\n  protected hookSwipe() {\n    const disposeSwipeLeft = this.events.on('swipeLeft', async () => {\n      await this.player.prevPage(1, true)\n    })\n    const disposeSwipeRight = this.events.on('swipeRight', async () => {\n      await this.player.nextPage(1, true)\n    })\n    this.unmount.on(() => {\n      disposeSwipeLeft()\n      disposeSwipeRight()\n    })\n  }\n\n  protected hookVerticalWheel() {\n    const doc = this.doc\n    const scrollElement = this.doc?.scrollingElement\n    if (!doc || !scrollElement) return\n\n    const onWheel = (e: WheelEvent) => {\n      eventBan(e)\n      if (isInputElement(e.target)) return\n      if (e.deltaY === 0) return\n      scrollElement.scrollLeft -= e.deltaY\n    }\n\n    doc.documentElement.addEventListener('wheel', onWheel)\n    this.unmount.on(() => {\n      doc.documentElement.removeEventListener('wheel', onWheel)\n    })\n  }\n\n  protected hookSelection() {\n    const win = this.win\n    const doc = this.doc\n    if (!win || !doc) return\n\n    doc.addEventListener('selectionchange', () => {\n      const boxSelector = `.${PARA_BOX_CLASS}`\n      const getSelectionPosRange = ():\n        | (BookTypes.PropertyRange & { paragraph: number })\n        | undefined => {\n        const sel = doc.getSelection()\n        if (!sel || sel.rangeCount <= 0) return\n        const range = sel.getRangeAt(0)\n        const selectedText = range.toString()\n        const length = selectedText.length\n        if (!length) return\n        const parent = range.commonAncestorContainer.parentElement\n        if (!parent) return\n        const elem = parent.matches(boxSelector)\n          ? parent\n          : parent.closest(boxSelector)\n        if (!elem) return\n        const paragraph = this.readableParts.findIndex(\n          (part) => part.elem === elem,\n        )\n        if (paragraph === -1) return\n        const preCaretRange = range.cloneRange()\n        preCaretRange.selectNodeContents(elem)\n        preCaretRange.setEnd(range.endContainer, range.endOffset)\n        const start = preCaretRange.toString().length - length\n        return { paragraph, start, end: start + length, selectedText }\n      }\n      const posRange = getSelectionPosRange()\n      if (posRange) {\n        this.states.pos = {\n          ...this.states.pos,\n          paragraph: posRange.paragraph,\n        }\n        this.states.selection = {\n          start: posRange.start,\n          end: posRange.end,\n          selectedText: posRange.selectedText,\n        }\n      } else {\n        this.states.selection = undefined\n      }\n    })\n\n    if (isMobile) {\n      const onBlur = () => {\n        doc.getSelection()?.removeAllRanges()\n      }\n      win.addEventListener('blur', onBlur)\n      this.unmount.on(() => {\n        win.removeEventListener('blur', onBlur)\n      })\n    }\n  }\n\n  protected hookScroll() {\n    const scrollElement = this.doc?.scrollingElement\n    if (!this.doc || !scrollElement) return\n\n    const onScroll = () => {\n      let percent: number\n      if (this.enabledPageList)\n        percent =\n          this.pageListScrollLeft /\n          (this.pageListScrollWidth - scrollElement.clientWidth)\n      else if (this.isVertical)\n        percent =\n          -scrollElement.scrollLeft /\n          (scrollElement.scrollWidth - scrollElement.clientWidth)\n      else\n        percent =\n          scrollElement.scrollTop /\n          (scrollElement.scrollHeight - scrollElement.clientHeight)\n\n      this.states.scrollPercent = percent * 100\n    }\n    onScroll()\n    const disposeScrollEvent = this.events.on('scroll', () => onScroll())\n\n    this.doc.addEventListener(\n      'scroll',\n      () => this.events.fire('scroll', null),\n      {\n        passive: true,\n      },\n    )\n\n    this.unmount.on(() => {\n      disposeScrollEvent()\n    })\n  }\n\n  protected hookALinks(doc: Document) {\n    for (const link of doc.querySelectorAll('a')) {\n      if (!link.href) continue\n\n      link.addEventListener('click', (e) => {\n        eventBan(e)\n        this.events.fire('click', link)\n      })\n    }\n  }\n\n  protected hookLinkClick() {\n    const confirmLink = async (href: string) => {\n      return await uiConfirm({\n        title: t('confirm.openLink'),\n        description: href,\n      })\n    }\n    const openLink = async (href: string) => {\n      if (await confirmLink(href))\n        window.open(href, '_blank', 'noopener,noreferrer')\n    }\n\n    const onClickLink = (link: HTMLAnchorElement) => {\n      async(async () => {\n        const isToc = link.closest(NAV_TOC_SELECTOR)\n        let uri: string\n        if (isToc) {\n          const href = link.getAttribute('href')\n          if (!href) return\n          uri = path.join('/', href)\n        } else {\n          const href = link.href\n          if (!href) return\n          if (!href.startsWith(this.mainContentRootUrl))\n            return await openLink(href)\n          uri = href.substring(this.mainContentRootUrl.length)\n        }\n        if (await confirmLink(uri)) {\n          await this.gotoUrlPath(uri)\n          this.player.utterer.cancel()\n        }\n      })\n    }\n    const disposeClick = this.events.on('click', onClickLink)\n    this.unmount.on(() => {\n      disposeClick()\n    })\n  }\n\n  protected hookImgs(doc: Document) {\n    for (const img of doc.querySelectorAll('img')) {\n      img.addEventListener('click', (event) => {\n        const src = img.src\n        if (!src) return\n        eventBan(event)\n        globalStore.set(previewImgSrcAtom, src)\n      })\n    }\n\n    for (const svg of doc.querySelectorAll('svg')) {\n      svg.addEventListener('click', (event) => {\n        eventBan(event)\n        async(async () => {\n          const dataURL = await svgToDataUri(svg, doc.URL)\n          globalStore.set(previewImgSrcAtom, dataURL)\n        })\n      })\n    }\n  }\n\n  protected hookParagraphClick() {\n    const win = this.win\n    const doc = this.doc\n    if (!win || !doc) return\n    const click = (e: Event, paraIndex: number) => {\n      eventBan(e)\n      void this.player.gotoParagraph(paraIndex, false)\n    }\n    const dblclick = (e: Event, paraIndex: number) => {\n      eventBan(e)\n      doc.getSelection()?.removeAllRanges()\n      void this.player.annotations.toggle(\n        {\n          section: this.states.pos.section,\n          paragraph: paraIndex,\n        },\n        null,\n      )\n    }\n    this.readableParts.forEach((n, i) => {\n      if (n.type === 'text') {\n        n.elem.addEventListener('click', (e) => click(e, i))\n        n.elem.addEventListener('dblclick', (e) => dblclick(e, i))\n      }\n    })\n  }\n\n  protected viewCalculate(doc: Document) {\n    const viewRect = doc.documentElement.getBoundingClientRect()\n    this.viewWidth = viewRect.width\n    this.viewOffsetWidth = viewRect.width + this.pageListGap\n    this.viewHeight = viewRect.height\n    // eslint-disable-next-line no-console\n    console.debug(`viewWidth: ${this.viewWidth}`)\n    // eslint-disable-next-line no-console\n    console.debug(`viewOffsetWidth: ${this.viewOffsetWidth}`)\n    // eslint-disable-next-line no-console\n    console.debug(`viewHeight: ${this.viewHeight}`)\n  }\n\n  protected pageListScrollWidthCalculate(\n    html: HTMLElement,\n    breakElem: HTMLElement | null,\n  ) {\n    let min = Infinity\n    let max = -Infinity\n    if (!this.readableParts.length) return html.scrollWidth\n    for (const elem of [\n      ...this.readableParts.map((part) => part.elem),\n      breakElem,\n    ]) {\n      if (!elem) continue\n      const rect = elem.getBoundingClientRect()\n      if (rect.left < min) min = rect.left\n      if (rect.right > max) max = rect.right\n    }\n    return max - min\n  }\n\n  protected async pageListCalculate(doc: Document) {\n    if (!this.viewWidth || !this.viewOffsetWidth) return\n\n    const html = doc.documentElement\n    const pageListType = this.pageListType()\n\n    // update column count\n    const columnCount = pageListType === 'single' ? 1 : 2\n    const columnWidth = (this.viewWidth - this.pageListGap) / columnCount\n    html.style.setProperty('--main-column-count', columnCount.toString())\n    html.style.setProperty('--main-column-width', `${columnWidth}px`)\n    this.pageListColumnWidth = columnWidth\n\n    this.pageListResizeImgs(doc, this.pageListColumnWidth)\n\n    this.pageListScrollWidth = this.pageListScrollWidthCalculate(html, null)\n\n    let pageCount: number\n    // update page list width\n    doc.querySelector(`.${COLUMN_BREAK_CLASS}`)?.remove()\n    if (pageListType === 'double') {\n      // fix column double last page\n      pageCount = Math.round(\n        (2 * this.pageListScrollWidth) / this.viewOffsetWidth,\n      )\n      if (pageCount % 2 === 1) {\n        // add empty page & update the scrollWidth\n        pageCount += 1\n        const p = doc.createElement('p')\n        p.classList.add(COLUMN_BREAK_CLASS)\n        doc.body.appendChild(p)\n        this.pageListScrollWidth = this.pageListScrollWidthCalculate(html, p)\n      }\n      pageCount /= 2\n    } else {\n      pageCount = Math.round(this.pageListScrollWidth / this.viewOffsetWidth)\n    }\n    if (pageCount < 1) pageCount = 1\n\n    this.pageListCount = pageCount\n    // eslint-disable-next-line no-console\n    console.debug(`pageListScrollWidth: ${this.pageListScrollWidth}`)\n    // eslint-disable-next-line no-console\n    console.debug(`pageListColumnWidth: ${this.pageListColumnWidth}`)\n    // eslint-disable-next-line no-console\n    console.debug(`pageListCount: ${this.pageListCount}`)\n\n    this.parsePageList(html)\n  }\n\n  protected pageListResizeImgs(doc: Document, columnWidth: number) {\n    if (!this.viewHeight) return\n    const imgs = doc.querySelectorAll('img')\n\n    const pageWHRate = columnWidth / this.viewHeight\n    for (const img of imgs) {\n      if (img.width > columnWidth || img.height > this.viewHeight)\n        img.classList.add(\n          img.naturalWidth / img.naturalHeight > pageWHRate\n            ? IMG_MAX_WIDTH_CLASS\n            : IMG_MAX_HEIGHT_CLASS,\n        )\n    }\n  }\n\n  protected parsePageList(html: HTMLElement) {\n    const viewOffsetWidth = this.viewOffsetWidth\n    if (!viewOffsetWidth) return\n    if (!this.pageListCount) return\n\n    this.pageList = range(0, this.pageListCount)\n      .map((i) => i * viewOffsetWidth)\n      .map((offsetLeft) => ({ offsetLeft }))\n\n    const parentLeft = html.getBoundingClientRect().left\n    for (const [paragraph, readablePart] of this.readableParts.entries()) {\n      const rect = readablePart.elem.getBoundingClientRect()\n      const offsetLeft =\n        rect.left + readablePart.elem.offsetWidth / 2 - parentLeft\n      const page = findLast(\n        this.pageList,\n        (page) => page.offsetLeft <= offsetLeft,\n      )\n      if (page && !page.topmost)\n        page.topmost = {\n          readablePart,\n          paragraph,\n        }\n    }\n  }\n\n  protected updatePageListCurFocus() {\n    if (!this.pageList) return\n\n    // update focus part\n    const paragraph = this.states.pos.paragraph\n    const pageListPosIndex = findLastIndex(\n      this.pageList,\n      (page) => !!page.topmost && page.topmost.paragraph <= paragraph,\n    )\n    if (pageListPosIndex === this.pageListCurIndex) {\n      // use the pos paragraph as resize focus\n      this.pageListResizeCurFocusPart = this.readableParts.at(paragraph)\n    } else {\n      // use pageListCurIndex as resize focus\n      this.pageListResizeCurFocusPart = this.pageList.at(\n        this.pageListCurIndex,\n      )?.topmost?.readablePart\n    }\n  }\n\n  #paragraphLastActive?: ReadablePart\n  protected updateParagraphActive() {\n    this.tryManipulateDOM(() => {\n      const item = this.readableParts.at(this.states.pos.paragraph)\n      if (\n        !item ||\n        (this.#paragraphLastActive && item === this.#paragraphLastActive)\n      )\n        return\n      this.#paragraphLastActive?.elem.classList.remove(PARA_ACTIVE_CLASS)\n      this.#paragraphLastActive = item\n      item.elem.classList.add(PARA_ACTIVE_CLASS)\n    }).catch(console.error)\n  }\n\n  protected updateAnnotations() {\n    this.tryManipulateDOM(() => {\n      if (!this.states.annotations || !this.doc) return\n      for (const item of Array.from(\n        this.doc.querySelectorAll(`.${PARA_ANNOTATION_CLASS}`),\n      )) {\n        item.classList.remove(PARA_ANNOTATION_CLASS)\n      }\n      const hlBlocks: HighlightBlock[] = []\n      for (const annotation of this.states.annotations) {\n        if (annotation.pos.section !== this.states.pos.section) continue\n        const node = this.readableParts.at(annotation.pos.paragraph)\n        if (!node) continue\n        if (!annotation.range) {\n          node.elem.classList.add(PARA_ANNOTATION_CLASS)\n          continue\n        }\n        hlBlocks.push({\n          node,\n          charIndex: annotation.range.start,\n          charLength: annotation.range.end - annotation.range.start,\n          color: 'var(--main-bg-blue)',\n        })\n      }\n      this.annotationHl.highlight(hlBlocks, false)\n    }).catch(console.error)\n  }\n\n  protected updateKeywords() {\n    this.tryManipulateDOM(() => {\n      if (!this.states.keywords || !this.doc) return\n      const hlBlocks: HighlightBlock[] = []\n      for (const keyword of this.states.keywords) {\n        const nodes = this.readableParts.filter((p) => p.type === 'text')\n        if (!nodes.length) continue\n        for (const node of nodes) {\n          const matches = keywordMatches(node.text, keyword)\n          if (!matches.length) continue\n          for (const [startIdx, length] of matches) {\n            hlBlocks.push({\n              node,\n              charIndex: startIdx,\n              charLength: length,\n              color: 'var(--main-bg-blue)',\n            })\n          }\n        }\n      }\n      this.keywordHl.highlight(hlBlocks, false)\n    }).catch(console.error)\n  }\n\n  protected updateActiveNavs() {\n    interface RequiredNav extends BookNav {\n      spineIndex: number\n    }\n\n    // same spineIndex navs\n    const navs = this.book.flattenedNavs.filter(\n      (nav): nav is RequiredNav => nav.spineIndex === this.states.pos.section,\n    )\n\n    const findNav = (): BookNav | undefined => {\n      // get last nav of less than spineIndex\n      if (navs.length === 0) {\n        const lastNav = findLast(\n          this.book.flattenedNavs,\n          (nav) => !!nav.spineIndex && nav.spineIndex < this.states.pos.section,\n        )\n        return lastNav\n      }\n\n      // last anchor from iframe page\n      const readableParts = this.readableParts\n      const lastAnchors = findLast(\n        readableParts.slice(0, this.states.pos.paragraph + 1),\n        (part) => !!part.navAnchorIds,\n      )?.navAnchorIds\n      const lastAnchor =\n        lastAnchors && lastAnchors.length > 0\n          ? lastAnchors[lastAnchors.length - 1]\n          : null\n\n      // no anchor in iframe\n      if (!lastAnchor) {\n        return navs[0]\n      }\n\n      // find last matched anchor nav\n      const matchedNav = findLast(navs, (nav) => nav.hrefAnchor === lastAnchor)\n\n      // no matched nav by last anchor\n      if (!matchedNav) {\n        return navs[0]\n      }\n\n      return matchedNav\n    }\n\n    const matchedNav = findNav()\n    if (!matchedNav) {\n      this.states.activeNavs = []\n      return\n    }\n    const matchedNavIndex = this.book.flattenedNavs.indexOf(matchedNav)\n    if (matchedNavIndex === -1) {\n      this.states.activeNavs = []\n      return\n    }\n\n    // find all parent navs\n    const matchedNavs: BookNav[] = [matchedNav]\n    let index = matchedNavIndex - 1\n    let level = matchedNav.level - 1\n    while (index >= 0 && level > 0) {\n      const [nav, newIndex] = findLastPair(\n        this.book.flattenedNavs,\n        (nav) => nav.level === level,\n        index,\n      )\n      if (nav) {\n        index = newIndex - 1\n        level = nav.level - 1\n        matchedNavs.unshift(nav)\n      } else {\n        break\n      }\n    }\n    this.states.activeNavs = matchedNavs\n  }\n}\n\nexport function usePlayerIframe(player: Player) {\n  useMountEffect(async () => {\n    // first load page\n    await player.iframeCtrler.load()\n  })\n}\n","import { t } from 'i18next'\nimport invert from 'invert-color'\nimport { booksKeywordsDeleteRouter } from '../../../../core/api/books/keywords-delete.js'\nimport { booksKeywordsUpsertRouter } from '../../../../core/api/books/keywords-upsert.js'\nimport type { BookTypes } from '../../../../core/book/types.js'\nimport { uiConfirm } from '../../../common/confirm.js'\nimport { messageApi } from '../../../common/notification.js'\nimport type { Player } from './player.js'\n\nexport class PlayerKeywords {\n  /** book uuid */\n  uuid: string\n  reload?: () => void\n\n  constructor(public readonly player: Player) {\n    this.uuid = player.book.item.uuid\n  }\n\n  private getBriefText(pos: BookTypes.PropertyPosition) {\n    const node = this.player.iframeCtrler.readableParts.at(pos.paragraph)\n    if (!node) return\n    if (node.type !== 'text') {\n      void messageApi().error(t('desc.keywordNoSupported'))\n      return null\n    }\n    const brief = node.text.slice(0, 30)\n    return {\n      text: node.text,\n      brief,\n    }\n  }\n\n  async add({\n    keyword,\n    pos,\n  }: {\n    keyword: string\n    pos: BookTypes.PropertyPosition\n  }) {\n    const text = this.getBriefText(pos)\n    if (!text) return\n    const res = await booksKeywordsUpsertRouter.action({\n      keywords: [\n        {\n          keyword,\n          uuid: null,\n          pos,\n          brief: text.brief,\n          content: text.text,\n        },\n      ],\n      uuid: this.uuid,\n    })\n    this.reload?.()\n    void messageApi().info(`${t('desc.keywordUpdated')} ${keyword}`)\n    return res.keywords.at(0)\n  }\n\n  async upsert(\n    {\n      uuid,\n      keyword,\n      pos,\n    }: {\n      uuid: string | null\n      keyword: string\n      pos: BookTypes.PropertyPosition\n    },\n    {\n      alias,\n      note,\n      color,\n    }: {\n      alias?: string[]\n      note?: string\n      color?: string\n    },\n  ): Promise<undefined | BookTypes.PropertyKeyword> {\n    const text = this.getBriefText(pos)\n    if (!text) return\n    const res = await booksKeywordsUpsertRouter.action({\n      keywords: [\n        {\n          uuid,\n          keyword,\n          pos,\n          brief: text.brief,\n          content: text.text,\n          alias,\n          note,\n          color,\n        },\n      ],\n      uuid: this.uuid,\n    })\n    this.reload?.()\n    void messageApi().info(`${t('desc.keywordUpdated')} ${keyword}`)\n    return res.keywords.at(0)\n  }\n\n  async remove(keyword: BookTypes.PropertyKeyword) {\n    const fgColor = keyword.color\n      ? invert(keyword.color, {\n          black: '#3a3a3a',\n          white: '#fafafa',\n        })\n      : 'var(--main-fg-blue)'\n    if (\n      !(await uiConfirm({\n        title: t('prompt.keywordRemoveConfirm'),\n        description: (\n          <span\n            style={{\n              backgroundColor: keyword.color ?? 'var(--main-bg-blue)',\n              color: fgColor,\n            }}\n          >\n            {keyword.keyword}\n          </span>\n        ),\n      }))\n    )\n      return\n\n    await booksKeywordsDeleteRouter.action({\n      uuid: this.uuid,\n      keywordUuids: [keyword.uuid],\n    })\n    this.reload?.()\n    void messageApi().info(`${t('desc.keywordDeleted')} ${keyword.keyword}`)\n  }\n}\n","import type { Dispatch } from 'react'\nimport { useEffect, useMemo } from 'react'\nimport type { BookNav } from '../../../../core/book/book-base.js'\nimport type { BookTypes } from '../../../../core/book/types.js'\nimport { isMobile } from '../../../../core/util/browser.js'\nimport { ChangedEmitter } from '../../../../core/util/emitter.js'\nimport type { PageListType } from '../../../store.js'\nimport type { Player } from './player.js'\n\ntype PlayerStates = {\n  started: boolean\n  pos: BookTypes.PropertyPosition\n  activeNavs: BookNav[]\n  loading: boolean\n  scrollPercent: number | undefined\n  selection: BookTypes.PropertyRange | undefined\n}\n\ntype PlayerReadonlyStates = {\n  annotations: BookTypes.PropertyAnnotation[] | undefined\n  keywords: BookTypes.PropertyKeyword[] | undefined\n  isPersonReplace: boolean\n  speechSpeed: number\n  voice: null | SpeechSynthesisVoice\n  autoNextSection: boolean\n  paragraphRepeat: number\n  pageList: PageListType\n  fontSize: number\n  disabledVertical: boolean\n}\n\nexport class PlayerStatesManager {\n  #states: PlayerStates = {\n    started: false,\n    pos: { section: 0, paragraph: 0 },\n    activeNavs: [],\n    loading: false,\n    scrollPercent: undefined,\n    selection: undefined,\n  }\n\n  events = new ChangedEmitter<PlayerStates>()\n\n  get started() {\n    return this.#states.started\n  }\n\n  set started(started: boolean) {\n    this.#states.started = started\n    this.events.fire('started', started)\n  }\n\n  get pos() {\n    return this.#states.pos\n  }\n\n  set pos(pos: BookTypes.PropertyPosition) {\n    this.#states.pos = pos\n    this.events.fire('pos', pos)\n  }\n\n  set activeNavs(activeNavs: BookNav[]) {\n    this.#states.activeNavs = activeNavs\n    this.events.fire('activeNavs', activeNavs)\n  }\n\n  get loading() {\n    return this.#states.loading\n  }\n\n  set loading(loading: boolean) {\n    this.#states.loading = loading\n    this.events.fire('loading', loading)\n  }\n\n  get scrollPercent() {\n    return this.#states.scrollPercent\n  }\n\n  set scrollPercent(scrollPercent: number | undefined) {\n    this.#states.scrollPercent = scrollPercent\n    this.events.fire('scrollPercent', scrollPercent)\n  }\n\n  get selection() {\n    return this.#states.selection\n  }\n\n  set selection(selection: BookTypes.PropertyRange | undefined) {\n    this.#states.selection = selection\n    this.events.fire('selection', selection)\n  }\n\n  #readonlyStates: PlayerReadonlyStates = {\n    annotations: [],\n    keywords: [],\n    isPersonReplace: false,\n    speechSpeed: 1,\n    voice: null,\n    autoNextSection: false,\n    paragraphRepeat: 1,\n    pageList: 'double',\n    fontSize: 16,\n    disabledVertical: false,\n  }\n\n  uiEvents = new ChangedEmitter<PlayerReadonlyStates>()\n\n  get annotations() {\n    return this.#readonlyStates.annotations\n  }\n\n  get keywords() {\n    return this.#readonlyStates.keywords\n  }\n\n  get voice() {\n    return this.#readonlyStates.voice\n  }\n\n  get isPersonReplace() {\n    return this.#readonlyStates.isPersonReplace\n  }\n\n  get speechSpeed() {\n    return this.#readonlyStates.speechSpeed\n  }\n\n  get autoNextSection() {\n    return this.#readonlyStates.autoNextSection\n  }\n\n  get paragraphRepeat() {\n    return this.#readonlyStates.paragraphRepeat\n  }\n\n  get pageList() {\n    return this.#readonlyStates.pageList\n  }\n\n  get fontSize() {\n    return this.#readonlyStates.fontSize\n  }\n\n  get disabledVertical() {\n    return this.#readonlyStates.disabledVertical\n  }\n\n  get docVisible() {\n    return document.visibilityState === 'visible'\n  }\n\n  get canManipulateDOM() {\n    return this.docVisible || !isMobile\n  }\n\n  syncUIState<K extends keyof PlayerReadonlyStates>(\n    name: K,\n    state: PlayerReadonlyStates[K],\n  ) {\n    this.#readonlyStates[name] = state\n    this.uiEvents.fire(name, state)\n  }\n}\n\nexport function usePlayerSync(\n  player: Player,\n  {\n    setPos,\n    setStarted,\n    setActiveNavs,\n    setLoading,\n    setScrollPercent,\n    setSelection,\n  }: {\n    setPos: Dispatch<BookTypes.PropertyPosition>\n    setStarted: Dispatch<boolean>\n    setActiveNavs: Dispatch<BookNav[]>\n    setLoading: Dispatch<boolean>\n    setScrollPercent: Dispatch<number | undefined>\n    setSelection: Dispatch<BookTypes.PropertyRange | undefined>\n  },\n) {\n  useEffect(() => {\n    const events = player.states.events\n    const disposes = [\n      events.on('pos', (pos) => {\n        setPos(pos)\n      }),\n      events.on('started', (started) => {\n        setStarted(started)\n      }),\n      events.on('activeNavs', (activeNavs) => {\n        setActiveNavs(activeNavs)\n      }),\n      events.on('loading', (loading) => {\n        setLoading(loading)\n      }),\n      events.on('scrollPercent', (scrollPercent) => {\n        setScrollPercent(scrollPercent)\n      }),\n      events.on('selection', (selection) => {\n        setSelection(selection)\n      }),\n    ]\n    return () => {\n      disposes.forEach((dispose) => dispose())\n    }\n  }, [\n    player,\n    setPos,\n    setStarted,\n    setActiveNavs,\n    setLoading,\n    setScrollPercent,\n    setSelection,\n  ])\n}\n\nexport function usePlayerUISync(\n  player: Player,\n  {\n    annotations,\n    keywords,\n    isPersonReplace,\n    speechSpeed,\n    voice,\n    autoNextSection,\n    paragraphRepeat,\n    pageList,\n    fontSize,\n    disabledVertical,\n  }: PlayerReadonlyStates,\n) {\n  useEffect(() => {\n    player.states.syncUIState('annotations', annotations)\n  }, [player, annotations])\n\n  useEffect(() => {\n    player.states.syncUIState('keywords', keywords)\n  }, [player, keywords])\n\n  useEffect(() => {\n    player.states.syncUIState('isPersonReplace', isPersonReplace)\n  }, [player, isPersonReplace])\n\n  useEffect(() => {\n    player.states.syncUIState('speechSpeed', speechSpeed)\n  }, [player, speechSpeed])\n\n  useEffect(() => {\n    player.states.syncUIState('voice', voice)\n  }, [player, voice])\n\n  useEffect(() => {\n    player.states.syncUIState('autoNextSection', autoNextSection)\n  }, [player, autoNextSection])\n\n  useEffect(() => {\n    player.states.syncUIState('paragraphRepeat', paragraphRepeat)\n  }, [player, paragraphRepeat])\n\n  useEffect(() => {\n    player.states.syncUIState('pageList', pageList)\n  }, [player, pageList])\n\n  useEffect(() => {\n    player.states.syncUIState('fontSize', fontSize)\n  }, [player, fontSize])\n\n  useEffect(() => {\n    player.states.syncUIState('disabledVertical', disabledVertical)\n  }, [player, disabledVertical])\n\n  const isFirstSection = useMemo(\n    () => player.isFirstSection,\n    [player.isFirstSection],\n  )\n  const isLastSection = useMemo(\n    () => player.isLastSection,\n    [player.isLastSection],\n  )\n  const isFirstParagraph = useMemo(\n    () => player.isFirstParagraph,\n    [player.isFirstParagraph],\n  )\n  const isLastParagraph = useMemo(\n    () => player.isLastParagraph,\n    [player.isLastParagraph],\n  )\n\n  return { isFirstSection, isLastSection, isFirstParagraph, isLastParagraph }\n}\n","import {\n  faBackward,\n  faBackwardFast,\n  faBookBookmark,\n  faBookmark,\n  faDownLeftAndUpRightToCenter,\n  faFileLines,\n  faFloppyDisk,\n  faFolderTree,\n  faForward,\n  faForwardFast,\n  faPause,\n  faPlay,\n  faQuoteRight,\n  faUpRightAndDownLeftFromCenter,\n} from '@fortawesome/free-solid-svg-icons'\nimport { Button, Popover, Select, Space, Tag } from 'antd'\nimport { t } from 'i18next'\nimport { useEffect, useMemo, useRef, useState } from 'react'\nimport { useNavigate } from 'react-router-dom'\nimport { booksTmpStoreRouter } from '../../../../core/api/books/tmp-store.js'\nimport type { BookNav } from '../../../../core/book/book-base.js'\nimport type { BookTypes } from '../../../../core/book/types.js'\nimport { filterOptionLabel } from '../../../../core/util/antd.js'\nimport { isMobile } from '../../../../core/util/browser.js'\nimport { async } from '../../../../core/util/promise.js'\nimport { Icon } from '../../../components/icon.js'\nimport {\n  useAutoSection,\n  useDisabledVertical,\n  useFontSize,\n  usePageList,\n  useParagraphRepeat,\n  usePersonReplace,\n  useSpeechSpeed,\n  useStopTimer,\n  useStopTimerSeconds,\n  useVoice,\n} from '../../../store.js'\nimport { SettingLine } from '../../layout/settings.js'\nimport { useAppBarSync } from '../../layout/use-app-bar.js'\nimport { useBookEditDialog } from '../edit.js'\nimport { useBookContext } from '../view.context.js'\nimport { BookSearchButton } from './book-search.js'\nimport { useBookPanel } from './panel/panel.js'\nimport type { Player } from './player'\nimport { usePlayerUISync } from './player-states.js'\nimport { useHotkeys } from '../../../hotkey/hotkey-state.js'\n\nfunction ControlButton(props: {\n  disabled?: boolean\n  onClick: React.MouseEventHandler | undefined\n  children: React.ReactNode\n}) {\n  return (\n    <Button\n      style={{ padding: '14px 4px' }}\n      size=\"small\"\n      type=\"primary\"\n      {...props}\n    ></Button>\n  )\n}\n\nfunction TooltipButton({\n  hotkey,\n  description,\n  ...btnProps\n}: {\n  hotkey?: string\n  description?: string\n  disabled?: boolean\n  onClick: React.MouseEventHandler | undefined\n  children: React.ReactNode\n}) {\n  const tooltip = useMemo(\n    () => (\n      <Space>\n        {description}\n        {hotkey ? <span className=\"keyboard\">{hotkey}</span> : null}\n      </Space>\n    ),\n    [description, hotkey],\n  )\n  return (\n    <Popover\n      style={{ pointerEvents: 'none' }}\n      content={isMobile ? null : tooltip}\n      placement=\"top\"\n    >\n      <ControlButton {...btnProps} />\n    </Popover>\n  )\n}\n\nfunction TimerRemainBadge({\n  started,\n  player,\n  stopTimerEnabled,\n  stopTimerSeconds,\n}: {\n  started: boolean\n  player: Player\n  stopTimerEnabled: boolean\n  stopTimerSeconds: number\n}) {\n  const refUsedSeconds = useRef<number>()\n  const [resetCount, setResetCount] = useState<number>(0)\n  const [remainSeconds, setRemainSeconds] = useState<number>(stopTimerSeconds)\n\n  // stop timer\n  useEffect(() => {\n    if (!started) return\n    if (!stopTimerEnabled) return\n    if (!resetCount) return setResetCount((c) => c + 1)\n\n    const usedSeconds = refUsedSeconds.current ?? 0\n\n    const startAt = Date.now() / 1000\n    let timer: NodeJS.Timeout | undefined = undefined\n    const fn = () => {\n      const used = Date.now() / 1000 - startAt + usedSeconds\n      refUsedSeconds.current = used\n      const remain = stopTimerSeconds - used\n      if (remain <= 0) {\n        player.pause()\n        refUsedSeconds.current = 0\n        if (timer) clearInterval(timer)\n        setRemainSeconds(0)\n        return\n      }\n      setRemainSeconds(remain)\n    }\n    fn()\n    timer = setInterval(fn, 1000)\n    return () => {\n      clearInterval(timer)\n    }\n  }, [resetCount, player, started, stopTimerEnabled, stopTimerSeconds])\n\n  const remainDisplay = useMemo(() => {\n    return `${Math.floor(remainSeconds / 60)\n      .toString()\n      .padStart(2, '0')}\n      :${(remainSeconds % 60).toFixed(0).padStart(2, '0')}`\n  }, [remainSeconds])\n\n  if (!stopTimerEnabled) return <></>\n\n  return (\n    <Tag\n      onClick={() => {\n        refUsedSeconds.current = 0\n        setResetCount((c) => c + 1)\n        setRemainSeconds(stopTimerSeconds)\n      }}\n    >\n      {remainDisplay}\n    </Tag>\n  )\n}\n\nfunction BookEditButton() {\n  const { book, reload } = useBookContext()\n  const { openBookEdit } = useBookEditDialog(reload)\n  const { addHotkey } = useHotkeys()\n\n  useEffect(() => {\n    return addHotkey(\n      'e',\n      t('hotkey.editBook'),\n      () => {\n        openBookEdit(book.item.uuid)\n      },\n      { level: 100 },\n    )\n  }, [addHotkey, book.item.uuid, openBookEdit])\n\n  return (\n    <Button block type=\"primary\" onClick={() => openBookEdit(book.item.uuid)}>\n      {t('editBook')}\n    </Button>\n  )\n}\n\nfunction VoicesSelect() {\n  const { book } = useBookContext()\n  const { voiceURI, setVoiceURI, allSortedVoices } = useVoice(book.item)\n  const voiceOptions = useMemo(\n    () =>\n      allSortedVoices.map((v) => ({\n        label: v.name,\n        value: v.voiceURI,\n      })),\n    [allSortedVoices],\n  )\n  return (\n    <SettingLine>\n      <Select\n        showSearch\n        filterOption={filterOptionLabel}\n        popupMatchSelectWidth={false}\n        style={{ width: '100%' }}\n        value={voiceURI}\n        onChange={(value) => setVoiceURI(value)}\n        options={voiceOptions}\n      ></Select>\n    </SettingLine>\n  )\n}\n\nexport function usePlayerUI({\n  player,\n  started,\n  activeNavs,\n  selection,\n}: {\n  started: boolean\n  player: Player\n  activeNavs?: BookNav[]\n  selection?: BookTypes.PropertyRange\n}) {\n  const { book, pos } = useBookContext()\n  const nav = useNavigate()\n  const { annotations, keywords, setViewPanelType, BookPanelView } =\n    useBookPanel(book, player, activeNavs, pos, selection)\n  const { voice } = useVoice(book.item)\n  const [autoNextSection] = useAutoSection()\n  const [isPersonReplace] = usePersonReplace()\n  const [stopTimerEnabled] = useStopTimer()\n  const [stopTimerSeconds] = useStopTimerSeconds()\n  const [speechSpeed] = useSpeechSpeed()\n  const [paragraphRepeat] = useParagraphRepeat()\n  const [pageList] = usePageList()\n  const [fontSize] = useFontSize()\n  const [disabledVertical] = useDisabledVertical()\n  const [collapsed, setCollapsed] = useState(isMobile)\n\n  const { isFirstSection, isLastSection, isFirstParagraph, isLastParagraph } =\n    usePlayerUISync(player, {\n      annotations,\n      keywords,\n      autoNextSection,\n      isPersonReplace,\n      speechSpeed,\n      voice,\n      paragraphRepeat,\n      pageList,\n      fontSize,\n      disabledVertical,\n    })\n\n  const PlayerCtrlGroup = useMemo(() => {\n    const buttons: (JSX.Element | null)[] = [\n      <TooltipButton\n        key=\"nav\"\n        hotkey=\"t\"\n        description={t('nav')}\n        onClick={() => {\n          setViewPanelType((v) => (v === 'nav' ? 'none' : 'nav'))\n        }}\n      >\n        <Icon icon={faFolderTree} />\n      </TooltipButton>,\n      annotations && annotations.length > 0 ? (\n        <TooltipButton\n          key=\"annotations\"\n          hotkey=\"m\"\n          description={t('annotation')}\n          onClick={() => {\n            setViewPanelType((v) =>\n              v === 'annotation' ? 'none' : 'annotation',\n            )\n          }}\n        >\n          <Icon icon={faBookBookmark} />\n        </TooltipButton>\n      ) : null,\n      <TooltipButton\n        key=\"annotation\"\n        description={t('hotkey.annotationToggle')}\n        hotkey=\"b\"\n        onClick={() => {\n          void player.annotations.toggle(pos, selection ?? null)\n        }}\n      >\n        <Icon icon={faBookmark} />\n      </TooltipButton>,\n      keywords && keywords.length > 0 ? (\n        <TooltipButton\n          key=\"keywords\"\n          description={t('keyword')}\n          hotkey=\"M\"\n          onClick={() => {\n            setViewPanelType((v) => (v === 'keyword' ? 'none' : 'keyword'))\n          }}\n        >\n          <Icon icon={faFileLines} />\n        </TooltipButton>\n      ) : null,\n      selection?.selectedText ? (\n        <TooltipButton\n          key=\"keyword\"\n          description={t('hotkey.keywordAdd')}\n          hotkey=\"B\"\n          onClick={() => {\n            void player.keywords.add({ pos, keyword: selection.selectedText })\n          }}\n        >\n          <Icon icon={faQuoteRight} />\n        </TooltipButton>\n      ) : null,\n    ]\n\n    if (!collapsed)\n      buttons.push(\n        <TooltipButton\n          key=\"prev-section\"\n          hotkey=\"shift + ←\"\n          description={t('hotkey.prevSection')}\n          disabled={isFirstSection}\n          onClick={() => {\n            player.prevSection().catch(console.error)\n          }}\n        >\n          <Icon icon={faBackwardFast} />\n        </TooltipButton>,\n        <TooltipButton\n          key=\"prev-paragraph\"\n          hotkey=\"↑\"\n          description={t('hotkey.prevParagraph')}\n          disabled={isFirstSection && isFirstParagraph}\n          onClick={() => {\n            player.prevParagraph().catch(console.error)\n          }}\n        >\n          <Icon icon={faBackward} />\n        </TooltipButton>,\n      )\n\n    buttons.push(\n      <TooltipButton\n        key=\"play\"\n        hotkey=\"Space\"\n        description={t('hotkey.playToggle')}\n        onClick={() => {\n          if (started) player.pause()\n          else player.start()\n        }}\n      >\n        {started ? <Icon icon={faPause} /> : <Icon icon={faPlay} />}\n      </TooltipButton>,\n    )\n\n    if (!collapsed)\n      buttons.push(\n        <TooltipButton\n          key=\"next-paragraph\"\n          hotkey=\"↓\"\n          description={t('hotkey.nextParagraph')}\n          disabled={isLastSection && isLastParagraph}\n          onClick={() => {\n            player.nextParagraph().catch(console.error)\n          }}\n        >\n          <Icon icon={faForward} />\n        </TooltipButton>,\n        <TooltipButton\n          key=\"next-section\"\n          hotkey=\"shift + →\"\n          description={t('hotkey.nextSection')}\n          disabled={isLastSection}\n          onClick={() => {\n            player.nextSection().catch(console.error)\n          }}\n        >\n          <Icon icon={faForwardFast} />\n        </TooltipButton>,\n      )\n\n    if (isMobile)\n      buttons.push(\n        <ControlButton\n          key=\"collapse\"\n          onClick={() => {\n            setCollapsed((c) => !c)\n          }}\n        >\n          {collapsed ? (\n            <Icon icon={faUpRightAndDownLeftFromCenter} />\n          ) : (\n            <Icon icon={faDownLeftAndUpRightToCenter} />\n          )}\n        </ControlButton>,\n      )\n\n    return <Button.Group>{buttons.filter(Boolean)}</Button.Group>\n  }, [\n    annotations,\n    collapsed,\n    isFirstParagraph,\n    isFirstSection,\n    isLastParagraph,\n    isLastSection,\n    keywords,\n    player,\n    pos,\n    selection,\n    setViewPanelType,\n    started,\n  ])\n\n  const TimerRemainUI = useMemo(() => {\n    return (\n      <TimerRemainBadge\n        key=\"timer-remain-ui\"\n        player={player}\n        started={started}\n        stopTimerEnabled={stopTimerEnabled}\n        stopTimerSeconds={stopTimerSeconds}\n      ></TimerRemainBadge>\n    )\n  }, [player, started, stopTimerEnabled, stopTimerSeconds])\n\n  const TmpStoreBtn = useMemo(() => {\n    return (\n      <Button\n        shape=\"circle\"\n        type=\"text\"\n        title={t('tmpStore')}\n        onClick={() => {\n          async(async () => {\n            const entity = await booksTmpStoreRouter.action({})\n            nav(`/books/added-successful/${entity.uuid}`)\n          })\n        }}\n        icon={<Icon icon={faFloppyDisk} />}\n      ></Button>\n    )\n  }, [nav])\n\n  const topRight = useMemo(() => {\n    return <>{TimerRemainUI}</>\n  }, [TimerRemainUI])\n\n  const bottomLeft = useMemo(() => {\n    return <>{PlayerCtrlGroup}</>\n  }, [PlayerCtrlGroup])\n\n  const bottomRight = useMemo(() => {\n    return <>{book.item.isTmp && TmpStoreBtn}</>\n  }, [TmpStoreBtn, book.item.isTmp])\n\n  const appSettings = useMemo(() => {\n    return (\n      <Space direction=\"vertical\">\n        <BookSearchButton player={player} />\n        <BookEditButton />\n        <VoicesSelect />\n      </Space>\n    )\n  }, [player])\n\n  useAppBarSync({\n    topRight,\n    bottomLeft,\n    bottomRight,\n    settings: appSettings,\n  })\n\n  return {\n    voice,\n    speechSpeed,\n    autoNextSection,\n    isPersonReplace,\n    BookPanelView,\n  }\n}\n","import { useUnmountEffect } from '@react-hookz/web'\nimport type { RefObject } from 'react'\nimport { useRef } from 'react'\nimport type { BookView } from '../../../../core/book/book-base.js'\nimport type { BookTypes } from '../../../../core/book/types.js'\nimport { SingleEmitter } from '../../../../core/util/emitter.js'\nimport { async } from '../../../../core/util/promise.js'\nimport { PlayerAnnotations } from './player-annotations.js'\nimport {\n  PlayerIframeController,\n  usePlayerIframe,\n} from './player-iframe-controller.js'\nimport { PlayerStatesManager } from './player-states.js'\nimport { Utterer } from './utterer.js'\nimport { PlayerKeywords } from './player-keywords.js'\n\nexport class Player {\n  states: PlayerStatesManager\n  utterer: Utterer\n  iframeCtrler: PlayerIframeController\n  annotations: PlayerAnnotations\n  keywords: PlayerKeywords\n  unmount = new SingleEmitter<void>({ once: true })\n\n  constructor(\n    public book: BookView,\n    initPos: BookTypes.PropertyPosition,\n    iframeRef: RefObject<HTMLIFrameElement>,\n  ) {\n    this.states = new PlayerStatesManager()\n    this.states.pos = initPos\n    this.iframeCtrler = new PlayerIframeController(this, this.states, iframeRef)\n    this.utterer = new Utterer(this, this.states, this.iframeCtrler)\n    this.annotations = new PlayerAnnotations(this)\n    this.keywords = new PlayerKeywords(this)\n\n    const onVisibilityChange = () => {\n      // TODO\n      // if (document.visibilityState === 'visible') this.reload()\n      async(async () => {\n        // wakeLock\n        let lock: WakeLockSentinel | undefined\n        await lock?.release().catch(console.error)\n        lock = undefined\n        if (this.states.started && this.states.docVisible) {\n          lock = await navigator.wakeLock.request('screen')\n        }\n      })\n    }\n    onVisibilityChange()\n    document.addEventListener('visibilitychange', onVisibilityChange)\n    const startedDispose = this.states.events.on('started', onVisibilityChange)\n    this.unmount.on(() => {\n      document.removeEventListener('visibilitychange', onVisibilityChange)\n      startedDispose()\n    })\n  }\n\n  start() {\n    this.states.started = true\n    this.utterer.startLoop().catch(console.error)\n  }\n\n  pause() {\n    this.states.started = false\n    this.utterer.cancel()\n  }\n\n  restart(delay?: number) {\n    this.pause()\n    if (delay)\n      setTimeout(() => {\n        this.start()\n      }, delay)\n    else this.start()\n  }\n\n  toggle() {\n    if (this.states.started) this.pause()\n    else this.start()\n  }\n\n  get isFirstSection() {\n    return this.states.pos.section === 0\n  }\n\n  get isLastSection() {\n    return this.states.pos.section === this.book.spines.length - 1\n  }\n\n  async gotoPos({\n    section,\n    paragraph,\n    scrollToParagraph = true,\n    animated = true,\n  }: {\n    section?: number\n    paragraph?: number\n    scrollToParagraph?: boolean\n    animated?: boolean\n  }) {\n    if (\n      section !== undefined &&\n      (section < 0 || section >= this.book.spines.length)\n    )\n      return\n\n    section ??= this.states.pos.section\n    paragraph ??= this.states.pos.paragraph\n\n    if (this.states.pos.section === section) {\n      // Same section\n\n      if (this.states.pos.paragraph === paragraph)\n        // Skip when same position\n        return\n\n      this.states.pos = {\n        section,\n        paragraph,\n      }\n      if (scrollToParagraph)\n        await this.iframeCtrler.scrollToCurParagraph(animated)\n    } else {\n      // Change section\n      await this.iframeCtrler.load({\n        section,\n        paragraph,\n        animated,\n      })\n    }\n\n    this.utterer.cancel()\n  }\n\n  async gotoSection(section: number, paragraph: number) {\n    await this.gotoPos({ section, paragraph })\n  }\n\n  async prevSection(paragraph = 0) {\n    await this.gotoPos({\n      section: this.states.pos.section - 1,\n      paragraph,\n      animated: false,\n    })\n  }\n\n  async nextSection(paragraph = 0) {\n    await this.gotoPos({\n      section: this.states.pos.section + 1,\n      paragraph,\n      animated: false,\n    })\n  }\n\n  async gotoUrlPath(urlPath: string) {\n    await this.iframeCtrler.gotoUrlPath(urlPath)\n    this.utterer.cancel()\n  }\n\n  get isFirstPage() {\n    return this.iframeCtrler.isFirstPageList\n  }\n\n  get isLastPage() {\n    return this.iframeCtrler.isLastPageList\n  }\n\n  async gotoPage(pageIndex: number, jump: boolean) {\n    await this.iframeCtrler.pageListScrollToPage(pageIndex, jump)\n  }\n\n  async prevPage(count: number, jump: boolean) {\n    await this.iframeCtrler.pageListPushAdjust(-count, jump)\n  }\n\n  async nextPage(count: number, jump: boolean) {\n    await this.iframeCtrler.pageListPushAdjust(count, jump)\n  }\n\n  get isFirstParagraph() {\n    return this.states.pos.paragraph <= 0\n  }\n\n  get isLastParagraph() {\n    return (\n      this.states.pos.paragraph >= this.iframeCtrler.readableParts.length - 1\n    )\n  }\n\n  async gotoParagraph(paragraph: number, scrollToParagraph = true) {\n    await this.gotoPos({ paragraph, scrollToParagraph })\n  }\n\n  async prevParagraph(scrollToParagraph = true) {\n    if (this.states.pos.paragraph === 0) await this.prevSection(-1)\n    else\n      await this.gotoParagraph(this.states.pos.paragraph - 1, scrollToParagraph)\n  }\n\n  async nextParagraph(scrollToParagraph = true) {\n    if (this.states.pos.paragraph >= this.iframeCtrler.readableParts.length - 1)\n      await this.nextSection()\n    else\n      await this.gotoParagraph(this.states.pos.paragraph + 1, scrollToParagraph)\n  }\n}\n\nexport function useCreatePlayer(\n  book: BookView,\n  pos: BookTypes.PropertyPosition,\n  iframeRef: RefObject<HTMLIFrameElement>,\n) {\n  const player = useRef<Player>()\n  if (!player.current) {\n    player.current = new Player(book, pos, iframeRef)\n  }\n  useUnmountEffect(() => {\n    player.current?.unmount.fire()\n  })\n  usePlayerIframe(player.current)\n  return player.current\n}\n","import type { Player } from './player.js'\n\nexport function ViewProgressBar({\n  player,\n  scrollPercent,\n}: {\n  player: Player\n  scrollPercent: number | undefined\n}) {\n  const progress = scrollPercent?.toFixed(2) ?? '0'\n\n  return (\n    <div\n      style={{\n        height: 8,\n        width: '100%',\n        overflow: 'hidden',\n        borderRadius: 8,\n        background: 'var(--main-bg-active)',\n      }}\n      onClick={(event) => {\n        const rect = event.currentTarget.getBoundingClientRect()\n        const percent = (event.clientX - rect.left) / rect.width\n        player.iframeCtrler.scrollToPercent(percent, true).catch(console.error)\n      }}\n      title={`${progress}%`}\n    >\n      <div\n        style={{\n          transition: 'width 0.2s',\n          width: `${progress}%`,\n          height: '100%',\n          background: 'var(--main-fg-active)',\n        }}\n      ></div>\n    </div>\n  )\n}\n","import { Howl } from 'howler'\nimport keyboardURL from './sound/keyboard.mp3'\nimport rainLoopURL from './sound/rain-loop.mp3'\nimport nextPageURL from './sound/next-page.mp3'\nimport shutterURL from './sound/shutter.mp3'\nimport rewindURL from './sound/rewind.mp3'\n\nconst shutterSound = new Howl({\n  src: [shutterURL],\n})\nexport async function shutterPlay() {\n  shutterSound.play()\n  await new Promise((resolve) => {\n    shutterSound.once('end', resolve)\n  })\n}\n\nconst pressEnterSound = new Howl({\n  src: [keyboardURL],\n})\n\nexport async function pressEnterPlay() {\n  pressEnterSound.play()\n  await new Promise((resolve) => {\n    pressEnterSound.once('end', resolve)\n  })\n}\n\nconst nextPageSound = new Howl({\n  src: [nextPageURL],\n})\n\nexport async function nextPagePlay() {\n  nextPageSound.play()\n  await new Promise((resolve) => {\n    nextPageSound.once('end', resolve)\n  })\n}\n\nconst rainSound = new Howl({\n  src: [rainLoopURL],\n})\nrainSound.loop(true)\nrainSound.fade(0, 0.5, 500)\n\nexport function rainStart() {\n  if (!rainSound.playing()) {\n    rainSound.play()\n  }\n}\n\nexport function rainStop() {\n  if (rainSound.playing()) {\n    rainSound.pause()\n  }\n}\n\nconst rewindSound = new Howl({\n  src: [rewindURL],\n  volume: 0.5,\n})\n\nexport async function rewindPlay() {\n  rewindSound.play()\n  await new Promise((resolve) => {\n    rewindSound.once('end', resolve)\n  })\n}\n","import type { ReadablePartText } from '../../../../core/util/readable.js'\nimport { Speech, type SpeakResult } from '../../../../core/util/speech.js'\nimport type { Player } from './player'\nimport type { PlayerIframeController } from './player-iframe-controller.js'\nimport type { PlayerStatesManager } from './player-states'\nimport {\n  nextPagePlay,\n  pressEnterPlay,\n  rewindPlay,\n  shutterPlay,\n} from './sound.js'\nimport { UttererHighlight } from './highlight/utterer-highlight.js'\n\nconst speakRetriedMax = 3\n\nexport class Utterer {\n  hl: UttererHighlight\n  states: PlayerStatesManager\n  speech: Speech\n\n  constructor(\n    public player: Player,\n    states: PlayerStatesManager,\n    iframeCtrler: PlayerIframeController,\n  ) {\n    this.states = states\n    this.hl = new UttererHighlight(iframeCtrler, states)\n\n    this.speech = new Speech()\n  }\n\n  cancel() {\n    this.speech.cancel()\n  }\n\n  async speakNode(node: ReadablePartText): Promise<SpeakResult> {\n    if (!this.states.voice) return 'done'\n\n    return this.speech.speak(node.text, {\n      voice: this.states.voice,\n      speed: this.states.speechSpeed,\n      isPersonReplace: this.states.isPersonReplace,\n      alias: this.player.iframeCtrler.alias,\n      onBoundary: (event) => {\n        this.hl.highlight(\n          [\n            {\n              node,\n              charIndex: event.charIndex,\n              charLength: event.charLength,\n            },\n          ],\n          true,\n        )\n      },\n    })\n  }\n\n  async speakText(text: string): Promise<SpeakResult> {\n    if (!this.states.voice) return 'done'\n\n    return this.speech.speak(text, {\n      voice: this.states.voice,\n      speed: this.states.speechSpeed,\n      isPersonReplace: this.states.isPersonReplace,\n      alias: this.player.iframeCtrler.alias,\n    })\n  }\n\n  private async nextPart() {\n    // end of section\n    if (\n      this.states.pos.paragraph >=\n      this.player.iframeCtrler.readableParts.length - 1\n    ) {\n      // next section\n      if (\n        this.states.pos.section < this.player.book.spines.length - 1 &&\n        this.states.autoNextSection\n      ) {\n        await this.player.nextSection()\n        await nextPagePlay()\n      }\n      // stop\n      else {\n        this.player.pause()\n      }\n    } else {\n      // next paragraph\n      await this.player.nextParagraph()\n      await pressEnterPlay()\n    }\n  }\n\n  async startLoop() {\n    let retriedCount = 0\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, no-constant-condition\n    while (true) {\n      if (!this.states.started) return\n      try {\n        const node = this.player.iframeCtrler.readableParts.at(\n          this.states.pos.paragraph,\n        )\n        if (node) {\n          switch (node.type) {\n            case 'text': {\n              let isCancel = false\n              for (let i = 0; i < this.states.paragraphRepeat; i++) {\n                const ret = await this.speakNode(node)\n                if (ret === 'cancel') {\n                  isCancel = true\n                  break\n                } else if (i !== this.states.paragraphRepeat - 1) {\n                  await rewindPlay()\n                }\n              }\n              // May pause, jumps to other paragraphs, leave page.\n              // Continue is necessary, when the user jumps to other paragraphs\n              if (isCancel) continue\n              break\n            }\n            case 'image': {\n              await shutterPlay()\n              break\n            }\n          }\n        }\n\n        await this.nextPart()\n      } catch (err) {\n        console.error(err)\n        retriedCount += 1\n        if (retriedCount > speakRetriedMax) {\n          await this.nextPart()\n          retriedCount = 0\n        }\n      }\n    }\n  }\n}\n","import { useUnmountEffect } from '@react-hookz/web'\nimport { t } from 'i18next'\nimport { useEffect, useMemo, useRef, useState } from 'react'\nimport { useNavigate } from 'react-router-dom'\nimport type { BookNav } from '../../../../core/book/book-base.js'\nimport type { BookTypes } from '../../../../core/book/types.js'\nimport { FlexBox } from '../../../components/flex-box.js'\nimport { SpinCenter } from '../../../components/spin.js'\nimport { useHotkeys } from '../../../hotkey/hotkey-state.js'\nimport { useViewPanelType } from '../../../store.js'\nimport { useColorScheme } from '../../../theme.js'\nimport { useBookContext } from '../view.context.js'\nimport { usePlayerSync } from './player-states.js'\nimport { usePlayerUI } from './player-ui.js'\nimport { useCreatePlayer } from './player.js'\nimport { ViewProgressBar } from './progress-bar.js'\n\nexport function useViewer() {\n  const { book, pos, setPos } = useBookContext()\n  const iframeRef = useRef<HTMLIFrameElement>(null)\n  const [started, setStarted] = useState(false)\n  const [activeNavs, setActiveNavs] = useState<BookNav[]>()\n  const [loading, setLoading] = useState<boolean>(false)\n  const [scrollPercent, setScrollPercent] = useState<number | undefined>()\n  const [selection, setSelection] = useState<\n    BookTypes.PropertyRange | undefined\n  >()\n  const { addHotkeys } = useHotkeys()\n  const [, setViewPanelType] = useViewPanelType()\n  const nav = useNavigate()\n\n  const player = useCreatePlayer(book, pos, iframeRef)\n  usePlayerSync(player, {\n    setPos,\n    setStarted,\n    setActiveNavs,\n    setLoading,\n    setScrollPercent,\n    setSelection,\n  })\n\n  // dark scheme\n  const theme = useColorScheme()\n  useEffect(() => {\n    player.iframeCtrler.updateColorTheme(theme)\n  }, [player.iframeCtrler, theme])\n\n  const { BookPanelView } = usePlayerUI({\n    player,\n    started,\n    activeNavs,\n    selection,\n  })\n\n  const MainContent = useMemo(\n    () => (\n      <FlexBox flex={1} style={{ position: 'relative' }}>\n        {loading && (\n          <div\n            style={{\n              position: 'absolute',\n              zIndex: 2,\n              width: '100%',\n              display: 'flex',\n              justifyContent: 'center',\n            }}\n          >\n            <SpinCenter />\n          </div>\n        )}\n        {/* NOTE: sandbox will caused safari onclick not work in iframe */}\n        <iframe\n          style={{ padding: '0 4px' }}\n          title=\"viewer\"\n          ref={iframeRef}\n        ></iframe>\n        <ViewProgressBar\n          player={player}\n          scrollPercent={scrollPercent}\n        ></ViewProgressBar>\n      </FlexBox>\n    ),\n    [loading, scrollPercent, player],\n  )\n\n  // hotkey\n  useEffect(() => {\n    const jumpPrevPage = () => player.prevPage(1, true)\n    const jumpNextPage = () => player.nextPage(1, true)\n    const firstPage = () => player.gotoPage(0, true)\n    const lastPage = () => player.gotoPage(-1, true)\n    const prevPage = () => player.prevPage(1, false)\n    const nextPage = () => player.nextPage(1, false)\n    const prevSection = () => player.prevSection()\n    const nextSection = () => player.nextSection()\n    const firstParagraph = () => player.gotoParagraph(0)\n    const lastParagraph = () => player.gotoParagraph(-1)\n    const prevParagraph = () => player.prevParagraph()\n    const nextParagraph = () => player.nextParagraph()\n\n    return addHotkeys([\n      // panel\n      [\n        't',\n        t('hotkey.navToggle'),\n        () => setViewPanelType((v) => (v === 'nav' ? 'none' : 'nav')),\n      ],\n      [\n        'm',\n        t('hotkey.annotationsPanelToggle'),\n        () =>\n          setViewPanelType((v) => (v === 'annotation' ? 'none' : 'annotation')),\n      ],\n      [\n        'b',\n        t('hotkey.annotationToggle'),\n        () => player.annotations.toggle(pos, selection ?? null),\n      ],\n      [\n        { shift: true, key: 'm' },\n        t('hotkey.keywordPanelToggle'),\n        () => setViewPanelType((v) => (v === 'keyword' ? 'none' : 'keyword')),\n      ],\n      [\n        { shift: true, key: 'b' },\n        t('hotkey.keywordAdd'),\n        () =>\n          selection?.selectedText &&\n          player.keywords.add({ pos, keyword: selection.selectedText }),\n      ],\n\n      // navigation\n      ['u', t('hotkey.goBack'), () => nav('../')],\n\n      // play\n      [' ', t('hotkey.playToggle'), () => player.toggle()],\n      [{ shift: true, key: 'h' }, t('hotkey.prevSection'), prevSection],\n      [{ shift: true, key: 'l' }, t('hotkey.nextSection'), nextSection],\n      [{ shift: true, key: 'ArrowLeft' }, t('hotkey.prevSection'), prevSection],\n      [\n        { shift: true, key: 'ArrowRight' },\n        t('hotkey.nextSection'),\n        nextSection,\n      ],\n      ['h', t('hotkey.jumpPrevPage'), jumpPrevPage],\n      ['l', t('hotkey.jumpNextPage'), jumpNextPage],\n      ['k', t('hotkey.prevParagraph'), prevParagraph],\n      ['j', t('hotkey.nextParagraph'), nextParagraph],\n      ['ArrowLeft', t('hotkey.jumpPrevPage'), jumpPrevPage],\n      ['ArrowRight', t('hotkey.jumpNextPage'), jumpNextPage],\n      ['ArrowUp', t('hotkey.prevParagraph'), prevParagraph],\n      ['ArrowDown', t('hotkey.nextParagraph'), nextParagraph],\n      ['Home', t('hotkey.firstPage'), firstPage],\n      ['End', t('hotkey.lastPage'), lastPage],\n      ['PageUp', t('hotkey.prevPage'), prevPage],\n      ['PageDown', t('hotkey.nextPage'), nextPage],\n      [['g', 'g'], t('hotkey.firstParagraph'), firstParagraph],\n      [{ shift: true, key: 'G' }, t('hotkey.lastParagraph'), lastParagraph],\n    ])\n  }, [addHotkeys, book, nav, player, pos, selection, setViewPanelType])\n\n  // leave\n  useUnmountEffect(() => {\n    player.pause()\n  })\n\n  return {\n    activeNavs,\n    BookPanelView,\n    MainContent,\n  }\n}\n","import { useEffect } from 'react'\nimport {\n  HashRouter,\n  Navigate,\n  Route,\n  Routes,\n  useNavigate,\n} from 'react-router-dom'\nimport { userRouter } from '../../core/api/user.js'\nimport { useAction } from '../../core/route/action.js'\nimport { useHotkeys } from '../hotkey/hotkey-state.js'\nimport { useFontSize, useSpeechSpeed } from '../store.js'\nimport { BooksEntry } from './books/entry.js'\nimport { Layout } from './layout/layout.js'\nimport { Login } from './login.js'\nimport { NotFound } from './not-found.js'\nimport { useHintText } from '../common/hint-text.js'\nimport { t } from 'i18next'\n\nfunction Books() {\n  const { data: user } = useAction(userRouter, null)\n  const nav = useNavigate()\n  useEffect(() => {\n    if (user && !user.info) {\n      nav('/login')\n    }\n  }, [nav, user])\n\n  return (\n    <Layout>\n      <BooksEntry />\n    </Layout>\n  )\n}\n\nfunction Main() {\n  const [, setSpeechSpeed] = useSpeechSpeed()\n  const [, setFontSize] = useFontSize()\n  const { addHotkeys } = useHotkeys()\n  const { openHint } = useHintText()\n\n  // hotkey\n  useEffect(() => {\n    return addHotkeys([\n      [\n        '[',\n        t('hotkey.speedDown'),\n        () =>\n          setSpeechSpeed((v) => {\n            const n = (v * 10 - 1) / 10\n            openHint(`${t('speed')}: ${n}`)\n            return n\n          }),\n      ],\n      [\n        ']',\n        t('hotkey.speedUp'),\n        () =>\n          setSpeechSpeed((v) => {\n            const n = (v * 10 + 1) / 10\n            openHint(`${t('speed')}: ${n}`)\n            return n\n          }),\n      ],\n      [\n        '-',\n        t('hotkey.fontSizeDown'),\n        () =>\n          setFontSize((v) => {\n            const n = v - 1\n            openHint(`${t('fontSize')}: ${n}`)\n            return n\n          }),\n      ],\n      [\n        '=',\n        t('hotkey.fontSizeUp'),\n        () =>\n          setFontSize((v) => {\n            const n = v + 1\n            openHint(`${t('fontSize')}: ${n}`)\n            return n\n          }),\n      ],\n      [\n        'r',\n        t('hotkey.reload'),\n        () => {\n          location.reload()\n        },\n      ],\n    ])\n  }, [addHotkeys, openHint, setFontSize, setSpeechSpeed])\n\n  return (\n    <Routes>\n      <Route path=\"/login\" element={<Login />}></Route>\n      <Route path=\"/books/*\" element={<Books></Books>}></Route>\n      <Route path=\"/\" element={<Navigate to=\"/books\" />}></Route>\n      <Route\n        path=\"*\"\n        element={\n          <Layout>\n            <NotFound title=\"page\"></NotFound>\n          </Layout>\n        }\n      ></Route>\n    </Routes>\n  )\n}\n\nexport function RootEntry() {\n  return (\n    <HashRouter>\n      <Main></Main>\n    </HashRouter>\n  )\n}\n","import { faClose } from '@fortawesome/free-solid-svg-icons'\nimport { Button, Form, Typography } from 'antd'\nimport { t } from 'i18next'\nimport path from '@file-services/path'\nimport { useEffect, useState } from 'react'\nimport { useNavigate } from 'react-router-dom'\nimport { booksCreateByUrlRouter } from '../../../core/api/books/create-by-url.js'\nimport { booksCreateRouter } from '../../../core/api/books/create.js'\nimport { booksFetchUrlInfoRouter } from '../../../core/api/books/fetch-url-info.js'\nimport { BookEpub } from '../../../core/book/book-epub.js'\nimport { TMP_UUID } from '../../../core/consts.js'\nimport type { LangCode } from '../../../core/lang.js'\nimport { parseLangCode } from '../../../core/lang.js'\nimport { arrayBufferToBase64 } from '../../../core/util/converter.js'\nimport { eventBan } from '../../../core/util/dom.js'\nimport { async } from '../../../core/util/promise.js'\nimport { isUrl } from '../../../core/util/url.js'\nimport { FlexBox } from '../../components/flex-box.js'\nimport { Icon } from '../../components/icon.js'\nimport { LanguageSelect } from '../../components/language-select.js'\nimport { SpinFullscreen } from '../../components/spin.js'\n\ntype DragItem = DragItemUrl | DragItemEpub | DragItemText\n\ntype DragItemUrl = {\n  type: 'url'\n  title: string\n  langCode?: LangCode\n  url: string\n}\n\ntype DragItemEpub = {\n  type: 'file-epub'\n  title: string\n  langCode?: LangCode\n  bufferBase64: string\n}\n\ntype DragItemText = {\n  type: 'file-text'\n  title: string\n  langCode?: LangCode\n  bufferBase64: string\n}\n\nfunction hasFileOrUrl(event: React.DragEvent<HTMLDivElement>) {\n  const items = filterFileOrUrl(event)\n  return !!items.length\n}\n\nfunction filterFileOrUrl(event: React.DragEvent<HTMLDivElement>) {\n  const items = [...event.dataTransfer.items]\n  return items.filter((it) => {\n    if (it.kind === 'file') return true\n    if (it.kind === 'string' && it.type === 'text/uri-list') return true\n    return false\n  })\n}\n\nexport function DragFile({ children }: { children: React.ReactNode }) {\n  const [dragOver, setDragOver] = useState(0)\n  const [dragItem, setDragItem] = useState<DragItem | null>(null)\n  const [isInputLangCode, setIsInputLangCode] = useState(false)\n  const [loading, setLoading] = useState(false)\n  const nav = useNavigate()\n\n  useEffect(() => {\n    async(async () => {\n      if (!dragItem) return\n      if (!dragItem.langCode) {\n        setIsInputLangCode(true)\n        return\n      }\n      setLoading(true)\n      switch (dragItem.type) {\n        case 'file-epub':\n          await booksCreateRouter.action({\n            bufferBase64: dragItem.bufferBase64,\n            langCode: dragItem.langCode,\n            name: dragItem.title,\n            type: 'epub',\n            isTmp: true,\n          })\n          break\n        case 'file-text':\n          await booksCreateRouter.action({\n            bufferBase64: dragItem.bufferBase64,\n            langCode: dragItem.langCode,\n            name: dragItem.title,\n            type: 'text',\n            isTmp: true,\n          })\n          break\n        case 'url':\n          await booksCreateByUrlRouter.action({\n            url: dragItem.url,\n            langCode: dragItem.langCode,\n            name: dragItem.title,\n            isTmp: true,\n          })\n          break\n      }\n      setLoading(false)\n      setDragItem(null)\n      nav(`/books/view/${TMP_UUID}`)\n    })\n  }, [dragItem, nav])\n\n  if (loading) return <SpinFullscreen />\n\n  return (\n    <FlexBox\n      style={{\n        width: '100%',\n        height: '100%',\n        position: 'relative',\n      }}\n      gap={0}\n      onDragEnter={(event) => {\n        if (!hasFileOrUrl(event)) return\n        setDragOver((c) => c + 1)\n      }}\n      onDragLeave={(event) => {\n        if (!hasFileOrUrl(event)) return\n        setDragOver((c) => c - 1)\n      }}\n      onDragOver={(event) => {\n        eventBan(event)\n      }}\n      onDrop={(event) => {\n        event.preventDefault()\n        async(async () => {\n          setDragOver(0)\n          setLoading(true)\n          try {\n            for (const item of filterFileOrUrl(event)) {\n              if (item.kind === 'file') {\n                const file = item.getAsFile()\n                if (!file) continue\n                const buf = await file.arrayBuffer()\n                const epub = await BookEpub.read(buf)\n                if (!epub) continue\n                const langCode = parseLangCode(epub.language)\n                const ext = path.extname(file.name)\n                const basename = path.basename(file.name, ext)\n                const bufferBase64 = arrayBufferToBase64(buf)\n                if (ext === '.epub')\n                  return setDragItem({\n                    bufferBase64,\n                    title: epub.title ?? basename,\n                    type: 'file-epub',\n                    langCode,\n                  })\n                else if (ext === '.txt' || ext === '.text')\n                  return setDragItem({\n                    bufferBase64,\n                    title: basename,\n                    type: 'file-text',\n                    langCode,\n                  })\n              } else if (item.kind === 'string') {\n                const url = await new Promise<string>((resolve) => {\n                  item.getAsString(resolve)\n                })\n                if (!isUrl(url)) continue\n                const info = await booksFetchUrlInfoRouter.action({ url })\n                return setDragItem({\n                  type: 'url',\n                  url,\n                  title: info.title,\n                  langCode: info.lang,\n                })\n              }\n            }\n          } finally {\n            setLoading(false)\n          }\n        })\n      }}\n    >\n      {!!dragOver && (\n        <FlexBox\n          style={{\n            width: '100%',\n            height: '100%',\n            position: 'absolute',\n            justifyContent: 'center',\n            alignItems: 'center',\n            zIndex: 1,\n            backgroundColor: 'var(--main-bg)',\n          }}\n        >\n          {t('prompt.dropHere')}\n        </FlexBox>\n      )}\n      {isInputLangCode && (\n        <div\n          style={{\n            width: '100%',\n            height: '100%',\n            position: 'absolute',\n            zIndex: 2,\n            backgroundColor: 'var(--main-bg)',\n            padding: 40,\n          }}\n        >\n          <FlexBox dir=\"row\">\n            <Typography style={{ flex: 1 }}>\n              {t('prompt.selectLanguage')}\n            </Typography>\n            <Button\n              shape=\"circle\"\n              type=\"text\"\n              onClick={() => {\n                setDragItem(null)\n                setIsInputLangCode(false)\n              }}\n              icon={<Icon icon={faClose} />}\n            ></Button>\n          </FlexBox>\n          <Form.Item label={t('language')} name=\"langCode\" required>\n            <LanguageSelect\n              onChange={(value) => {\n                if (!dragItem || !value) return\n                setDragItem({ ...dragItem, langCode: value as LangCode })\n                setIsInputLangCode(false)\n              }}\n            ></LanguageSelect>\n          </Form.Item>\n        </div>\n      )}\n      {children}\n    </FlexBox>\n  )\n}\n","import { faBook, faGear } from '@fortawesome/free-solid-svg-icons'\nimport { Button, Drawer, Modal, Typography } from 'antd'\nimport { t } from 'i18next'\nimport { useAtom } from 'jotai'\nimport { useState } from 'react'\nimport { useNavigate } from 'react-router-dom'\nimport { logoutRouter } from '../../../core/api/logout.js'\nimport { env } from '../../../core/env.js'\nimport { FlexBox } from '../../components/flex-box.js'\nimport { Icon } from '../../components/icon.js'\nimport { LinkWrap } from '../../components/link-wrap.js'\nimport { defaultTitle, useTitle } from '../../hooks/use-title.js'\nimport { DragFile } from './drag-file.js'\nimport styles from './layout.module.scss'\nimport { GlobalSettings, SettingLine } from './settings.js'\nimport { appBarStatesAtom } from './use-app-bar.js'\n\nexport const Layout = ({ children }: { children?: React.ReactNode }) => {\n  const title = useTitle() ?? defaultTitle\n  const [appBarStates] = useAtom(appBarStatesAtom)\n  const [showSettings, setShowSettings] = useState(false)\n  const nav = useNavigate()\n  const [openedBookTitle, setOpenedBookTitle] = useState(false)\n\n  const appBar = (\n    <FlexBox\n      className={[styles.appBar, 'top'].join(' ')}\n      dir=\"row\"\n      style={{\n        justifyContent: 'end',\n      }}\n      gap={4}\n    >\n      <FlexBox\n        dir=\"row\"\n        style={{\n          overflow: 'hidden',\n          alignItems: 'center',\n        }}\n        gap={4}\n      >\n        <LinkWrap to=\"/books\">\n          {(href) => (\n            <Button type=\"link\" size=\"small\" href={href}>\n              <Icon size=\"2xl\" icon={faBook} />\n            </Button>\n          )}\n        </LinkWrap>\n        <Typography\n          style={{\n            flex: 1,\n            whiteSpace: 'nowrap',\n            overflow: 'hidden',\n            textOverflow: 'ellipsis',\n            cursor: 'pointer',\n          }}\n          title={title}\n          onClick={() => {\n            setOpenedBookTitle(true)\n          }}\n        >\n          {title}\n        </Typography>\n        <Modal\n          title={t('bookName')}\n          open={openedBookTitle}\n          footer={false}\n          onCancel={() => setOpenedBookTitle(false)}\n        >\n          <Typography>{title}</Typography>\n        </Modal>\n      </FlexBox>\n      <FlexBox dir=\"row\" style={{ alignItems: 'center', flex: 1 }} gap={4}>\n        {appBarStates.topLeft}\n      </FlexBox>\n      <FlexBox dir=\"row\" style={{ alignItems: 'center' }} gap={4}>\n        {appBarStates.topRight}\n      </FlexBox>\n    </FlexBox>\n  )\n\n  const appBarBottom = (\n    <FlexBox\n      className={[styles.appBar, 'bottom'].join(' ')}\n      dir=\"row\"\n      style={{\n        flexWrap: 'wrap',\n        justifyContent: 'end',\n      }}\n      gap={4}\n    >\n      <FlexBox\n        dir=\"row\"\n        style={{\n          alignItems: 'center',\n          flex: 1,\n        }}\n        gap={4}\n      >\n        {appBarStates.bottomLeft}\n      </FlexBox>\n      <FlexBox dir=\"row\" style={{ alignItems: 'center' }} gap={4}>\n        {appBarStates.bottomRight}\n        <FlexBox dir=\"row\" style={{ alignItems: 'center' }} gap={4}>\n          <Button\n            shape=\"circle\"\n            type=\"text\"\n            onClick={() => {\n              setShowSettings((v) => !v)\n            }}\n            icon={<Icon icon={faGear} />}\n          ></Button>\n          <Drawer\n            placement=\"right\"\n            open={showSettings}\n            onClose={() => setShowSettings(false)}\n            title={t('setting.title')}\n            forceRender\n          >\n            <FlexBox style={{ flex: 1, minWidth: 300, gap: 6 }}>\n              <FlexBox style={{ flex: 1, gap: 6 }}>\n                {appBarStates.settings}\n                <GlobalSettings></GlobalSettings>\n              </FlexBox>\n              <FlexBox>\n                {env.appMode === 'server' && (\n                  <SettingLine>\n                    <Button\n                      type=\"primary\"\n                      block\n                      onClick={() => {\n                        logoutRouter\n                          .action()\n                          .then(() => {\n                            nav('/')\n                          })\n                          .catch(console.error)\n                      }}\n                    >\n                      {t('logout')}\n                    </Button>\n                  </SettingLine>\n                )}\n              </FlexBox>\n            </FlexBox>\n          </Drawer>\n        </FlexBox>\n      </FlexBox>\n    </FlexBox>\n  )\n\n  return (\n    <DragFile>\n      <FlexBox\n        style={{\n          width: '100%',\n          height: '100%',\n          alignContent: 'space-around',\n          justifyContent: 'space-around',\n        }}\n      >\n        {appBar}\n        <div\n          style={{\n            flex: 1,\n            padding: 8,\n            overflow: 'hidden',\n            overflowY: 'auto',\n          }}\n        >\n          {children}\n        </div>\n        {appBarBottom}\n      </FlexBox>\n    </DragFile>\n  )\n}\n","import {\n  faArrowRight,\n  faQuestionCircle,\n} from '@fortawesome/free-solid-svg-icons'\nimport { Checkbox, List, Popover, Radio, Slider, Space, Typography } from 'antd'\nimport { t } from 'i18next'\nimport { ZH_PERSON_RULES } from '../../../core/consts.js'\nimport { FlexBox } from '../../components/flex-box.js'\nimport { Icon } from '../../components/icon.js'\nimport { RInputNumber } from '../../components/input-number.js'\nimport {\n  SPLIT_PAGE_TYPES,\n  USER_COLOR_SCHEMES,\n  useAutoSection,\n  useDisabledVertical,\n  useFontSize,\n  usePageList,\n  useParagraphRepeat,\n  usePersonReplace,\n  useSpeechSpeed,\n  useStopTimer,\n  useStopTimerSeconds,\n  useUserColorScheme,\n  type PageListType,\n  type UserColorscheme,\n} from '../../store.js'\n\nexport function SettingLine({ children }: { children: React.ReactNode }) {\n  return (\n    <FlexBox\n      dir=\"row\"\n      gap={8}\n      style={{\n        alignItems: 'center',\n        width: '100%',\n      }}\n    >\n      {children}\n    </FlexBox>\n  )\n}\n\nexport function SettingLabel({\n  style,\n  children,\n}: {\n  style?: React.CSSProperties\n  children: React.ReactNode\n}) {\n  return (\n    <Typography style={{ alignSelf: 'start', ...style }}>{children}</Typography>\n  )\n}\n\nconst AutoSectionCheckBox = () => {\n  const [autoNextSection, setAutoNextSection] = useAutoSection()\n  return (\n    <SettingLine>\n      <Checkbox\n        checked={autoNextSection}\n        onChange={(e) => setAutoNextSection(e.target.checked)}\n      >\n        {t('setting.autoNextSection')}\n      </Checkbox>\n    </SettingLine>\n  )\n}\n\nconst TimerInput = () => {\n  const [stopTimerEnabled, setStopTimerEnabled] = useStopTimer()\n  const [stopTimerSeconds, setStopTimerSeconds] = useStopTimerSeconds()\n  return (\n    <SettingLine>\n      <Checkbox\n        checked={stopTimerEnabled}\n        onChange={(e) => {\n          setStopTimerEnabled(e.target.checked)\n        }}\n      >\n        {t('setting.timer')}\n      </Checkbox>\n      <RInputNumber\n        style={{ width: '80px' }}\n        disabled={!stopTimerEnabled}\n        value={Math.floor(stopTimerSeconds / 60)}\n        onChange={(v) => {\n          if (v === null) return\n          setStopTimerSeconds(Math.floor(v * 60))\n        }}\n      ></RInputNumber>\n    </SettingLine>\n  )\n}\n\nfunction PersonReplaceCheckBox({\n  checked,\n  onChange,\n}: {\n  checked: boolean\n  onChange: (checked: boolean) => void\n}) {\n  return (\n    <>\n      <Checkbox\n        checked={checked}\n        onChange={(e) => {\n          onChange(e.target.checked)\n        }}\n      >\n        {t('setting.personReplace')}\n      </Checkbox>\n      <Popover\n        style={{ pointerEvents: 'none' }}\n        content={\n          <List>\n            {Object.entries(ZH_PERSON_RULES).map(([from, to], idx) => {\n              return (\n                <List.Item key={idx}>\n                  <Space>\n                    {from}\n                    <Icon icon={faArrowRight} />\n                    {to.word} ({to.pinyin})\n                  </Space>\n                </List.Item>\n              )\n            })}\n          </List>\n        }\n      >\n        <div>\n          <Icon size=\"lg\" icon={faQuestionCircle} />\n        </div>\n      </Popover>\n    </>\n  )\n}\n\nconst PersonReplaceUI = () => {\n  const [isPersonReplace, setIsPersonReplace] = usePersonReplace()\n\n  return (\n    <SettingLine>\n      <PersonReplaceCheckBox\n        checked={isPersonReplace}\n        onChange={(v) => {\n          setIsPersonReplace(v)\n        }}\n      ></PersonReplaceCheckBox>\n    </SettingLine>\n  )\n}\n\nfunction DisabledVerticalCheckbox() {\n  const [disabledVertical, setDisabledVertical] = useDisabledVertical()\n  return (\n    <SettingLine>\n      <Checkbox\n        checked={disabledVertical}\n        onChange={(e) => {\n          setDisabledVertical(e.target.checked)\n        }}\n      >\n        {t('setting.disabledVertical')}\n      </Checkbox>\n    </SettingLine>\n  )\n}\n\nconst PlaySpeed = () => {\n  const [speechSpeed, setSpeechSpeed] = useSpeechSpeed()\n  return (\n    <SettingLine>\n      <SettingLabel>{t('setting.speed')}</SettingLabel>\n      <FlexBox style={{ flex: 1 }}>\n        <Slider\n          value={speechSpeed}\n          onChange={(v) => {\n            setSpeechSpeed(v)\n          }}\n          step={0.1}\n          min={0.1}\n          max={5.0}\n        ></Slider>\n        <RInputNumber\n          type=\"number\"\n          value={speechSpeed}\n          step={0.1}\n          onChange={(v) => {\n            if (v === null) return\n            setSpeechSpeed(v)\n          }}\n        ></RInputNumber>\n      </FlexBox>\n    </SettingLine>\n  )\n}\n\nconst ColorSchemeSelect = () => {\n  const [userColorScheme, setUserColorScheme] = useUserColorScheme()\n  return (\n    <>\n      <SettingLine>\n        <SettingLabel style={{ paddingTop: '4px' }}>\n          {t('setting.userColorScheme')}\n        </SettingLabel>\n        <Radio.Group\n          value={userColorScheme}\n          onChange={(e) => {\n            setUserColorScheme(e.target.value as UserColorscheme)\n          }}\n        >\n          <Space direction=\"vertical\">\n            {USER_COLOR_SCHEMES.map((value) => {\n              return (\n                <Radio key={value} value={value}>\n                  {t(value)}\n                </Radio>\n              )\n            })}\n          </Space>\n        </Radio.Group>\n      </SettingLine>\n    </>\n  )\n}\n\nconst ParagraphRepeatInput = () => {\n  const [paragraphRepeat, setParagraphRepeat] = useParagraphRepeat()\n  return (\n    <SettingLine>\n      <span>{t('setting.paragraphRepeat')}:</span>\n      <RInputNumber\n        style={{ width: 80 }}\n        value={paragraphRepeat}\n        onChange={(v) => {\n          if (!v) return\n          setParagraphRepeat(v < 1 ? 1 : Math.floor(v))\n        }}\n      ></RInputNumber>\n    </SettingLine>\n  )\n}\n\nfunction PageListCheckBox() {\n  const [pageList, setPageList] = usePageList()\n  return (\n    <SettingLine>\n      <SettingLabel style={{ paddingTop: '4px' }}>\n        {t('setting.pageList')}\n      </SettingLabel>\n      <Radio.Group\n        value={pageList}\n        onChange={(e) => {\n          setPageList(e.target.value as PageListType)\n        }}\n      >\n        <Space direction=\"vertical\">\n          {SPLIT_PAGE_TYPES.map((value) => {\n            return (\n              <Radio key={value} value={value}>\n                {t(`setting.pageListType.${value}`)}\n              </Radio>\n            )\n          })}\n        </Space>\n      </Radio.Group>\n    </SettingLine>\n  )\n}\n\nfunction FontSizeInput() {\n  const [fontSize, setFontSize] = useFontSize()\n  return (\n    <SettingLine>\n      <span>{t('setting.fontSize')}</span>\n      <RInputNumber\n        style={{ width: 80 }}\n        value={fontSize}\n        onChange={(v) => {\n          if (v === null) return\n          setFontSize(v < 1 ? 1 : Math.floor(v))\n        }}\n      ></RInputNumber>\n    </SettingLine>\n  )\n}\n\nexport const GlobalSettings = () => {\n  return (\n    <Space direction=\"vertical\">\n      <AutoSectionCheckBox></AutoSectionCheckBox>\n      <TimerInput></TimerInput>\n      <PersonReplaceUI></PersonReplaceUI>\n      <DisabledVerticalCheckbox></DisabledVerticalCheckbox>\n      <PlaySpeed></PlaySpeed>\n      <ColorSchemeSelect></ColorSchemeSelect>\n      <ParagraphRepeatInput></ParagraphRepeatInput>\n      <PageListCheckBox></PageListCheckBox>\n      <FontSizeInput></FontSizeInput>\n    </Space>\n  )\n}\n","import { useUnmountEffect } from '@react-hookz/web'\nimport { atom, useAtom } from 'jotai'\nimport { useEffect } from 'react'\n\nexport const appBarStatesAtom = atom<{\n  topLeft: React.ReactNode\n  topRight: React.ReactNode\n  settings: React.ReactNode\n  bottomLeft: React.ReactNode\n  bottomRight: React.ReactNode\n}>({\n  topLeft: null,\n  topRight: null,\n  settings: null,\n  bottomLeft: null,\n  bottomRight: null,\n})\n\nexport const useAppBarSync = ({\n  topLeft,\n  topRight,\n  settings,\n  bottomLeft,\n  bottomRight,\n}: {\n  topLeft?: React.ReactNode\n  topRight?: React.ReactNode\n  settings?: React.ReactNode\n  bottomLeft?: React.ReactNode\n  bottomRight?: React.ReactNode\n}) => {\n  const [, setAppBarStates] = useAtom(appBarStatesAtom)\n\n  useEffect(() => {\n    setAppBarStates({\n      topLeft,\n      topRight,\n      settings,\n      bottomLeft,\n      bottomRight,\n    })\n  }, [topLeft, topRight, settings, bottomLeft, bottomRight, setAppBarStates])\n\n  useUnmountEffect(() => {\n    setAppBarStates({\n      topLeft: null,\n      topRight: null,\n      settings: null,\n      bottomLeft: null,\n      bottomRight: null,\n    })\n  })\n}\n","import { Button, Form, Input } from 'antd'\nimport { t } from 'i18next'\nimport { useEffect, useState } from 'react'\nimport { useNavigate } from 'react-router-dom'\nimport { loginRouter } from '../../core/api/login.js'\nimport { userRouter } from '../../core/api/user.js'\nimport { useAction } from '../../core/route/action.js'\n\ntype Values = {\n  account: string\n  password: string\n}\n\nexport function Login() {\n  const nav = useNavigate()\n  const [error, setError] = useState<string>()\n  const { data: user } = useAction(userRouter, null)\n  const [form] = Form.useForm()\n\n  useEffect(() => {\n    if (user) {\n      if (user.info) {\n        nav('/')\n      }\n    }\n  }, [nav, user])\n\n  return (\n    <>\n      <div style={{ maxWidth: 300, margin: '50px auto 0' }}>\n        <h2>Auditory Reader</h2>\n        <h4>{t('login')}</h4>\n\n        <Form<Values>\n          form={form}\n          initialValues={{ account: '', password: '' }}\n          onFinish={(values) => {\n            loginRouter\n              .action(values)\n              .then(async (res) => {\n                if (res.ok) {\n                  nav('/')\n                } else {\n                  setError(t('error.login'))\n                }\n              })\n              .catch(console.error)\n          }}\n        >\n          <Form.Item\n            label={t('account')}\n            name=\"account\"\n            rules={[{ required: true }]}\n          >\n            <Input placeholder={t('prompt.inputAccount')}></Input>\n          </Form.Item>\n          <Form.Item\n            label={t('password')}\n            name=\"password\"\n            rules={[{ required: true }]}\n            validateStatus={error ? 'error' : undefined}\n            help={error}\n          >\n            <Input\n              type=\"password\"\n              placeholder={t('prompt.inputPassword')}\n            ></Input>\n          </Form.Item>\n          <Form.Item>\n            <Button type=\"primary\" block htmlType=\"submit\">\n              {t('submit')}\n            </Button>\n          </Form.Item>\n        </Form>\n      </div>\n    </>\n  )\n}\n","import { Alert } from 'antd'\nimport { t } from 'i18next'\nimport { useEffect } from 'react'\nimport { useNavigate } from 'react-router-dom'\nimport { useHotkeys } from '../hotkey/hotkey-state.js'\n\nexport function NotFound({ title }: { title: string }) {\n  const nav = useNavigate()\n  const { addHotkeys } = useHotkeys()\n\n  // hotkey\n  useEffect(() => {\n    return addHotkeys([['u', t('hotkey.goBack'), () => nav('../../')]])\n  }, [addHotkeys, nav])\n\n  return (\n    <Alert\n      type=\"error\"\n      message={`The ${title} not found`}\n      description={`The ${title} not found`}\n    ></Alert>\n  )\n}\n","import { env } from '../../core/env.js'\n\nasync function unregister() {\n  if (!('serviceWorker' in navigator)) return\n  const registrations = await navigator.serviceWorker.getRegistrations()\n  for (const registration of registrations) {\n    await registration.unregister()\n  }\n}\n\nexport async function registerAPI() {\n  if (env.appMode === 'server') {\n    await unregister()\n    return 'successful'\n  }\n  if (!('serviceWorker' in navigator)) {\n    // eslint-disable-next-line no-console\n    console.log('service-worker: unsupported')\n    return 'unsupported'\n  }\n  await unregister()\n  const service = await navigator.serviceWorker.register(\n    new URL('./api', import.meta.url),\n    {\n      scope: env.appPublicRoot,\n    },\n  )\n  await navigator.serviceWorker.ready\n  if (service.active) {\n    // eslint-disable-next-line no-console\n    console.log('service-worker: registered')\n    return 'successful'\n  }\n  return 'failed'\n}\n","import { atom, useAtom } from 'jotai'\nimport type { Dispatch, SetStateAction } from 'react'\nimport { useCallback, useMemo } from 'react'\nimport type { BookTypes } from '../core/book/types.js'\nimport { orderBy } from '../core/util/collection.js'\nimport { globalStore } from './store/global.js'\nimport { isBrowser } from '../core/util/browser.js'\n\nconst allVoicesAtom = atom<SpeechSynthesisVoice[]>([])\nif (isBrowser) {\n  const loadVoices = () => {\n    globalStore.set(allVoicesAtom, speechSynthesis.getVoices())\n  }\n  loadVoices()\n  if ('addEventListener' in window.speechSynthesis) {\n    window.speechSynthesis.addEventListener('voiceschanged', loadVoices)\n  }\n}\n\nfunction createStore<T>(options: {\n  storeKey: string\n  read: (value: string | null) => T\n  write: (value: T) => string | null\n}): () => [T, Dispatch<SetStateAction<T>>] {\n  const { storeKey, read, write } = options\n  const getOriginStoredValue = () => localStorage.getItem(storeKey)\n  const globalAtom = atom(read(getOriginStoredValue()))\n\n  return () => {\n    const [inner, setInner] = useAtom(globalAtom)\n    const setValue: Dispatch<SetStateAction<T>> = useCallback(\n      (getValue: SetStateAction<T>): void => {\n        let value: T\n        if (typeof getValue === 'function') {\n          value = (getValue as any)(inner)\n        } else {\n          value = getValue\n        }\n        setInner(value)\n        const writeValue = write(value)\n        if (writeValue) localStorage.setItem(storeKey, writeValue)\n        else localStorage.removeItem(storeKey)\n      },\n      [inner, setInner],\n    )\n    return [inner, setValue]\n  }\n}\n\nexport type ViewPanelType = 'none' | 'nav' | 'annotation' | 'keyword'\nconst limitViewPanelType = (v: string | null): ViewPanelType =>\n  v === 'nav' || v === 'annotation' || v === 'keyword' ? v : 'none'\n\nexport const useViewPanelType = createStore<ViewPanelType>({\n  storeKey: 'viewPanelType',\n  read: limitViewPanelType,\n  write: limitViewPanelType,\n})\n\n/**\n * Dict[book-lang] = voiceURI\n */\nconst useLangVoiceURIDict = createStore<Record<string, string>>({\n  storeKey: 'langVoiceURIDict',\n  read: (uriDictStr) => (uriDictStr ? JSON.parse(uriDictStr) : {}),\n  write: (uriDict) => JSON.stringify(uriDict),\n})\n\nexport const useGetVoice = () => {\n  const [dict] = useLangVoiceURIDict()\n  const [allVoices] = useAtom(allVoicesAtom)\n\n  const getAllSortedVoices = useCallback(\n    (book: BookTypes.Entity) => {\n      return orderBy(allVoices, 'desc', (v) => [\n        v.lang.startsWith(`${book.langCode}-`),\n        !v.localService,\n      ])\n    },\n    [allVoices],\n  )\n\n  const getVoice = useCallback(\n    (book: BookTypes.Entity) => {\n      const allSortedVoices = getAllSortedVoices(book)\n      const uri = dict[book.langCode]\n      const voice = uri ? allSortedVoices.find((v) => v.voiceURI === uri) : null\n      return voice ?? allSortedVoices.at(0) ?? null\n    },\n    [dict, getAllSortedVoices],\n  )\n\n  return { getVoice, getAllSortedVoices }\n}\n\nconst useLangVoiceURI = (book: BookTypes.Entity) => {\n  const [dict, setDict] = useLangVoiceURIDict()\n\n  const langURI = useMemo<string | null>(\n    () => dict[book.langCode] ?? null,\n    [book.langCode, dict],\n  )\n\n  const setLangURI = useCallback(\n    (langURI: string | null) => {\n      const newDict = { ...dict }\n      if (langURI) newDict[book.langCode] = langURI\n      else delete newDict[book.langCode]\n      setDict(newDict)\n    },\n    [book.langCode, dict, setDict],\n  )\n\n  return [langURI, setLangURI] as const\n}\n\nexport const useVoice = (book: BookTypes.Entity) => {\n  const [langVoiceURI, setLangVoiceURI] = useLangVoiceURI(book)\n  const { getAllSortedVoices, getVoice } = useGetVoice()\n\n  const allSortedVoices = useMemo(() => {\n    return getAllSortedVoices(book)\n  }, [book, getAllSortedVoices])\n\n  const voiceURI = useMemo((): string | null => {\n    return langVoiceURI ?? allSortedVoices[0]?.voiceURI ?? null\n  }, [allSortedVoices, langVoiceURI])\n\n  const setVoiceURI = useCallback(\n    (voiceURI: string | null) => {\n      setLangVoiceURI(voiceURI)\n    },\n    [setLangVoiceURI],\n  )\n\n  const voice = useMemo(() => {\n    return getVoice(book) ?? null\n  }, [book, getVoice])\n\n  const setVoice = useCallback(\n    (voice: SpeechSynthesisVoice | null) => {\n      setVoiceURI(voice?.voiceURI ?? null)\n    },\n    [setVoiceURI],\n  )\n\n  return { voiceURI, setVoiceURI, voice, setVoice, allSortedVoices }\n}\n\nexport const useAutoSection = createStore<boolean>({\n  storeKey: 'autoSection',\n  read: (v) => (v ? v === '1' : true),\n  write: (v) => (v ? '1' : '0'),\n})\n\nexport const useStopTimer = createStore<boolean>({\n  storeKey: 'stopTimer',\n  read: (v) => (v ? v === '1' : true),\n  write: (v) => (v ? '1' : '0'),\n})\n\nexport const useStopTimerSeconds = createStore<number>({\n  storeKey: 'stopTimerSeconds',\n  read: (v) => (v ? Number(v) : 30 * 60),\n  write: (v) => v.toString(),\n})\n\nexport const usePersonReplace = createStore<boolean>({\n  storeKey: 'personReplace',\n  read: (v) => (v ? v === '1' : false),\n  write: (v) => (v ? '1' : '0'),\n})\n\nexport const useSpeechSpeed = createStore<number>({\n  storeKey: 'speechSpeed',\n  read: (v) => (v ? Number(v) : 1),\n  write: (v) => v.toString(),\n})\n\nexport const COLOR_SCHEMES = ['dark', 'light'] as const\nexport type ColorScheme = (typeof COLOR_SCHEMES)[number]\nexport const USER_COLOR_SCHEMES = ['system', ...COLOR_SCHEMES] as const\nexport type UserColorscheme = (typeof USER_COLOR_SCHEMES)[number]\n\nexport const useUserColorScheme = createStore<UserColorscheme>({\n  storeKey: 'userColorScheme',\n  read: (v) => (v ?? 'system') as UserColorscheme,\n  write: (v) => v,\n})\n\nexport const useParagraphRepeat = createStore<number>({\n  storeKey: 'paragraphRepeat',\n  read: (v) => (v ? Number(v) : 1),\n  write: (v) => v.toString(),\n})\n\nexport const SPLIT_PAGE_TYPES = ['none', 'auto', 'single', 'double'] as const\nexport type PageListType = (typeof SPLIT_PAGE_TYPES)[number]\n\nexport const usePageList = createStore<PageListType>({\n  storeKey: 'pageList',\n  read: (v) =>\n    SPLIT_PAGE_TYPES.includes(v as PageListType) ? (v as PageListType) : 'auto',\n  write: (v) => v,\n})\n\nexport const useFontSize = createStore<number>({\n  storeKey: 'fontSize',\n  read: (v) => (v ? Math.min(Math.max(Number(v), 8), 30) : 16),\n  write: (v) => v.toString(),\n})\n\nexport const useDisabledVertical = createStore<boolean>({\n  storeKey: 'disabledVertical',\n  read: (v) => (v ? v === '1' : false),\n  write: (v) => (v ? '1' : '0'),\n})\n","import { COLOR_SCHEME_DARK_CLASS } from '../core/consts.js'\n\nexport const globalStyle = `\n  :root {\n    --main-bg: white;\n    --main-bg-active: #ddd;\n    --main-bg-hover: #e3e3e3;\n    --main-fg: #111;\n    --main-fg-active: #111;\n    --main-fg-hover: #111;\n    --main-border: #666;\n    --main-bg-blue: #03c;\n    --main-fg-blue: #DDD;\n    --main-bg-highlight: rgba(10, 120, 220, 0.3);\n    --main-fg-highlight: var(--main-fg);\n  }\n  :root.${COLOR_SCHEME_DARK_CLASS}  {\n    --main-bg: #1a1b1e;\n    --main-bg-active: #555;\n    --main-bg-hover: #444;\n    --main-fg: #ccc;\n    --main-fg-active: #ccc;\n    --main-fg-hover: #ccc;\n    --main-border: #777;\n  }\n`\n","import { useMediaQuery } from '@react-hookz/web'\nimport { App, ConfigProvider, theme } from 'antd'\nimport { useUserColorScheme, type ColorScheme } from './store.js'\n\nconst { defaultAlgorithm, darkAlgorithm } = theme\n\nexport const useColorScheme = (): ColorScheme => {\n  const prefersDarkMode = useMediaQuery('(prefers-color-scheme: dark)')\n  const [userColorScheme] = useUserColorScheme()\n\n  const mode: ColorScheme =\n    userColorScheme === 'system'\n      ? prefersDarkMode\n        ? 'dark'\n        : 'light'\n      : userColorScheme\n\n  return mode\n}\n\nexport const AntdConfigProvider = ({\n  children,\n}: {\n  children: React.ReactNode\n}) => {\n  const colorScheme = useColorScheme()\n  return (\n    <ConfigProvider\n      theme={{\n        algorithm: colorScheme === 'dark' ? darkAlgorithm : defaultAlgorithm,\n        components: {\n          InputNumber: {\n            handleVisible: true,\n          },\n        },\n      }}\n    >\n      <App className=\"app\">{children}</App>\n    </ConfigProvider>\n  )\n}\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACJA;AAOA;AAIA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AC5DA;AAaA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACTA;AADA;AAKA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA5BA;;AAFA;;AAAA;;AAEA;AAFA;AAEA;AA6BA;AAGA;AADA;AAGA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAtBA;;AAAA;;;AAuBA;AAMA;AAJA;;AAEA;AAIA;AAIA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAhBA;;AAAA;;;AAiBA;;;;;;;;;;;;;;;;;;;;;;ACzFA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AAeA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAgBA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAGA;AAEA;AAAA;;AAEA;AACA;AACA;AAEA;AAAA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAAA;AAEA;AAGA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AArKA;AAHA;AACA;AAGA;AACA;AAoKA;;;;;;;;;;;;;;;;;;;;;;;;;ACjOA;AACA;AAEA;AAIA;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACpEA;AAEA;AAEA;AAEA;AACA;AAMA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1CA;;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;;AAEA;;;;;AACA;;;;;AACA;AACA;AAAA;;;;;;;;AAIA;AAnCA;;AACA;AAuBA;;;AAxBA;AAqCA;AACA;AAEA;AAAA;;AACA;;;;;AACA;;;;;AACA;;;;;AACA;;;;;AACA;;;;;AACA;;;;;AACA;;;;;AACA;;;;;;;;;;;;;;;;AAIA;AAfA;AAiBA;AACA;AACA;AACA;;;;;;;;;;AAGA;AANA;;;;;;;;;;;;;;;;;;;;;;;;;AC/EA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAjBA;;AACA;;;AAkBA;AAAA;;AAWA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AACA;AACA;AAAA;AAEA;AAlCA;;AAWA;AACA;AACA;AAeA;;;AAQA;;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;;;;;;AACA;;;;;;;AAGA;AAEA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AACA;;;;;;AAEA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAnDA;;AACA;AAgBA;;;AAjBA;AAqDA;;AACA;AAEA;AAEA;;;;;AACA;AANA;;AACA;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3IA;AACA;AACA;AAEA;AACA;AAEA;;AACA;AAEA;AAGA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAtBA;;AACA;;;AAuBA;;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;;;;;;AAGA;AAVA;;AACA;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AAEA;AAEA;;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAIA;AAjCA;;AACA;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLA;AACA;AAOA;AAEA;AAYA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AAiBA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;AAKA;AAlEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AAWA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAAA;;AAEA;AAAA;;;;;;AACA;AAAA;;;;;;;AANA;;;;;AASA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;AAKA;AApDA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AAAA;AAQA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAGA;AAtBA;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AAUA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AAdA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;AAEA;AACA;AACA;AAEA;AADA;AACA;AACA;AAEA;AAAA;;;;;;;;;;;AAEA;AAAA;;;;;;AACA;AACA;AACA;AAEA;AADA;AACA;AACA;AAEA;AAAA;;;;;;;;;;;;;;;;;AAIA;AACA;AAAA;;;;;;AACA;AA/BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AAOA;AAAA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AA1BA;;AACA;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;ACXA;AAOA;AAAA;;AACA;AACA;AACA;AAHA;;AACA;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAKA;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;AAIA;AAjFA;;AAIA;AACA;;;AALA;;;;;;;;;;;;;;;;;;;;;;;;;;AC9NA;AAEA;AACA;AAAA;AAAA;AAAA;;;;;;AACA;AAFA;AAIA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;AAGA;AAPA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AAEA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AAGA;AAFA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;;AAGA;AAnBA;;;;;;;;;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;AC5BA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACXA;AACA;AAEA;AAKA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACbA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AAHA;;AACA;;;AAIA;;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AANA;;AACA;;;AADA;AAQA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AApBA;;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiCA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAIA;AAKA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAvDA;AAyDA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAHA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AArBA;;AACA;;;AAsBA;;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AACA;AAAA;AACA;AACA;AAAA;;;;;;;;;;AAGA;AAAA;AAAA;;;;;;;AANA;;;;;;;;;;;;;;;;AAaA;AA/CA;;AAEA;AACA;AACA;AAQA;;;AAZA;;;;;;;;;;;;;;;;;;;;;;;;;AC9MA;AACA;AACA;AACA;AAEA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AAEA;AAAA;;;;;;AAEA;AACA;;AACA;AAAA;AAAA;;;;;;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;;;;;;AACA;;;;;;;;;;;;;;;;;AAMA;AAjBA;;AACA;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AAIA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AACA;AACA;AACA;AACA;AACA;;;;;AACA;AACA;AACA;AACA;AACA;;;;;AACA;AACA;;;;;;AAGA;AA1BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAKA;AA7FA;;AACA;AAEA;AACA;;;AAJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAQA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;;;;;;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAKA;AAvEA;;AACA;AAEA;AACA;;;AAJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAQA;;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;;;;;;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;;;;;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAGA;AAEA;;;;;;;;;;;;;;;;;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AAMA;AAlFA;;AACA;AAGA;;;AAJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAOA;AAAA;;AAOA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAKA;AA9CA;;AAOA;;;AAPA;AAgDA;AAAA;;AACA;AAAA;AAAA;AAEA;;;;;AAEA;AAAA;AAAA;;;;;;AACA;AANA;;AACA;;;AADA;AAQA;AAGA;AAAA;AAAA;AAEA;;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAzBA;;AACA;AACA;;;AAyBA;;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAKA;AAxBA;;AACA;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;;;;;AACA;;AACA;AAAA;AAAA;;;;;;;;;;AACA;AAAA;AAAA;;;;;;;;;;AACA;AACA;AACA;;;;;;;;;;AAEA;AAAA;AAAA;;;;;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AAIA;AAhBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAXA;;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfA;AACA;AAOA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AAEA;AASA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAAA;;;;;;;;;;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AA7BA;AA+BA;;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAGA;AAEA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AAKA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvEA;AAyEA;AAAA;;AAyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAGA;AAEA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjQA;;AAyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAiOA;AAAA;;AAOA;AAEA;AACA;AAIA;AAAA;AAAA;AAEA;AAEA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;AAIA;AA7DA;;AAOA;AASA;;;AAhBA;AA+DA;AAAA;;AAyBA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AADA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAEA;AACA;AAAA;AAAA;;;;;;;;;;;;AAtFA;;;;;AA0FA;AA9KA;;AAyBA;AACA;AAGA;AAqBA;;;AAlDA;AAgLA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAAA;;;;;AAAA;AAEA;;;;;;AAGA;AAvBA;;AACA;;;AADA;AAyBA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;;AAEA;AAAA;;;;;;AACA;;;AAGA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;AAKA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;AAEA;AAGA;AACA;AACA;AACA;AACA;;;;;AAEA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;AAEA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AAIA;AACA;AAAA;;;;;AAEA;;AACA;AACA;AAAA;;AACA;AACA;;AACA;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAGA;AAAA;;;;;;AACA;AAAA;;;;;;AACA;AAAA;;;;;;AACA;;;;;;;;;;;;;;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAGA;;;;;;;;;;;;AAGA;;;;;;;;;;AAMA;AA7TA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAGA;AA0BA;AAyBA;AAeA;AA6GA;;;AA7LA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACntBA;AAcA;AAEA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AAIA;AAAA;AACA;AAKA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/DA;;AAKA;AAKA;;;AAuDA;;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;;AACA;AACA;;;;;;;AAGA;AAnBA;;AACA;AACA;AACA;;;AAHA;AAqBA;AAAA;;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;;AAEA;;;;;AAEA;;;;;AAEA;;;;;AACA;AAvBA;;AACA;AACA;;;AAFA;AAyBA;;AACA;AAEA;AAAA;;;;;;AAEA;AAAA;;;;;;AACA;AANA;;AACA;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAIA;;AACA;AACA;AAAA;AACA;AACA;AACA;AALA;AAOA;AAAA;;AASA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;;;;;;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AAAA;;;;;;AACA;;AACA;AACA;AAAA;AAAA;;;;;;AACA;;;;;;;;AAVA;;;;;AAcA;;;;;;AAEA;AAAA;;AACA;AAAA;AAAA;;;;;;;;;;;;;AAIA;AArGA;;AAiCA;;;AAjCA;AAuGA;AAAA;;AAOA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAUA;AARA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AADA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;;;;;;;;;;;;;;;;;AAGA;AACA;AACA;AACA;;;;;;;;;;;;AAIA;AAvEA;;AAOA;AACA;AAKA;AAiBA;;;AA9BA;AAyEA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAAA;AAGA;;AAEA;AACA;AACA;AACA;AAAA;;;;;;AACA;AACA;AACA;AAEA;;;;;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;;;;;;;;;;;;AAIA;AA9CA;;AACA;AASA;AAOA;;;AAjBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjNA;AACA;AAEA;;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AAEA;;AA6CA;AAdA;AAUA;AACA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AA+JA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAhMA;AAqBA;AAQA;AA0DA;AAoDA;AAYA;;;AA3JA;AAaA;;AAAA;;AACA;;AAAA;;AA6DA;;AAAA;;AAtEA;AACA;AANA;AAcA;AA6DA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlFA;AA8LA;AA5KA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAkBA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACvNA;AACA;AAEA;;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AAIA;AAEA;;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAAA;;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAAA;;;;;;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AAIA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;AAMA;AACA;AAjEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACTA;AAKA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAgBA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;AAIA;AACA;;AAAA;AAAA;;;;;;;;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA;AAjHA;AAmHA;AAAA;;AAWA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;;AACA;AAIA;AAGA;AACA;AACA;AACA;AACA;AALA;;;;;;;;;;AAUA;;;;;;;AAGA;AApHA;;AAWA;AAIA;;;AAfA;AAsHA;;AAMA;AAEA;AAGA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAKA;AAAA;AAAA;AAGA;AAKA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AA7DA;;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrQA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAAA;;AACA;AAEA;AACA;AAEA;AAEA;AADA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAAA;;;;;;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AAIA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;AAMA;AACA;AA9EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACTA;AAMA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;;AAWA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AADA;;;;;;;;;;;;;;;AAOA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;AAEA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA;AApHA;;AAWA;;;AAXA;AAsHA;AAAA;;AAOA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;;AACA;AAIA;AAGA;AACA;AACA;AACA;AAJA;;;;;;;;;;AASA;;;;;;;AAGA;AArGA;;AAOA;AAIA;;;AAXA;AAuGA;;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;;;;;;AACA;AACA;AAxBA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrPA;AACA;AAEA;AACA;AAGA;AAAA;AAWA;AAEA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AAdA;;;;;AAkBA;;;;;;AAGA;AA7CA;AA+CA;AAAA;;AASA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;;;;;AAGA;;;;;;AAIA;AAnFA;;AASA;;;AATA;AAqFA;AAKA;AACA;AACA;AAAA;AAAA;;;;;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrJA;AACA;AAGA;AAEA;AACA;AACA;AAEA;;AAOA;AACA;AACA;AAMA;AAEA;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AAAA;;;;;;AACA;;;AAGA;;AAEA;AAAA;;;;;;AACA;;;AAGA;;AAEA;AAAA;;;;;;AACA;;;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAlEA;;AAOA;AACA;AACA;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AAEA;AACA;AAGA;AASA;AACA;AA0CA;AAvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAwCA;AAvCA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;;AAEA;AAAA;;;;;;AACA;;AAAA;AAAA;;;;;;;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;;;AAMA;AAGA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAIA;AAFA;;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAMA;AAFA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AA9IA;;AAJA;AAEA;AAEA;AACA;AACA;AA6IA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7JA;AACA;AACA;AAEA;AAEA;AAEA;AAYA;AAMA;AAMA;AAKA;AACA;AACA;AAKA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAsWA;AApUA;AA8BA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AA+DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAGA;AASA;AADA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AAGA;AASA;AADA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAGA;AAWA;AAHA;AACA;AAEA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAIA;AACA;AAEA;AAGA;AAQA;AANA;AACA;AACA;AACA;AACA;AAIA;AACA;AAMA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AAIA;;AAEA;AAEA;AAUA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AAsBA;;;AAGA;;;AAGA;;AAEA;AACA;AACA;;;;;;;;;AASA;;;;AAMA;;;;AAKA;;;AAIA;AACA;AAEA;AACA;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;AAiBA;;;;AAIA;;;;;;AAMA;AACA;;;;;;AAMA;;;;AAIA;AACA;;;;AAIA;;AAEA;;;;;;;;AAQA;;;;;;;AAOA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AA0BA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AADA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAIA;AAKA;AAIA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AADA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAkBA;AACA;AAlBA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AADA;AACA;AAGA;AACA;AAGA;AACA;;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAIA;AAYA;AAXA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAIA;AAKA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvyCA;;;;AAnDA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAwSA;;AAAA;;AAoEA;;AAAA;;AAyUA;AA0fA;;AAAA;;AAtpCA;AACA;AACA;AAtDA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AAMA;AAKA;AACA;AACA;AAKA;AAwrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9qBA;AAEA;AAKA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AA6uCA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACj8CA;AACA;AACA;AACA;AAEA;AACA;AAGA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAqBA;AAdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAoCA;AAjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA4BA;AA3BA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;AAGA;AAIA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AApHA;;AAJA;AAEA;AAEA;AACA;AACA;AAmHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClIA;AAGA;AACA;AA2BA;AADA;AAYA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAiBA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AACA;;AAlIA;;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAoDA;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAyDA;AAEA;AAEA;;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApDA;AAsDA;AAEA;;AAaA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAEA;AAEA;AAAA;AAEA;AAEA;AAAA;AAEA;AAEA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAzEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3NA;AAgBA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AAEA;AAAA;AAAA;AACA;AACA;AACA;;;;;;AAGA;AAbA;AAeA;AAAA;;AAWA;;AAGA;AACA;AAAA;AAAA;;;;;AAAA;;;;;;AAGA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;;;;;;;;;;;AAGA;AA7BA;AAAA;AA+BA;AAAA;;AAWA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAGA;AACA;AAAA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAGA;AAjEA;AAAA;AAmEA;;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;;;;;;AAGA;AArBA;;AACA;AACA;AACA;;;AAHA;AAuBA;;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;AAIA;AAxBA;;AACA;AACA;;;AAFA;AA0BA;AAAA;;AAWA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;;;;;;AAPA;;;;;AASA;AAGA;AACA;AACA;AACA;AAGA;AAEA;AAAA;;;;;;AATA;;;;AAWA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;;;;;;AAPA;;;;;AASA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAAA;;;;;;AAPA;;;;AASA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;;;;;;AAPA;;;;AASA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;;;;;AARA;;;;AAUA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;;;;;AARA;;;;;AAYA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;;;;AAAA;AAAA;;;;;;AARA;;;;;AAYA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;;;;;AARA;;;;AAUA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;;;;;AARA;;;;;AAYA;AAIA;AACA;AACA;AAEA;AACA;;;;;AAEA;AAAA;;;;;;AARA;;;;;AAaA;AAAA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAJA;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AAGA;AAAA;AAAA;AAEA;AACA;AAAA;;AACA;AAAA;AAAA;AAEA;AACA;AAAA;;AACA;AAAA;AAAA;AAEA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;;AACA;AAAA;;;;;;AACA;;;;;AACA;;;;;;;;;;;AAGA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1QA;;AAWA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAgOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/cA;AAEA;AAGA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AA0CA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAWA;AAMA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAGA;AACA;AArLA;;AAPA;AACA;AACA;AACA;AACA;AACA;AAGA;AAHA;AAAA;AAAA;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAsJA;AAEA;;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAdA;;AASA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;AC1NA;AAAA;AAOA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAIA;AAnCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AClEA;AAIA;AAMA;AAEA;AAEA;AAgBA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtHA;;AAJA;AACA;AACA;AAGA;AAIA;AACA;AAEA;AACA;AA8GA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3IA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAIA;AACA;AAAA;AAAA;AACA;AACA;;;;;;AAEA;AACA;AACA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA1JA;;AACA;AASA;AACA;AACA;AAEA;AACA;AAUA;AAKA;AAmHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClKA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;;;;;;;;;;AAGA;AAdA;;AACA;AACA;;;AAFA;AAgBA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAAA;AAAA;;;;;;;;;;AACA;AAAA;AAAA;;;;;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;AACA;AACA;AACA;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAMA;AA1EA;;AACA;AACA;AACA;AACA;;;AAJA;AA4EA;AACA;AAEA;;;;;;;;;;AAGA;AANA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAyBA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;;;;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;AAKA;;;;;;;AAGA;AA/KA;;AAKA;;;AALA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAKA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;;;;;;;;;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAEA;;;;;;;;;;;;AAIA;AA/JA;;AACA;AACA;AAEA;;;AAJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjBA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAiBA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAGA;AAbA;AAeA;AAAA;AAOA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;AAEA;AAVA;AAYA;;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;AAIA;AAZA;;AACA;;;AADA;AAcA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAIA;AAxBA;;AACA;AACA;;;AAFA;AA0BA;AAAA;AAOA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AACA;AAEA;;AACA;AACA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;AAJA;;;;;AAQA;;;;;;AAIA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAKA;AAzCA;AA2CA;;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAIA;AAbA;;AACA;;;AADA;AAeA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;AAIA;AAdA;;AACA;;;AADA;AAgBA;;AACA;AACA;;AAEA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AAKA;AA3BA;;AACA;;;AADA;AA6BA;;AACA;AACA;AAEA;;AACA;AAAA;AAAA;AAAA;AACA;;;;;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AADA;;;;;AAIA;;;;;;;;;;;;;;;;;;AAMA;AA3BA;;AACA;;;AADA;AA6BA;;AACA;AACA;;AAEA;;AAAA;AAAA;;;;;;;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAIA;AAfA;;AACA;;;AADA;AAiBA;;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;;;;;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AADA;;;;;AAIA;;;;;;;;;;;;;;;;;AAKA;AAzBA;;AACA;;;AADA;AA2BA;;AACA;AACA;;AAEA;AAAA;;;;;;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAIA;AAfA;;AACA;;;AADA;AAiBA;AACA;AACA;;AACA;;;;;AACA;;;;;AACA;;;;;AACA;;;;;AACA;;;;;AACA;;;;;AACA;;;;;AACA;;;;;AACA;;;;;;;;;;;AAGA;AAdA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/RA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AAaA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlCA;;AAaA;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;AACA;AAAA;;;;;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;;;;;;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;AAGA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAhEA;;AACA;AAEA;AACA;;;AAJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;;;;;;AAGA;AAhBA;;AACA;AACA;;;AAFA;;;;;;;;;;;;;;;;;;;;;;;ACNA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClCA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAKA;AACA;AACA;AAEA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;;AAjBA;;;AAkBA;AAGA;AAGA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAzBA;;AACA;AACA;;;AAyBA;;AACA;AAEA;AAEA;AAAA;AAAA;AAGA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAnBA;;AACA;;;AAoBA;;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AA/BA;;AACA;AACA;;;AA+BA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACxNA;AAEA;;;;;;;;;;;;;;AAcA;;;;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AAEA;AAEA;;AACA;AACA;AAEA;AAOA;AACA;AAZA;;AACA;AACA;;;AAYA;AAAA;;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;;;;;;;;;;AAGA;AApBA;;AAKA;;;AALA"}